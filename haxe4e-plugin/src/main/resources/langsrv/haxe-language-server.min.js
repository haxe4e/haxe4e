// Generated by Haxe 5.0.0-alpha.1+b1b235b
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class DateTools {
	static __format_get(d,e) {
		switch(e) {
		case "%":
			return "%";
		case "A":
			return DateTools.DAY_NAMES[d.getDay()];
		case "B":
			return DateTools.MONTH_NAMES[d.getMonth()];
		case "C":
			return StringTools.lpad(Std.string(d.getFullYear() / 100 | 0),"0",2);
		case "D":
			return DateTools.__format(d,"%m/%d/%y");
		case "F":
			return DateTools.__format(d,"%Y-%m-%d");
		case "M":
			return StringTools.lpad(Std.string(d.getMinutes()),"0",2);
		case "R":
			return DateTools.__format(d,"%H:%M");
		case "S":
			return StringTools.lpad(Std.string(d.getSeconds()),"0",2);
		case "T":
			return DateTools.__format(d,"%H:%M:%S");
		case "Y":
			return Std.string(d.getFullYear());
		case "a":
			return DateTools.DAY_SHORT_NAMES[d.getDay()];
		case "d":
			return StringTools.lpad(Std.string(d.getDate()),"0",2);
		case "e":
			return Std.string(d.getDate());
		case "b":case "h":
			return DateTools.MONTH_SHORT_NAMES[d.getMonth()];
		case "H":case "k":
			return StringTools.lpad(Std.string(d.getHours()),e == "H" ? "0" : " ",2);
		case "I":case "l":
			let hour = d.getHours() % 12;
			return StringTools.lpad(Std.string(hour == 0 ? 12 : hour),e == "I" ? "0" : " ",2);
		case "m":
			return StringTools.lpad(Std.string(d.getMonth() + 1),"0",2);
		case "n":
			return "\n";
		case "p":
			if(d.getHours() > 11) {
				return "PM";
			} else {
				return "AM";
			}
			break;
		case "r":
			return DateTools.__format(d,"%I:%M:%S %p");
		case "s":
			return Std.string(d.getTime() / 1000 | 0);
		case "t":
			return "\t";
		case "u":
			let t = d.getDay();
			if(t == 0) {
				return "7";
			} else if(t == null) {
				return "null";
			} else {
				return "" + t;
			}
			break;
		case "w":
			return Std.string(d.getDay());
		case "y":
			return StringTools.lpad(Std.string(d.getFullYear() % 100),"0",2);
		default:
			throw new haxe_exceptions_NotImplementedException("Date.format %" + e + "- not implemented yet.",null,{ fileName : "DateTools.hx", lineNumber : 101, className : "DateTools", methodName : "__format_get"});
		}
	}
	static __format(d,f) {
		let r_b = "";
		let p = 0;
		while(true) {
			let np = f.indexOf("%",p);
			if(np < 0) {
				break;
			}
			let len = np - p;
			r_b += len == null ? HxOverrides.substr(f,p,null) : HxOverrides.substr(f,p,len);
			r_b += Std.string(DateTools.__format_get(d,HxOverrides.substr(f,np + 1,1)));
			p = np + 2;
		}
		let len = f.length - p;
		r_b += len == null ? HxOverrides.substr(f,p,null) : HxOverrides.substr(f,p,len);
		return r_b;
	}
	static format(d,f) {
		return DateTools.__format(d,f);
	}
}
DateTools.__name__ = "DateTools";
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	matched(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	matchedRight() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		let sz = this.r.m.index + this.r.m[0].length;
		return HxOverrides.substr(this.r.s,sz,this.r.s.length - sz);
	}
	matchedPos() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	matchSub(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			let b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			let b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	split(s) {
		return s.replace(this.r,"#__delim__#").split("#__delim__#");
	}
	map(s,f) {
		let offset = 0;
		let buf_b = "";
		do {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			let p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
		} while(this.r.global);
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
}
EReg.__name__ = "EReg";
Object.assign(EReg.prototype, {
	__class__: EReg
});
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static remove(a,obj) {
		let i = a.indexOf(obj);
		if(i == -1) {
			return false;
		}
		a.splice(i,1);
		return true;
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = "HxOverrides";
class json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		this.errors = errors;
		this.putils = putils;
		this.errorType = errorType;
	}
	fromJson(jsonString,filename) {
		if(filename == null) {
			filename = "";
		}
		this.putils = new json2object_PositionUtils(jsonString);
		this.errors = [];
		try {
			this.loadJson(new hxjsonast_Parser(jsonString,filename).doParse());
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof hxjsonast_Error)) {
				let e = _g1;
				this.errors.push(json2object_Error.ParserError(e.message,this.putils.convertPosition(e.pos)));
			} else {
				throw _g;
			}
		}
		return this.value;
	}
	loadJson(json,variable) {
		if(variable == null) {
			variable = "";
		}
		let pos = this.putils.convertPosition(json.pos);
		let _g = json.value;
		switch(_g._hx_index) {
		case 0:
			this.loadJsonString(_g.s,pos,variable);
			break;
		case 1:
			this.loadJsonNumber(_g.s,pos,variable);
			break;
		case 2:
			this.loadJsonObject(_g.fields,pos,variable);
			break;
		case 3:
			this.loadJsonArray(_g.values,pos,variable);
			break;
		case 4:
			this.loadJsonBool(_g.b,pos,variable);
			break;
		case 5:
			this.loadJsonNull(pos,variable);
			break;
		}
		return this.value;
	}
	loadJsonNull(pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	loadJsonString(s,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	loadString(s,pos,variable,validValues,defaultValue) {
		if(validValues.indexOf(s) != -1) {
			return s;
		}
		this.onIncorrectType(pos,variable);
		return defaultValue;
	}
	loadJsonNumber(f,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	loadJsonInt(f,pos,variable,value) {
		if(Std.parseInt(f) != null && Std.parseInt(f) == parseFloat(f)) {
			return Std.parseInt(f);
		}
		this.onIncorrectType(pos,variable);
		return value;
	}
	loadJsonBool(b,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	loadJsonArray(a,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	loadJsonArrayValue(a,loadJsonFn,variable) {
		let _g = [];
		let _g1 = 0;
		while(_g1 < a.length) {
			let j = a[_g1++];
			let tmp;
			try {
				tmp = loadJsonFn(j,variable);
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				let _g1 = haxe_Exception.caught(_g).unwrap();
				if(js_Boot.__instanceof(_g1,json2object_InternalError)) {
					let e = _g1;
					if(e != json2object_InternalError.ParsingThrow) {
						throw haxe_Exception.thrown(e);
					}
					continue;
				} else {
					throw _g;
				}
			}
			_g.push(tmp);
		}
		return _g;
	}
	loadJsonObject(o,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	loadObjectField(loadJsonFn,field,name,assigned,defaultValue,pos) {
		try {
			let ret = loadJsonFn(field.value,field.name);
			this.mapSet(assigned,name,true);
			return ret;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(js_Boot.__instanceof(_g1,json2object_InternalError)) {
				let e = _g1;
				if(e != json2object_InternalError.ParsingThrow) {
					throw haxe_Exception.thrown(e);
				}
			} else {
				this.errors.push(json2object_Error.CustomFunctionException(_g1,pos));
			}
		}
		return defaultValue;
	}
	objectSetupAssign(assigned,keys,values) {
		let _g = 0;
		let _g1 = keys.length;
		while(_g < _g1) {
			let i = _g++;
			this.mapSet(assigned,keys[i],values[i]);
		}
	}
	objectErrors(assigned,pos) {
		let lastPos = this.putils.convertPosition(new hxjsonast_Position(pos.file,pos.max - 1,pos.max - 1));
		let s_keys = Object.keys(assigned.h);
		let s_length = s_keys.length;
		let s_current = 0;
		while(s_current < s_length) {
			let s = s_keys[s_current++];
			if(!assigned.h[s]) {
				this.errors.push(json2object_Error.UninitializedVariable(s,lastPos));
			}
		}
	}
	onIncorrectType(pos,variable) {
		this.parsingThrow();
	}
	parsingThrow() {
		if(this.errorType != 0) {
			throw haxe_Exception.thrown(json2object_InternalError.ParsingThrow);
		}
	}
	objectThrow(pos,variable) {
		if(this.errorType == 2) {
			throw haxe_Exception.thrown(json2object_InternalError.ParsingThrow);
		}
		if(this.errorType == 1) {
			this.errors.push(json2object_Error.UninitializedVariable(variable,pos));
		}
	}
	mapSet(map,key,value) {
		map.h[key] = value;
	}
}
json2object_reader_BaseParser.__name__ = "json2object.reader.BaseParser";
Object.assign(json2object_reader_BaseParser.prototype, {
	__class__: json2object_reader_BaseParser
});
class JsonParser_$1 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?wrapping : Null<formatter.config.WrapConfig>, ?whitespace : Null<formatter.config.WhitespaceConfig>, ?sameLine : Null<formatter.config.SameLineConfig>, ?lineEnds : Null<formatter.config.LineEndConfig>, ?indentation : Null<formatter.config.IndentationConfig>, ?excludes : Null<Array<String>>, ?emptyLines : Null<formatter.config.EmptyLinesConfig>, ?disableFormatting : Null<Bool> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["disableFormatting","emptyLines","excludes","indentation","lineEnds","sameLine","whitespace","wrapping"],[true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "disableFormatting":
				this.value.disableFormatting = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"disableFormatting",assigned,this.value.disableFormatting,pos);
				break;
			case "emptyLines":
				this.value.emptyLines = this.loadObjectField(($_=new JsonParser_$4(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"emptyLines",assigned,this.value.emptyLines,pos);
				break;
			case "excludes":
				this.value.excludes = this.loadObjectField(($_=new JsonParser_$66(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"excludes",assigned,this.value.excludes,pos);
				break;
			case "indentation":
				this.value.indentation = this.loadObjectField(($_=new JsonParser_$33(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentation",assigned,this.value.indentation,pos);
				break;
			case "lineEnds":
				this.value.lineEnds = this.loadObjectField(($_=new JsonParser_$36(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineEnds",assigned,this.value.lineEnds,pos);
				break;
			case "sameLine":
				this.value.sameLine = this.loadObjectField(($_=new JsonParser_$39(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"sameLine",assigned,this.value.sameLine,pos);
				break;
			case "whitespace":
				this.value.whitespace = this.loadObjectField(($_=new JsonParser_$42(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whitespace",assigned,this.value.whitespace,pos);
				break;
			case "wrapping":
				this.value.wrapping = this.loadObjectField(($_=new JsonParser_$60(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"wrapping",assigned,this.value.wrapping,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { disableFormatting : false, emptyLines : new JsonParser_$4([],this.putils,0).getAuto(), excludes : ["\\.haxelib","\\.git","node_modules"], indentation : new JsonParser_$33([],this.putils,0).getAuto(), lineEnds : new JsonParser_$36([],this.putils,0).getAuto(), sameLine : new JsonParser_$39([],this.putils,0).getAuto(), whitespace : new JsonParser_$42([],this.putils,0).getAuto(), wrapping : new JsonParser_$60([],this.putils,0).getAuto()};
	}
}
JsonParser_$1.__name__ = "JsonParser_1";
JsonParser_$1.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$1.prototype, {
	__class__: JsonParser_$1
});
class JsonParser_$112 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "beforeLast";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrappingLocation",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["beforeLast","afterLast"],"beforeLast");
	}
}
JsonParser_$112.__name__ = "JsonParser_112";
JsonParser_$112.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$112.prototype, {
	__class__: JsonParser_$112
});
class JsonParser_$114 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "onePerLine";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrappingType",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["onePerLine","onePerLineAfterFirst","equalNumber","fillLine","fillLineWithLeadingBreak","noWrap","keep"],"onePerLine");
	}
}
JsonParser_$114.__name__ = "JsonParser_114";
JsonParser_$114.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$114.prototype, {
	__class__: JsonParser_$114
});
class JsonParser_$116 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Array<formatter.config.WrapRule>",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonArray(a,pos,variable) {
		this.value = this.loadJsonArrayValue(a,($_=new JsonParser_$118(this.errors,this.putils,2),$bind($_,$_.loadJson)),variable);
	}
}
JsonParser_$116.__name__ = "JsonParser_116";
JsonParser_$116.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$116.prototype, {
	__class__: JsonParser_$116
});
class JsonParser_$118 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ type : formatter.config.WrappingType, ?location : Null<formatter.config.WrappingLocation>, conditions : Array<formatter.config.WrapCondition>, ?additionalIndent : Null<Int> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["additionalIndent","conditions","location","type"],[true,false,true,false]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "additionalIndent":
				this.value.additionalIndent = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"additionalIndent",assigned,this.value.additionalIndent,pos);
				break;
			case "conditions":
				this.value.conditions = this.loadObjectField(($_=new JsonParser_$119(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditions",assigned,this.value.conditions,pos);
				break;
			case "location":
				this.value.location = this.loadObjectField(($_=new JsonParser_$112(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"location",assigned,this.value.location,pos);
				break;
			case "type":
				this.value.type = this.loadObjectField(($_=new JsonParser_$120(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"type",assigned,this.value.type,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { additionalIndent : 0, conditions : new JsonParser_$119([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1))), location : "afterLast", type : new JsonParser_$120([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)))};
	}
}
JsonParser_$118.__name__ = "JsonParser_118";
JsonParser_$118.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$118.prototype, {
	__class__: JsonParser_$118
});
class JsonParser_$119 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Array<formatter.config.WrapCondition>",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonArray(a,pos,variable) {
		this.value = this.loadJsonArrayValue(a,($_=new JsonParser_$122(this.errors,this.putils,2),$bind($_,$_.loadJson)),variable);
	}
}
JsonParser_$119.__name__ = "JsonParser_119";
JsonParser_$119.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$119.prototype, {
	__class__: JsonParser_$119
});
class JsonParser_$12 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?beforeError : Null<Int>, ?beforeEnd : Null<Int>, ?beforeElse : Null<Int>, ?afterIf : Null<Int>, ?afterError : Null<Int>, ?afterElse : Null<Int> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterElse","afterError","afterIf","beforeElse","beforeEnd","beforeError"],[true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "afterElse":
				this.value.afterElse = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterElse",assigned,this.value.afterElse,pos);
				break;
			case "afterError":
				this.value.afterError = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterError",assigned,this.value.afterError,pos);
				break;
			case "afterIf":
				this.value.afterIf = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterIf",assigned,this.value.afterIf,pos);
				break;
			case "beforeElse":
				this.value.beforeElse = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeElse",assigned,this.value.beforeElse,pos);
				break;
			case "beforeEnd":
				this.value.beforeEnd = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeEnd",assigned,this.value.beforeEnd,pos);
				break;
			case "beforeError":
				this.value.beforeError = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeError",assigned,this.value.beforeError,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { afterElse : 0, afterError : 0, afterIf : 0, beforeElse : 0, beforeEnd : 0, beforeError : 0};
	}
}
JsonParser_$12.__name__ = "JsonParser_12";
JsonParser_$12.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$12.prototype, {
	__class__: JsonParser_$12
});
class JsonParser_$120 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "onePerLine";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrappingType",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["onePerLine","onePerLineAfterFirst","equalNumber","fillLine","fillLineWithLeadingBreak","noWrap","keep"],"onePerLine");
	}
}
JsonParser_$120.__name__ = "JsonParser_120";
JsonParser_$120.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$120.prototype, {
	__class__: JsonParser_$120
});
class JsonParser_$122 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?value : Null<Int>, cond : formatter.config.WrapConditionType }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["cond","value"],[false,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "cond":
				this.value.cond = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"cond",assigned,this.value.cond,pos);
				break;
			case "value":
				this.value.value = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"value",assigned,this.value.value,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { cond : new JsonParser_$123([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1))), value : 1};
	}
}
JsonParser_$122.__name__ = "JsonParser_122";
JsonParser_$122.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$122.prototype, {
	__class__: JsonParser_$122
});
class JsonParser_$123 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "itemCount >= n";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrapConditionType",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["itemCount >= n","itemCount <= n","anyItemLength >= n","anyItemLength <= n","totalItemLength >= n","totalItemLength <= n","lineLength >= n","lineLength <= n","hasMultilineItems","exceedsMaxLineLength"],"itemCount >= n");
	}
}
JsonParser_$123.__name__ = "JsonParser_123";
JsonParser_$123.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$123.prototype, {
	__class__: JsonParser_$123
});
class JsonParser_$125 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WhitespacePolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","before","noneBefore","onlyBefore","after","onlyAfter","noneAfter","around"],"none");
	}
}
JsonParser_$125.__name__ = "JsonParser_125";
JsonParser_$125.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$125.prototype, {
	__class__: JsonParser_$125
});
class JsonParser_$15 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenVars : Null<Int>, ?betweenFunctions : Null<Int>, ?beginType : Null<Int>, ?afterVars : Null<Int> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterVars","beginType","betweenFunctions","betweenVars","endType","existingBetweenFields"],[true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "afterVars":
				this.value.afterVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterVars",assigned,this.value.afterVars,pos);
				break;
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType,pos);
				break;
			case "betweenFunctions":
				this.value.betweenFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFunctions",assigned,this.value.betweenFunctions,pos);
				break;
			case "betweenVars":
				this.value.betweenVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenVars",assigned,this.value.betweenVars,pos);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType,pos);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { afterVars : 1, beginType : 0, betweenFunctions : 1, betweenVars : 0, endType : 0, existingBetweenFields : "keep"};
	}
}
JsonParser_$15.__name__ = "JsonParser_15";
JsonParser_$15.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$15.prototype, {
	__class__: JsonParser_$15
});
class JsonParser_$165 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "same";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.SameLinePolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["same","next","keep"],"same");
	}
}
JsonParser_$165.__name__ = "JsonParser_165";
JsonParser_$165.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$165.prototype, {
	__class__: JsonParser_$165
});
class JsonParser_$168 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?rightCurly : Null<formatter.config.RightCurlyLineEndPolicy>, ?leftCurly : Null<formatter.config.LeftCurlyLineEndPolicy>, ?emptyCurly : Null<formatter.config.EmptyCurlyPolicy> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["emptyCurly","leftCurly","rightCurly"],[true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "emptyCurly":
				this.value.emptyCurly = this.loadObjectField(($_=new JsonParser_$176(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"emptyCurly",assigned,this.value.emptyCurly,pos);
				break;
			case "leftCurly":
				this.value.leftCurly = this.loadObjectField(($_=new JsonParser_$178(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"leftCurly",assigned,this.value.leftCurly,pos);
				break;
			case "rightCurly":
				this.value.rightCurly = this.loadObjectField(($_=new JsonParser_$186(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"rightCurly",assigned,this.value.rightCurly,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { emptyCurly : "noBreak", leftCurly : "after", rightCurly : "both"};
	}
}
JsonParser_$168.__name__ = "JsonParser_168";
JsonParser_$168.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$168.prototype, {
	__class__: JsonParser_$168
});
class JsonParser_$174 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.CaseColonLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after"],"none");
	}
}
JsonParser_$174.__name__ = "JsonParser_174";
JsonParser_$174.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$174.prototype, {
	__class__: JsonParser_$174
});
class JsonParser_$176 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "noBreak";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.EmptyCurlyPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["noBreak","break"],"noBreak");
	}
}
JsonParser_$176.__name__ = "JsonParser_176";
JsonParser_$176.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$176.prototype, {
	__class__: JsonParser_$176
});
class JsonParser_$178 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.LeftCurlyLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after","before","both"],"none");
	}
}
JsonParser_$178.__name__ = "JsonParser_178";
JsonParser_$178.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$178.prototype, {
	__class__: JsonParser_$178
});
class JsonParser_$18 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenFields : Null<Int>, ?beginType : Null<Int> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["beginType","betweenFields","endType","existingBetweenFields"],[true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType,pos);
				break;
			case "betweenFields":
				this.value.betweenFields = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFields",assigned,this.value.betweenFields,pos);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType,pos);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { beginType : 0, betweenFields : 0, endType : 0, existingBetweenFields : "keep"};
	}
}
JsonParser_$18.__name__ = "JsonParser_18";
JsonParser_$18.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$18.prototype, {
	__class__: JsonParser_$18
});
class JsonParser_$180 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "auto";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.LineEndCharacter",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["auto","CR","LF","CRLF"],"auto");
	}
}
JsonParser_$180.__name__ = "JsonParser_180";
JsonParser_$180.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$180.prototype, {
	__class__: JsonParser_$180
});
class JsonParser_$182 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.AtLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after","afterLast","forceAfterLast"],"none");
	}
}
JsonParser_$182.__name__ = "JsonParser_182";
JsonParser_$182.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$182.prototype, {
	__class__: JsonParser_$182
});
class JsonParser_$186 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.RightCurlyLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","before","after","both"],"none");
	}
}
JsonParser_$186.__name__ = "JsonParser_186";
JsonParser_$186.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$186.prototype, {
	__class__: JsonParser_$186
});
class JsonParser_$188 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.SharpLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after"],"none");
	}
}
JsonParser_$188.__name__ = "JsonParser_188";
JsonParser_$188.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$188.prototype, {
	__class__: JsonParser_$188
});
class JsonParser_$192 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"String",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = s;
	}
}
JsonParser_$192.__name__ = "JsonParser_192";
JsonParser_$192.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$192.prototype, {
	__class__: JsonParser_$192
});
class JsonParser_$194 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "fixedZero";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.ConditionalIndentationPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["fixedZero","fixedZeroIncrease","fixedZeroIncreaseBlocks","aligned","alignedNestedIncrease","alignedIncrease","alignedDecrease"],"fixedZero");
	}
}
JsonParser_$194.__name__ = "JsonParser_194";
JsonParser_$194.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$194.prototype, {
	__class__: JsonParser_$194
});
class JsonParser_$196 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "all";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.BetweenImportsEmptyLinesLevel",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["all","firstLevelPackage","secondLevelPackage","thirdLevelPackage","fourthLevelPackage","fifthLevelPackage","fullPackage"],"all");
	}
}
JsonParser_$196.__name__ = "JsonParser_196";
JsonParser_$196.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$196.prototype, {
	__class__: JsonParser_$196
});
class JsonParser_$198 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "keep";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.KeepEmptyLinesPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["keep","remove"],"keep");
	}
}
JsonParser_$198.__name__ = "JsonParser_198";
JsonParser_$198.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$198.prototype, {
	__class__: JsonParser_$198
});
class JsonParser_$202 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "ignore";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.CommentEmptyLinesPolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["ignore","none","one"],"ignore");
	}
}
JsonParser_$202.__name__ = "JsonParser_202";
JsonParser_$202.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$202.prototype, {
	__class__: JsonParser_$202
});
class JsonParser_$21 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenVars : Null<Int>, ?betweenFunctions : Null<Int>, ?beginType : Null<Int>, ?afterVars : Null<Int> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterVars","beginType","betweenFunctions","betweenVars","endType","existingBetweenFields"],[true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "afterVars":
				this.value.afterVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterVars",assigned,this.value.afterVars,pos);
				break;
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType,pos);
				break;
			case "betweenFunctions":
				this.value.betweenFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFunctions",assigned,this.value.betweenFunctions,pos);
				break;
			case "betweenVars":
				this.value.betweenVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenVars",assigned,this.value.betweenVars,pos);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType,pos);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { afterVars : 0, beginType : 0, betweenFunctions : 0, betweenVars : 0, endType : 0, existingBetweenFields : "keep"};
	}
}
JsonParser_$21.__name__ = "JsonParser_21";
JsonParser_$21.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$21.prototype, {
	__class__: JsonParser_$21
});
class JsonParser_$218 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "keep";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.LineCommentEmptyLinePolicy",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["keep","one","none"],"keep");
	}
}
JsonParser_$218.__name__ = "JsonParser_218";
JsonParser_$218.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$218.prototype, {
	__class__: JsonParser_$218
});
class JsonParser_$24 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?betweenImportsLevel : Null<formatter.config.BetweenImportsEmptyLinesLevel>, ?betweenImports : Null<Int>, ?beforeUsing : Null<Int>, ?beforeType : Null<Int> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["beforeType","beforeUsing","betweenImports","betweenImportsLevel"],[true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "beforeType":
				this.value.beforeType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeType",assigned,this.value.beforeType,pos);
				break;
			case "beforeUsing":
				this.value.beforeUsing = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeUsing",assigned,this.value.beforeUsing,pos);
				break;
			case "betweenImports":
				this.value.betweenImports = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenImports",assigned,this.value.betweenImports,pos);
				break;
			case "betweenImportsLevel":
				this.value.betweenImportsLevel = this.loadObjectField(($_=new JsonParser_$196(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenImportsLevel",assigned,this.value.betweenImportsLevel,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { beforeType : 1, beforeUsing : 1, betweenImports : 0, betweenImportsLevel : "all"};
	}
}
JsonParser_$24.__name__ = "JsonParser_24";
JsonParser_$24.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$24.prototype, {
	__class__: JsonParser_$24
});
class JsonParser_$33 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?trailingWhitespace : Null<Bool>, ?tabWidth : Null<Int>, ?indentObjectLiteral : Null<Bool>, ?indentComplexValueExpressions : Null<Bool>, ?indentCaseLabels : Null<Bool>, ?conditionalPolicy : Null<formatter.config.ConditionalIndentationPolicy>, ?character : Null<String> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["character","conditionalPolicy","indentCaseLabels","indentComplexValueExpressions","indentObjectLiteral","tabWidth","trailingWhitespace"],[true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "character":
				this.value.character = this.loadObjectField(($_=new JsonParser_$192(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"character",assigned,this.value.character,pos);
				break;
			case "conditionalPolicy":
				this.value.conditionalPolicy = this.loadObjectField(($_=new JsonParser_$194(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditionalPolicy",assigned,this.value.conditionalPolicy,pos);
				break;
			case "indentCaseLabels":
				this.value.indentCaseLabels = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentCaseLabels",assigned,this.value.indentCaseLabels,pos);
				break;
			case "indentComplexValueExpressions":
				this.value.indentComplexValueExpressions = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentComplexValueExpressions",assigned,this.value.indentComplexValueExpressions,pos);
				break;
			case "indentObjectLiteral":
				this.value.indentObjectLiteral = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentObjectLiteral",assigned,this.value.indentObjectLiteral,pos);
				break;
			case "tabWidth":
				this.value.tabWidth = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tabWidth",assigned,this.value.tabWidth,pos);
				break;
			case "trailingWhitespace":
				this.value.trailingWhitespace = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"trailingWhitespace",assigned,this.value.trailingWhitespace,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { character : "tab", conditionalPolicy : "aligned", indentCaseLabels : true, indentComplexValueExpressions : false, indentObjectLiteral : true, tabWidth : 4, trailingWhitespace : false};
	}
}
JsonParser_$33.__name__ = "JsonParser_33";
JsonParser_$33.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$33.prototype, {
	__class__: JsonParser_$33
});
class JsonParser_$36 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?typedefCurly : Null<formatter.config.CurlyLineEndPolicy>, ?sharp : Null<formatter.config.SharpLineEndPolicy>, ?rightCurly : Null<formatter.config.RightCurlyLineEndPolicy>, ?objectLiteralCurly : Null<formatter.config.CurlyLineEndPolicy>, ?metadataVar : Null<formatter.config.AtLineEndPolicy>, ?metadataType : Null<formatter.config.AtLineEndPolicy>, ?metadataOther : Null<formatter.config.AtLineEndPolicy>, ?metadataFunction : Null<formatter.config.AtLineEndPolicy>, ?lineEndCharacter : Null<formatter.config.LineEndCharacter>, ?leftCurly : Null<formatter.config.LeftCurlyLineEndPolicy>, ?emptyCurly : Null<formatter.config.EmptyCurlyPolicy>, ?caseColon : Null<formatter.config.CaseColonLineEndPolicy>, ?blockCurly : Null<formatter.config.CurlyLineEndPolicy>, ?anonTypeCurly : Null<formatter.config.CurlyLineEndPolicy>, ?anonFunctionCurly : Null<formatter.config.CurlyLineEndPolicy> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFunctionCurly","anonTypeCurly","blockCurly","caseColon","emptyCurly","leftCurly","lineEndCharacter","metadataFunction","metadataOther","metadataType","metadataVar","objectLiteralCurly","rightCurly","sharp","typedefCurly"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFunctionCurly":
				this.value.anonFunctionCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFunctionCurly",assigned,this.value.anonFunctionCurly,pos);
				break;
			case "anonTypeCurly":
				this.value.anonTypeCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonTypeCurly",assigned,this.value.anonTypeCurly,pos);
				break;
			case "blockCurly":
				this.value.blockCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"blockCurly",assigned,this.value.blockCurly,pos);
				break;
			case "caseColon":
				this.value.caseColon = this.loadObjectField(($_=new JsonParser_$174(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"caseColon",assigned,this.value.caseColon,pos);
				break;
			case "emptyCurly":
				this.value.emptyCurly = this.loadObjectField(($_=new JsonParser_$176(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"emptyCurly",assigned,this.value.emptyCurly,pos);
				break;
			case "leftCurly":
				this.value.leftCurly = this.loadObjectField(($_=new JsonParser_$178(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"leftCurly",assigned,this.value.leftCurly,pos);
				break;
			case "lineEndCharacter":
				this.value.lineEndCharacter = this.loadObjectField(($_=new JsonParser_$180(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineEndCharacter",assigned,this.value.lineEndCharacter,pos);
				break;
			case "metadataFunction":
				this.value.metadataFunction = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataFunction",assigned,this.value.metadataFunction,pos);
				break;
			case "metadataOther":
				this.value.metadataOther = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataOther",assigned,this.value.metadataOther,pos);
				break;
			case "metadataType":
				this.value.metadataType = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataType",assigned,this.value.metadataType,pos);
				break;
			case "metadataVar":
				this.value.metadataVar = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataVar",assigned,this.value.metadataVar,pos);
				break;
			case "objectLiteralCurly":
				this.value.objectLiteralCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectLiteralCurly",assigned,this.value.objectLiteralCurly,pos);
				break;
			case "rightCurly":
				this.value.rightCurly = this.loadObjectField(($_=new JsonParser_$186(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"rightCurly",assigned,this.value.rightCurly,pos);
				break;
			case "sharp":
				this.value.sharp = this.loadObjectField(($_=new JsonParser_$188(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"sharp",assigned,this.value.sharp,pos);
				break;
			case "typedefCurly":
				this.value.typedefCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typedefCurly",assigned,this.value.typedefCurly,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { anonFunctionCurly : null, anonTypeCurly : null, blockCurly : null, caseColon : "after", emptyCurly : "noBreak", leftCurly : "after", lineEndCharacter : "auto", metadataFunction : "none", metadataOther : "none", metadataType : "none", metadataVar : "none", objectLiteralCurly : null, rightCurly : "both", sharp : "after", typedefCurly : null};
	}
}
JsonParser_$36.__name__ = "JsonParser_36";
JsonParser_$36.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$36.prototype, {
	__class__: JsonParser_$36
});
class JsonParser_$39 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?whileBody : Null<formatter.config.SameLinePolicy>, ?untypedBody : Null<formatter.config.SameLinePolicy>, ?tryCatch : Null<formatter.config.SameLinePolicy>, ?tryBody : Null<formatter.config.SameLinePolicy>, ?returnBodySingleLine : Null<formatter.config.SameLinePolicy>, ?returnBody : Null<formatter.config.SameLinePolicy>, ?ifElse : Null<formatter.config.SameLinePolicy>, ?ifBody : Null<formatter.config.SameLinePolicy>, ?functionBody : Null<formatter.config.SameLinePolicy>, ?forBody : Null<formatter.config.SameLinePolicy>, ?expressionTry : Null<formatter.config.SameLinePolicy>, ?expressionIfWithBlocks : Null<Bool>, ?expressionIf : Null<formatter.config.SameLinePolicy>, ?expressionCase : Null<formatter.config.SameLinePolicy>, ?elseIf : Null<formatter.config.SameLinePolicy>, ?elseBody : Null<formatter.config.SameLinePolicy>, ?doWhileBody : Null<formatter.config.SameLinePolicy>, ?doWhile : Null<formatter.config.SameLinePolicy>, ?comprehensionFor : Null<formatter.config.SameLinePolicy>, ?catchBody : Null<formatter.config.SameLinePolicy>, ?caseBody : Null<formatter.config.SameLinePolicy>, ?anonFunctionBody : Null<formatter.config.SameLinePolicy> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFunctionBody","caseBody","catchBody","comprehensionFor","doWhile","doWhileBody","elseBody","elseIf","expressionCase","expressionIf","expressionIfWithBlocks","expressionTry","forBody","functionBody","ifBody","ifElse","returnBody","returnBodySingleLine","tryBody","tryCatch","untypedBody","whileBody"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFunctionBody":
				this.value.anonFunctionBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFunctionBody",assigned,this.value.anonFunctionBody,pos);
				break;
			case "caseBody":
				this.value.caseBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"caseBody",assigned,this.value.caseBody,pos);
				break;
			case "catchBody":
				this.value.catchBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"catchBody",assigned,this.value.catchBody,pos);
				break;
			case "comprehensionFor":
				this.value.comprehensionFor = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"comprehensionFor",assigned,this.value.comprehensionFor,pos);
				break;
			case "doWhile":
				this.value.doWhile = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"doWhile",assigned,this.value.doWhile,pos);
				break;
			case "doWhileBody":
				this.value.doWhileBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"doWhileBody",assigned,this.value.doWhileBody,pos);
				break;
			case "elseBody":
				this.value.elseBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"elseBody",assigned,this.value.elseBody,pos);
				break;
			case "elseIf":
				this.value.elseIf = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"elseIf",assigned,this.value.elseIf,pos);
				break;
			case "expressionCase":
				this.value.expressionCase = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionCase",assigned,this.value.expressionCase,pos);
				break;
			case "expressionIf":
				this.value.expressionIf = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionIf",assigned,this.value.expressionIf,pos);
				break;
			case "expressionIfWithBlocks":
				this.value.expressionIfWithBlocks = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionIfWithBlocks",assigned,this.value.expressionIfWithBlocks,pos);
				break;
			case "expressionTry":
				this.value.expressionTry = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionTry",assigned,this.value.expressionTry,pos);
				break;
			case "forBody":
				this.value.forBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"forBody",assigned,this.value.forBody,pos);
				break;
			case "functionBody":
				this.value.functionBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionBody",assigned,this.value.functionBody,pos);
				break;
			case "ifBody":
				this.value.ifBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifBody",assigned,this.value.ifBody,pos);
				break;
			case "ifElse":
				this.value.ifElse = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifElse",assigned,this.value.ifElse,pos);
				break;
			case "returnBody":
				this.value.returnBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"returnBody",assigned,this.value.returnBody,pos);
				break;
			case "returnBodySingleLine":
				this.value.returnBodySingleLine = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"returnBodySingleLine",assigned,this.value.returnBodySingleLine,pos);
				break;
			case "tryBody":
				this.value.tryBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tryBody",assigned,this.value.tryBody,pos);
				break;
			case "tryCatch":
				this.value.tryCatch = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tryCatch",assigned,this.value.tryCatch,pos);
				break;
			case "untypedBody":
				this.value.untypedBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"untypedBody",assigned,this.value.untypedBody,pos);
				break;
			case "whileBody":
				this.value.whileBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whileBody",assigned,this.value.whileBody,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { anonFunctionBody : "same", caseBody : "next", catchBody : "next", comprehensionFor : "same", doWhile : "same", doWhileBody : "next", elseBody : "next", elseIf : "same", expressionCase : "keep", expressionIf : "same", expressionIfWithBlocks : false, expressionTry : "same", forBody : "next", functionBody : "next", ifBody : "next", ifElse : "same", returnBody : "same", returnBodySingleLine : "same", tryBody : "next", tryCatch : "same", untypedBody : "same", whileBody : "next"};
	}
}
JsonParser_$39.__name__ = "JsonParser_39";
JsonParser_$39.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$39.prototype, {
	__class__: JsonParser_$39
});
class JsonParser_$4 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?typedefEmptyLines : Null<formatter.config.TypedefFieldsEmptyLinesConfig>, ?maxAnywhereInFile : Null<Int>, ?macroClassEmptyLines : Null<formatter.config.ClassFieldsEmptyLinesConfig>, ?lineCommentsBetweenTypes : Null<formatter.config.LineCommentEmptyLinePolicy>, ?lineCommentsBetweenFunctions : Null<formatter.config.LineCommentEmptyLinePolicy>, ?interfaceEmptyLines : Null<formatter.config.InterfaceFieldsEmptyLinesConfig>, ?importAndUsing : Null<formatter.config.ImportsEmptyLinesConfig>, ?finalNewline : Null<Bool>, ?externClassEmptyLines : Null<formatter.config.InterfaceFieldsEmptyLinesConfig>, ?enumEmptyLines : Null<formatter.config.TypedefFieldsEmptyLinesConfig>, ?enumAbstractEmptyLines : Null<formatter.config.EnumAbstractFieldsEmptyLinesConfig>, ?conditionalsEmptyLines : Null<formatter.config.ConditionalEmptyLinesConfig>, ?classEmptyLines : Null<formatter.config.ClassFieldsEmptyLinesConfig>, ?betweenTypes : Null<Int>, ?betweenSingleLineTypes : Null<Int>, ?betweenMultilineComments : Null<Int>, ?beforeRightCurly : Null<formatter.config.KeepEmptyLinesPolicy>, ?beforePackage : Null<Int>, ?beforeDocCommentEmptyLines : Null<formatter.config.CommentEmptyLinesPolicy>, ?beforeBlocks : Null<formatter.config.KeepEmptyLinesPolicy>, ?afterReturn : Null<formatter.config.KeepEmptyLinesPolicy>, ?afterPackage : Null<Int>, ?afterLeftCurly : Null<formatter.config.KeepEmptyLinesPolicy>, ?afterFileHeaderComment : Null<Int>, ?afterFieldsWithDocComments : Null<formatter.config.CommentEmptyLinesPolicy>, ?afterBlocks : Null<formatter.config.KeepEmptyLinesPolicy>, ?abstractEmptyLines : Null<formatter.config.ClassFieldsEmptyLinesConfig> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["abstractEmptyLines","afterBlocks","afterFieldsWithDocComments","afterFileHeaderComment","afterLeftCurly","afterPackage","afterReturn","beforeBlocks","beforeDocCommentEmptyLines","beforePackage","beforeRightCurly","betweenMultilineComments","betweenSingleLineTypes","betweenTypes","classEmptyLines","conditionalsEmptyLines","enumAbstractEmptyLines","enumEmptyLines","externClassEmptyLines","finalNewline","importAndUsing","interfaceEmptyLines","lineCommentsBetweenFunctions","lineCommentsBetweenTypes","macroClassEmptyLines","maxAnywhereInFile","typedefEmptyLines"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "abstractEmptyLines":
				this.value.abstractEmptyLines = this.loadObjectField(($_=new JsonParser_$7(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"abstractEmptyLines",assigned,this.value.abstractEmptyLines,pos);
				break;
			case "afterBlocks":
				this.value.afterBlocks = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterBlocks",assigned,this.value.afterBlocks,pos);
				break;
			case "afterFieldsWithDocComments":
				this.value.afterFieldsWithDocComments = this.loadObjectField(($_=new JsonParser_$202(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterFieldsWithDocComments",assigned,this.value.afterFieldsWithDocComments,pos);
				break;
			case "afterFileHeaderComment":
				this.value.afterFileHeaderComment = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterFileHeaderComment",assigned,this.value.afterFileHeaderComment,pos);
				break;
			case "afterLeftCurly":
				this.value.afterLeftCurly = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterLeftCurly",assigned,this.value.afterLeftCurly,pos);
				break;
			case "afterPackage":
				this.value.afterPackage = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterPackage",assigned,this.value.afterPackage,pos);
				break;
			case "afterReturn":
				this.value.afterReturn = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterReturn",assigned,this.value.afterReturn,pos);
				break;
			case "beforeBlocks":
				this.value.beforeBlocks = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeBlocks",assigned,this.value.beforeBlocks,pos);
				break;
			case "beforeDocCommentEmptyLines":
				this.value.beforeDocCommentEmptyLines = this.loadObjectField(($_=new JsonParser_$202(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeDocCommentEmptyLines",assigned,this.value.beforeDocCommentEmptyLines,pos);
				break;
			case "beforePackage":
				this.value.beforePackage = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforePackage",assigned,this.value.beforePackage,pos);
				break;
			case "beforeRightCurly":
				this.value.beforeRightCurly = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeRightCurly",assigned,this.value.beforeRightCurly,pos);
				break;
			case "betweenMultilineComments":
				this.value.betweenMultilineComments = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenMultilineComments",assigned,this.value.betweenMultilineComments,pos);
				break;
			case "betweenSingleLineTypes":
				this.value.betweenSingleLineTypes = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenSingleLineTypes",assigned,this.value.betweenSingleLineTypes,pos);
				break;
			case "betweenTypes":
				this.value.betweenTypes = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenTypes",assigned,this.value.betweenTypes,pos);
				break;
			case "classEmptyLines":
				this.value.classEmptyLines = this.loadObjectField(($_=new JsonParser_$7(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"classEmptyLines",assigned,this.value.classEmptyLines,pos);
				break;
			case "conditionalsEmptyLines":
				this.value.conditionalsEmptyLines = this.loadObjectField(($_=new JsonParser_$12(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditionalsEmptyLines",assigned,this.value.conditionalsEmptyLines,pos);
				break;
			case "enumAbstractEmptyLines":
				this.value.enumAbstractEmptyLines = this.loadObjectField(($_=new JsonParser_$15(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"enumAbstractEmptyLines",assigned,this.value.enumAbstractEmptyLines,pos);
				break;
			case "enumEmptyLines":
				this.value.enumEmptyLines = this.loadObjectField(($_=new JsonParser_$18(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"enumEmptyLines",assigned,this.value.enumEmptyLines,pos);
				break;
			case "externClassEmptyLines":
				this.value.externClassEmptyLines = this.loadObjectField(($_=new JsonParser_$21(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"externClassEmptyLines",assigned,this.value.externClassEmptyLines,pos);
				break;
			case "finalNewline":
				this.value.finalNewline = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"finalNewline",assigned,this.value.finalNewline,pos);
				break;
			case "importAndUsing":
				this.value.importAndUsing = this.loadObjectField(($_=new JsonParser_$24(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"importAndUsing",assigned,this.value.importAndUsing,pos);
				break;
			case "interfaceEmptyLines":
				this.value.interfaceEmptyLines = this.loadObjectField(($_=new JsonParser_$21(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"interfaceEmptyLines",assigned,this.value.interfaceEmptyLines,pos);
				break;
			case "lineCommentsBetweenFunctions":
				this.value.lineCommentsBetweenFunctions = this.loadObjectField(($_=new JsonParser_$218(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineCommentsBetweenFunctions",assigned,this.value.lineCommentsBetweenFunctions,pos);
				break;
			case "lineCommentsBetweenTypes":
				this.value.lineCommentsBetweenTypes = this.loadObjectField(($_=new JsonParser_$218(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineCommentsBetweenTypes",assigned,this.value.lineCommentsBetweenTypes,pos);
				break;
			case "macroClassEmptyLines":
				this.value.macroClassEmptyLines = this.loadObjectField(($_=new JsonParser_$7(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"macroClassEmptyLines",assigned,this.value.macroClassEmptyLines,pos);
				break;
			case "maxAnywhereInFile":
				this.value.maxAnywhereInFile = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"maxAnywhereInFile",assigned,this.value.maxAnywhereInFile,pos);
				break;
			case "typedefEmptyLines":
				this.value.typedefEmptyLines = this.loadObjectField(($_=new JsonParser_$18(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typedefEmptyLines",assigned,this.value.typedefEmptyLines,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { abstractEmptyLines : new JsonParser_$7([],this.putils,0).getAuto(), afterBlocks : "remove", afterFieldsWithDocComments : "one", afterFileHeaderComment : 1, afterLeftCurly : "remove", afterPackage : 1, afterReturn : "remove", beforeBlocks : "remove", beforeDocCommentEmptyLines : "one", beforePackage : 0, beforeRightCurly : "remove", betweenMultilineComments : 0, betweenSingleLineTypes : 0, betweenTypes : 1, classEmptyLines : new JsonParser_$7([],this.putils,0).getAuto(), conditionalsEmptyLines : new JsonParser_$12([],this.putils,0).getAuto(), enumAbstractEmptyLines : new JsonParser_$15([],this.putils,0).getAuto(), enumEmptyLines : new JsonParser_$18([],this.putils,0).getAuto(), externClassEmptyLines : new JsonParser_$21([],this.putils,0).getAuto(), finalNewline : true, importAndUsing : new JsonParser_$24([],this.putils,0).getAuto(), interfaceEmptyLines : new JsonParser_$21([],this.putils,0).getAuto(), lineCommentsBetweenFunctions : "keep", lineCommentsBetweenTypes : "keep", macroClassEmptyLines : new JsonParser_$7([],this.putils,0).getAuto(), maxAnywhereInFile : 1, typedefEmptyLines : new JsonParser_$18([],this.putils,0).getAuto()};
	}
}
JsonParser_$4.__name__ = "JsonParser_4";
JsonParser_$4.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$4.prototype, {
	__class__: JsonParser_$4
});
class JsonParser_$42 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?whilePolicy : Null<formatter.config.WhitespacePolicy>, ?typeParamOpenPolicy : Null<formatter.config.WhitespacePolicy>, ?typeParamClosePolicy : Null<formatter.config.WhitespacePolicy>, ?typeHintColonPolicy : Null<formatter.config.WhitespacePolicy>, ?typeExtensionPolicy : Null<formatter.config.WhitespacePolicy>, ?typeCheckColonPolicy : Null<formatter.config.WhitespacePolicy>, ?tryPolicy : Null<formatter.config.WhitespacePolicy>, ?ternaryPolicy : Null<formatter.config.WhitespacePolicy>, ?switchPolicy : Null<formatter.config.WhitespacePolicy>, ?semicolonPolicy : Null<formatter.config.WhitespacePolicy>, ?parenConfig : Null<formatter.config.ParenWhitespaceConfig>, ?openingBracketPolicy : Null<formatter.config.WhitespacePolicy>, ?objectFieldColonPolicy : Null<formatter.config.WhitespacePolicy>, ?intervalPolicy : Null<formatter.config.WhitespacePolicy>, ?ifPolicy : Null<formatter.config.WhitespacePolicy>, ?functionTypeHaxe4Policy : Null<formatter.config.WhitespacePolicy>, ?functionTypeHaxe3Policy : Null<formatter.config.WhitespacePolicy>, ?formatStringInterpolation : Null<Bool>, ?forPolicy : Null<formatter.config.WhitespacePolicy>, ?dotPolicy : Null<formatter.config.WhitespacePolicy>, ?doPolicy : Null<formatter.config.WhitespacePolicy>, ?compressSuccessiveParenthesis : Null<Bool>, ?commaPolicy : Null<formatter.config.WhitespacePolicy>, ?colonPolicy : Null<formatter.config.WhitespacePolicy>, ?closingBracketPolicy : Null<formatter.config.WhitespacePolicy>, ?catchPolicy : Null<formatter.config.WhitespacePolicy>, ?caseColonPolicy : Null<formatter.config.WhitespacePolicy>, ?bracesConfig : Null<formatter.config.BracesWhitespaceConfig>, ?binopPolicy : Null<formatter.config.WhitespacePolicy>, ?arrowFunctionsPolicy : Null<formatter.config.WhitespacePolicy>, ?addLineCommentSpace : Null<Bool> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["addLineCommentSpace","arrowFunctionsPolicy","binopPolicy","bracesConfig","caseColonPolicy","catchPolicy","closingBracketPolicy","colonPolicy","commaPolicy","compressSuccessiveParenthesis","doPolicy","dotPolicy","forPolicy","formatStringInterpolation","functionTypeHaxe3Policy","functionTypeHaxe4Policy","ifPolicy","intervalPolicy","objectFieldColonPolicy","openingBracketPolicy","parenConfig","semicolonPolicy","switchPolicy","ternaryPolicy","tryPolicy","typeCheckColonPolicy","typeExtensionPolicy","typeHintColonPolicy","typeParamClosePolicy","typeParamOpenPolicy","whilePolicy"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "addLineCommentSpace":
				this.value.addLineCommentSpace = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"addLineCommentSpace",assigned,this.value.addLineCommentSpace,pos);
				break;
			case "arrowFunctionsPolicy":
				this.value.arrowFunctionsPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"arrowFunctionsPolicy",assigned,this.value.arrowFunctionsPolicy,pos);
				break;
			case "binopPolicy":
				this.value.binopPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"binopPolicy",assigned,this.value.binopPolicy,pos);
				break;
			case "bracesConfig":
				this.value.bracesConfig = this.loadObjectField(($_=new JsonParser_$45(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"bracesConfig",assigned,this.value.bracesConfig,pos);
				break;
			case "caseColonPolicy":
				this.value.caseColonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"caseColonPolicy",assigned,this.value.caseColonPolicy,pos);
				break;
			case "catchPolicy":
				this.value.catchPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"catchPolicy",assigned,this.value.catchPolicy,pos);
				break;
			case "closingBracketPolicy":
				this.value.closingBracketPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"closingBracketPolicy",assigned,this.value.closingBracketPolicy,pos);
				break;
			case "colonPolicy":
				this.value.colonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"colonPolicy",assigned,this.value.colonPolicy,pos);
				break;
			case "commaPolicy":
				this.value.commaPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"commaPolicy",assigned,this.value.commaPolicy,pos);
				break;
			case "compressSuccessiveParenthesis":
				this.value.compressSuccessiveParenthesis = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"compressSuccessiveParenthesis",assigned,this.value.compressSuccessiveParenthesis,pos);
				break;
			case "doPolicy":
				this.value.doPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"doPolicy",assigned,this.value.doPolicy,pos);
				break;
			case "dotPolicy":
				this.value.dotPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"dotPolicy",assigned,this.value.dotPolicy,pos);
				break;
			case "forPolicy":
				this.value.forPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"forPolicy",assigned,this.value.forPolicy,pos);
				break;
			case "formatStringInterpolation":
				this.value.formatStringInterpolation = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"formatStringInterpolation",assigned,this.value.formatStringInterpolation,pos);
				break;
			case "functionTypeHaxe3Policy":
				this.value.functionTypeHaxe3Policy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionTypeHaxe3Policy",assigned,this.value.functionTypeHaxe3Policy,pos);
				break;
			case "functionTypeHaxe4Policy":
				this.value.functionTypeHaxe4Policy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionTypeHaxe4Policy",assigned,this.value.functionTypeHaxe4Policy,pos);
				break;
			case "ifPolicy":
				this.value.ifPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifPolicy",assigned,this.value.ifPolicy,pos);
				break;
			case "intervalPolicy":
				this.value.intervalPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"intervalPolicy",assigned,this.value.intervalPolicy,pos);
				break;
			case "objectFieldColonPolicy":
				this.value.objectFieldColonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectFieldColonPolicy",assigned,this.value.objectFieldColonPolicy,pos);
				break;
			case "openingBracketPolicy":
				this.value.openingBracketPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"openingBracketPolicy",assigned,this.value.openingBracketPolicy,pos);
				break;
			case "parenConfig":
				this.value.parenConfig = this.loadObjectField(($_=new JsonParser_$48(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"parenConfig",assigned,this.value.parenConfig,pos);
				break;
			case "semicolonPolicy":
				this.value.semicolonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"semicolonPolicy",assigned,this.value.semicolonPolicy,pos);
				break;
			case "switchPolicy":
				this.value.switchPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"switchPolicy",assigned,this.value.switchPolicy,pos);
				break;
			case "ternaryPolicy":
				this.value.ternaryPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ternaryPolicy",assigned,this.value.ternaryPolicy,pos);
				break;
			case "tryPolicy":
				this.value.tryPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tryPolicy",assigned,this.value.tryPolicy,pos);
				break;
			case "typeCheckColonPolicy":
				this.value.typeCheckColonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeCheckColonPolicy",assigned,this.value.typeCheckColonPolicy,pos);
				break;
			case "typeExtensionPolicy":
				this.value.typeExtensionPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeExtensionPolicy",assigned,this.value.typeExtensionPolicy,pos);
				break;
			case "typeHintColonPolicy":
				this.value.typeHintColonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeHintColonPolicy",assigned,this.value.typeHintColonPolicy,pos);
				break;
			case "typeParamClosePolicy":
				this.value.typeParamClosePolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeParamClosePolicy",assigned,this.value.typeParamClosePolicy,pos);
				break;
			case "typeParamOpenPolicy":
				this.value.typeParamOpenPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeParamOpenPolicy",assigned,this.value.typeParamOpenPolicy,pos);
				break;
			case "whilePolicy":
				this.value.whilePolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whilePolicy",assigned,this.value.whilePolicy,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { addLineCommentSpace : true, arrowFunctionsPolicy : "around", binopPolicy : "around", bracesConfig : new JsonParser_$45([],this.putils,0).getAuto(), caseColonPolicy : "onlyAfter", catchPolicy : "after", closingBracketPolicy : "none", colonPolicy : "none", commaPolicy : "onlyAfter", compressSuccessiveParenthesis : true, doPolicy : "after", dotPolicy : "none", forPolicy : "after", formatStringInterpolation : true, functionTypeHaxe3Policy : "none", functionTypeHaxe4Policy : "around", ifPolicy : "after", intervalPolicy : "none", objectFieldColonPolicy : "after", openingBracketPolicy : "noneAfter", parenConfig : new JsonParser_$48([],this.putils,0).getAuto(), semicolonPolicy : "onlyAfter", switchPolicy : "after", ternaryPolicy : "around", tryPolicy : "after", typeCheckColonPolicy : "around", typeExtensionPolicy : "after", typeHintColonPolicy : "none", typeParamClosePolicy : "none", typeParamOpenPolicy : "none", whilePolicy : "after"};
	}
}
JsonParser_$42.__name__ = "JsonParser_42";
JsonParser_$42.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$42.prototype, {
	__class__: JsonParser_$42
});
class JsonParser_$45 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?unknownBraces : Null<formatter.config.OpenClosePolicy>, ?typedefBraces : Null<formatter.config.OpenClosePolicy>, ?objectLiteralBraces : Null<formatter.config.OpenClosePolicy>, ?blockBraces : Null<formatter.config.OpenClosePolicy>, ?anonTypeBraces : Null<formatter.config.OpenClosePolicy> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonTypeBraces","blockBraces","objectLiteralBraces","typedefBraces","unknownBraces"],[true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "anonTypeBraces":
				this.value.anonTypeBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonTypeBraces",assigned,this.value.anonTypeBraces,pos);
				break;
			case "blockBraces":
				this.value.blockBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"blockBraces",assigned,this.value.blockBraces,pos);
				break;
			case "objectLiteralBraces":
				this.value.objectLiteralBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectLiteralBraces",assigned,this.value.objectLiteralBraces,pos);
				break;
			case "typedefBraces":
				this.value.typedefBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typedefBraces",assigned,this.value.typedefBraces,pos);
				break;
			case "unknownBraces":
				this.value.unknownBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"unknownBraces",assigned,this.value.unknownBraces,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { anonTypeBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, blockBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, objectLiteralBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, typedefBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, unknownBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}};
	}
}
JsonParser_$45.__name__ = "JsonParser_45";
JsonParser_$45.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$45.prototype, {
	__class__: JsonParser_$45
});
class JsonParser_$48 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?whileConditionParens : Null<formatter.config.OpenClosePolicy>, ?switchConditionParens : Null<formatter.config.OpenClosePolicy>, ?sharpConditionParens : Null<formatter.config.OpenClosePolicy>, ?metadataParens : Null<formatter.config.OpenClosePolicy>, ?ifConditionParens : Null<formatter.config.OpenClosePolicy>, ?funcParamParens : Null<formatter.config.OpenClosePolicy>, ?forLoopParens : Null<formatter.config.OpenClosePolicy>, ?expressionParens : Null<formatter.config.OpenClosePolicy>, ?conditionParens : Null<formatter.config.OpenClosePolicy>, ?catchParens : Null<formatter.config.OpenClosePolicy>, ?callParens : Null<formatter.config.OpenClosePolicy>, ?anonFuncParamParens : Null<formatter.config.OpenClosePolicy> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFuncParamParens","callParens","catchParens","conditionParens","expressionParens","forLoopParens","funcParamParens","ifConditionParens","metadataParens","sharpConditionParens","switchConditionParens","whileConditionParens"],[true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFuncParamParens":
				this.value.anonFuncParamParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFuncParamParens",assigned,this.value.anonFuncParamParens,pos);
				break;
			case "callParens":
				this.value.callParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"callParens",assigned,this.value.callParens,pos);
				break;
			case "catchParens":
				this.value.catchParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"catchParens",assigned,this.value.catchParens,pos);
				break;
			case "conditionParens":
				this.value.conditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditionParens",assigned,this.value.conditionParens,pos);
				break;
			case "expressionParens":
				this.value.expressionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionParens",assigned,this.value.expressionParens,pos);
				break;
			case "forLoopParens":
				this.value.forLoopParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"forLoopParens",assigned,this.value.forLoopParens,pos);
				break;
			case "funcParamParens":
				this.value.funcParamParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"funcParamParens",assigned,this.value.funcParamParens,pos);
				break;
			case "ifConditionParens":
				this.value.ifConditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifConditionParens",assigned,this.value.ifConditionParens,pos);
				break;
			case "metadataParens":
				this.value.metadataParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataParens",assigned,this.value.metadataParens,pos);
				break;
			case "sharpConditionParens":
				this.value.sharpConditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"sharpConditionParens",assigned,this.value.sharpConditionParens,pos);
				break;
			case "switchConditionParens":
				this.value.switchConditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"switchConditionParens",assigned,this.value.switchConditionParens,pos);
				break;
			case "whileConditionParens":
				this.value.whileConditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whileConditionParens",assigned,this.value.whileConditionParens,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		let tmp = new JsonParser_$51([],this.putils,0).getAuto();
		let tmp1 = new JsonParser_$51([],this.putils,0).getAuto();
		let tmp2 = new JsonParser_$51([],this.putils,0).getAuto();
		let tmp3 = new JsonParser_$51([],this.putils,0).getAuto();
		return { anonFuncParamParens : tmp, callParens : tmp1, catchParens : null, conditionParens : { openingPolicy : "noneAfter", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, expressionParens : { openingPolicy : "noneAfter", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, forLoopParens : { openingPolicy : "noneAfter", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, funcParamParens : tmp2, ifConditionParens : null, metadataParens : tmp3, sharpConditionParens : null, switchConditionParens : null, whileConditionParens : null};
	}
}
JsonParser_$48.__name__ = "JsonParser_48";
JsonParser_$48.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$48.prototype, {
	__class__: JsonParser_$48
});
class JsonParser_$51 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?removeInnerWhenEmpty : Null<Bool>, ?openingPolicy : Null<formatter.config.WhitespacePolicy>, ?closingPolicy : Null<formatter.config.WhitespacePolicy> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["closingPolicy","openingPolicy","removeInnerWhenEmpty"],[true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "closingPolicy":
				this.value.closingPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"closingPolicy",assigned,this.value.closingPolicy,pos);
				break;
			case "openingPolicy":
				this.value.openingPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"openingPolicy",assigned,this.value.openingPolicy,pos);
				break;
			case "removeInnerWhenEmpty":
				this.value.removeInnerWhenEmpty = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"removeInnerWhenEmpty",assigned,this.value.removeInnerWhenEmpty,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { closingPolicy : "onlyAfter", openingPolicy : "none", removeInnerWhenEmpty : true};
	}
}
JsonParser_$51.__name__ = "JsonParser_51";
JsonParser_$51.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$51.prototype, {
	__class__: JsonParser_$51
});
class JsonParser_$60 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?typeParameter : Null<formatter.config.WrapRules>, ?opBoolChain : Null<formatter.config.WrapRules>, ?opAddSubChain : Null<formatter.config.WrapRules>, ?objectLiteral : Null<formatter.config.WrapRules>, ?multiVar : Null<formatter.config.WrapRules>, ?methodChain : Null<formatter.config.WrapRules>, ?metadataCallParameter : Null<formatter.config.WrapRules>, ?maxLineLength : Null<Int>, ?implementsExtends : Null<formatter.config.WrapRules>, ?functionSignature : Null<formatter.config.WrapRules>, ?casePattern : Null<formatter.config.WrapRules>, ?callParameter : Null<formatter.config.WrapRules>, ?arrayWrap : Null<formatter.config.WrapRules>, ?arrayMatrixWrap : Null<formatter.config.ArrayMatrixWrap>, ?anonType : Null<formatter.config.WrapRules>, ?anonFunctionSignature : Null<formatter.config.WrapRules> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFunctionSignature","anonType","arrayMatrixWrap","arrayWrap","callParameter","casePattern","functionSignature","implementsExtends","maxLineLength","metadataCallParameter","methodChain","multiVar","objectLiteral","opAddSubChain","opBoolChain","typeParameter"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFunctionSignature":
				this.value.anonFunctionSignature = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFunctionSignature",assigned,this.value.anonFunctionSignature,pos);
				break;
			case "anonType":
				this.value.anonType = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonType",assigned,this.value.anonType,pos);
				break;
			case "arrayMatrixWrap":
				this.value.arrayMatrixWrap = this.loadObjectField(($_=new JsonParser_$84(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"arrayMatrixWrap",assigned,this.value.arrayMatrixWrap,pos);
				break;
			case "arrayWrap":
				this.value.arrayWrap = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"arrayWrap",assigned,this.value.arrayWrap,pos);
				break;
			case "callParameter":
				this.value.callParameter = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"callParameter",assigned,this.value.callParameter,pos);
				break;
			case "casePattern":
				this.value.casePattern = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"casePattern",assigned,this.value.casePattern,pos);
				break;
			case "functionSignature":
				this.value.functionSignature = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionSignature",assigned,this.value.functionSignature,pos);
				break;
			case "implementsExtends":
				this.value.implementsExtends = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"implementsExtends",assigned,this.value.implementsExtends,pos);
				break;
			case "maxLineLength":
				this.value.maxLineLength = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"maxLineLength",assigned,this.value.maxLineLength,pos);
				break;
			case "metadataCallParameter":
				this.value.metadataCallParameter = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataCallParameter",assigned,this.value.metadataCallParameter,pos);
				break;
			case "methodChain":
				this.value.methodChain = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"methodChain",assigned,this.value.methodChain,pos);
				break;
			case "multiVar":
				this.value.multiVar = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"multiVar",assigned,this.value.multiVar,pos);
				break;
			case "objectLiteral":
				this.value.objectLiteral = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectLiteral",assigned,this.value.objectLiteral,pos);
				break;
			case "opAddSubChain":
				this.value.opAddSubChain = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"opAddSubChain",assigned,this.value.opAddSubChain,pos);
				break;
			case "opBoolChain":
				this.value.opBoolChain = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"opBoolChain",assigned,this.value.opBoolChain,pos);
				break;
			case "typeParameter":
				this.value.typeParameter = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeParameter",assigned,this.value.typeParameter,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { anonFunctionSignature : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount >= n", value : 7}], type : "fillLine", additionalIndent : 1},{ conditions : [{ cond : "totalItemLength >= n", value : 80}], type : "fillLine", additionalIndent : 1},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine", additionalIndent : 1}]}, anonType : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "anyItemLength >= n", value : 30}], type : "onePerLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 60}], type : "onePerLine"},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "onePerLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine"}]}, arrayMatrixWrap : "matrixWrapWithAlign", arrayWrap : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "hasMultilineItems", value : 1}], type : "onePerLine"},{ conditions : [{ cond : "totalItemLength <= n", value : 80}], type : "noWrap"},{ conditions : [{ cond : "anyItemLength <= n", value : 30},{ cond : "itemCount >= n", value : 10}], type : "fillLineWithLeadingBreak"},{ conditions : [{ cond : "anyItemLength >= n", value : 30}], type : "onePerLine"},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "onePerLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "onePerLine"}]}, callParameter : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount >= n", value : 7}], type : "fillLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 140}], type : "fillLine"},{ conditions : [{ cond : "anyItemLength >= n", value : 80}], type : "fillLine"},{ conditions : [{ cond : "lineLength >= n", value : 160}], type : "fillLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine"}]}, casePattern : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount >= n", value : 2}], type : "fillLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine"}]}, functionSignature : { defaultWrap : "fillLine", defaultAdditionalIndent : 1, rules : []}, implementsExtends : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 140}], type : "fillLine", additionalIndent : 2},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "fillLine", additionalIndent : 2},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine", additionalIndent : 2}]}, maxLineLength : 160, metadataCallParameter : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "totalItemLength >= n", value : 140}], type : "fillLine"},{ conditions : [{ cond : "lineLength >= n", value : 160}], type : "fillLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine"}]}, methodChain : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 160}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "totalItemLength <= n", value : 80},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "anyItemLength >= n", value : 30},{ cond : "itemCount >= n", value : 4}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "itemCount >= n", value : 7}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "onePerLineAfterFirst"}]}, multiVar : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "anyItemLength <= n", value : 15}], type : "fillLine"},{ conditions : [{ cond : "lineLength >= n", value : 80}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "onePerLineAfterFirst"}]}, objectLiteral : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "anyItemLength >= n", value : 30}], type : "onePerLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 60}], type : "onePerLine"},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "onePerLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "onePerLine"}]}, opAddSubChain : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 160},{ cond : "anyItemLength >= n", value : 60}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "lineLength >= n", value : 160}], location : "beforeLast", type : "fillLine"},{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "totalItemLength <= n", value : 120},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "itemCount >= n", value : 4}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], location : "beforeLast", type : "onePerLineAfterFirst"}]}, opBoolChain : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 140},{ cond : "anyItemLength >= n", value : 40}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "lineLength >= n", value : 140}], location : "beforeLast", type : "fillLine"},{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "totalItemLength <= n", value : 120},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "itemCount >= n", value : 4}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], location : "beforeLast", type : "fillLine"}]}, typeParameter : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "anyItemLength >= n", value : 50}], type : "fillLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 70}], type : "fillLine"}]}};
	}
}
JsonParser_$60.__name__ = "JsonParser_60";
JsonParser_$60.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$60.prototype, {
	__class__: JsonParser_$60
});
class JsonParser_$62 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Bool",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonBool(b,pos,variable) {
		this.value = b;
	}
}
JsonParser_$62.__name__ = "JsonParser_62";
JsonParser_$62.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$62.prototype, {
	__class__: JsonParser_$62
});
class JsonParser_$66 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Array<String>",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonArray(a,pos,variable) {
		this.value = this.loadJsonArrayValue(a,($_=new JsonParser_$77(this.errors,this.putils,2),$bind($_,$_.loadJson)),variable);
	}
}
JsonParser_$66.__name__ = "JsonParser_66";
JsonParser_$66.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$66.prototype, {
	__class__: JsonParser_$66
});
class JsonParser_$7 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenVars : Null<Int>, ?betweenStaticVars : Null<Int>, ?betweenStaticFunctions : Null<Int>, ?betweenFunctions : Null<Int>, ?beginType : Null<Int>, ?afterVars : Null<Int>, ?afterStaticVars : Null<Int>, ?afterStaticFunctions : Null<Int>, ?afterPrivateVars : Null<Int>, ?afterPrivateFunctions : Null<Int> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterPrivateFunctions","afterPrivateVars","afterStaticFunctions","afterStaticVars","afterVars","beginType","betweenFunctions","betweenStaticFunctions","betweenStaticVars","betweenVars","endType","existingBetweenFields"],[true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "afterPrivateFunctions":
				this.value.afterPrivateFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterPrivateFunctions",assigned,this.value.afterPrivateFunctions,pos);
				break;
			case "afterPrivateVars":
				this.value.afterPrivateVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterPrivateVars",assigned,this.value.afterPrivateVars,pos);
				break;
			case "afterStaticFunctions":
				this.value.afterStaticFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterStaticFunctions",assigned,this.value.afterStaticFunctions,pos);
				break;
			case "afterStaticVars":
				this.value.afterStaticVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterStaticVars",assigned,this.value.afterStaticVars,pos);
				break;
			case "afterVars":
				this.value.afterVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterVars",assigned,this.value.afterVars,pos);
				break;
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType,pos);
				break;
			case "betweenFunctions":
				this.value.betweenFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFunctions",assigned,this.value.betweenFunctions,pos);
				break;
			case "betweenStaticFunctions":
				this.value.betweenStaticFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenStaticFunctions",assigned,this.value.betweenStaticFunctions,pos);
				break;
			case "betweenStaticVars":
				this.value.betweenStaticVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenStaticVars",assigned,this.value.betweenStaticVars,pos);
				break;
			case "betweenVars":
				this.value.betweenVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenVars",assigned,this.value.betweenVars,pos);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType,pos);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { afterPrivateFunctions : 1, afterPrivateVars : 1, afterStaticFunctions : 1, afterStaticVars : 1, afterVars : 1, beginType : 0, betweenFunctions : 1, betweenStaticFunctions : 1, betweenStaticVars : 0, betweenVars : 0, endType : 0, existingBetweenFields : "keep"};
	}
}
JsonParser_$7.__name__ = "JsonParser_7";
JsonParser_$7.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$7.prototype, {
	__class__: JsonParser_$7
});
class JsonParser_$77 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"String",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = s;
	}
}
JsonParser_$77.__name__ = "JsonParser_77";
JsonParser_$77.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$77.prototype, {
	__class__: JsonParser_$77
});
class JsonParser_$80 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?rules : Null<Array<formatter.config.WrapRule>>, ?defaultWrap : Null<formatter.config.WrappingType>, ?defaultLocation : Null<formatter.config.WrappingLocation>, ?defaultAdditionalIndent : Null<Int> }",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonObject(o,pos,variable) {
		let assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["defaultAdditionalIndent","defaultLocation","defaultWrap","rules"],[true,true,true,true]);
		this.value = this.getAuto();
		let _g = 0;
		while(_g < o.length) {
			let field = o[_g];
			++_g;
			switch(field.name) {
			case "defaultAdditionalIndent":
				this.value.defaultAdditionalIndent = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"defaultAdditionalIndent",assigned,this.value.defaultAdditionalIndent,pos);
				break;
			case "defaultLocation":
				this.value.defaultLocation = this.loadObjectField(($_=new JsonParser_$112(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"defaultLocation",assigned,this.value.defaultLocation,pos);
				break;
			case "defaultWrap":
				this.value.defaultWrap = this.loadObjectField(($_=new JsonParser_$114(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"defaultWrap",assigned,this.value.defaultWrap,pos);
				break;
			case "rules":
				this.value.rules = this.loadObjectField(($_=new JsonParser_$116(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"rules",assigned,this.value.rules,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	getAuto() {
		return { defaultAdditionalIndent : 0, defaultLocation : "afterLast", defaultWrap : "noWrap", rules : []};
	}
}
JsonParser_$80.__name__ = "JsonParser_80";
JsonParser_$80.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$80.prototype, {
	__class__: JsonParser_$80
});
class JsonParser_$84 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.value = "noMatrixWrap";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.ArrayMatrixWrap",pos));
		this.objectThrow(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonString(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["noMatrixWrap","matrixWrapNoAlign","matrixWrapWithAlign"],"noMatrixWrap");
	}
}
JsonParser_$84.__name__ = "JsonParser_84";
JsonParser_$84.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$84.prototype, {
	__class__: JsonParser_$84
});
class JsonParser_$96 extends json2object_reader_BaseParser {
	constructor(errors,putils,errorType) {
		if(errorType == null) {
			errorType = 0;
		}
		super(errors,putils,errorType);
	}
	onIncorrectType(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Int",pos));
		super.onIncorrectType(pos,variable);
	}
	loadJsonNull(pos,variable) {
		this.value = null;
	}
	loadJsonNumber(f,pos,variable) {
		this.value = this.loadJsonInt(f,pos,variable,this.value);
	}
}
JsonParser_$96.__name__ = "JsonParser_96";
JsonParser_$96.__super__ = json2object_reader_BaseParser;
Object.assign(JsonParser_$96.prototype, {
	__class__: JsonParser_$96
});
class Lambda {
	static array(it) {
		let a = [];
		let i = $getIterator(it);
		while(i.hasNext()) a.push(i.next());
		return a;
	}
	static exists(it,f) {
		let x = $getIterator(it);
		while(x.hasNext()) if(f(x.next())) {
			return true;
		}
		return false;
	}
	static fold(it,f,first) {
		let x = $getIterator(it);
		while(x.hasNext()) first = f(x.next(),first);
		return first;
	}
	static count(it,pred) {
		let n = 0;
		if(pred == null) {
			let _ = $getIterator(it);
			while(_.hasNext()) {
				_.next();
				++n;
			}
		} else {
			let x = $getIterator(it);
			while(x.hasNext()) if(pred(x.next())) {
				++n;
			}
		}
		return n;
	}
	static find(it,f) {
		let v = $getIterator(it);
		while(v.hasNext()) {
			let v1 = v.next();
			if(f(v1)) {
				return v1;
			}
		}
		return null;
	}
}
Lambda.__name__ = "Lambda";
Math.__name__ = "Math";
class Reflect {
	static field(o,field) {
		try {
			return o[field];
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			return null;
		}
	}
	static fields(o) {
		let a = [];
		if(o != null) {
			let hasOwnProperty = Object.prototype.hasOwnProperty;
			for( var f in o ) {
			if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
				a.push(f);
			}
			}
		}
		return a;
	}
	static compare(a,b) {
		if(a == b) {
			return 0;
		} else if(a > b) {
			return 1;
		} else {
			return -1;
		}
	}
	static isEnumValue(v) {
		if(v != null) {
			return v.__enum__ != null;
		} else {
			return false;
		}
	}
	static deleteField(o,field) {
		if(!Object.prototype.hasOwnProperty.call(o,field)) {
			return false;
		}
		delete(o[field]);
		return true;
	}
}
Reflect.__name__ = "Reflect";
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		let v = parseInt(x);
		if(isNaN(v)) {
			return null;
		}
		return v;
	}
}
Std.__name__ = "Std";
class StringBuf {
	constructor() {
		this.b = "";
	}
}
StringBuf.__name__ = "StringBuf";
Object.assign(StringBuf.prototype, {
	__class__: StringBuf
});
class StringTools {
	static htmlEscape(s,quotes) {
		let buf_b = "";
		let _g_offset = 0;
		let _g_s = s;
		while(_g_offset < _g_s.length) {
			let s = _g_s;
			let index = _g_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g_offset;
			}
			let code = c1;
			switch(code) {
			case 34:
				if(quotes) {
					buf_b += "&quot;";
				} else {
					buf_b += String.fromCodePoint(code);
				}
				break;
			case 38:
				buf_b += "&amp;";
				break;
			case 39:
				if(quotes) {
					buf_b += "&#039;";
				} else {
					buf_b += String.fromCodePoint(code);
				}
				break;
			case 60:
				buf_b += "&lt;";
				break;
			case 62:
				buf_b += "&gt;";
				break;
			default:
				buf_b += String.fromCodePoint(code);
			}
		}
		return buf_b;
	}
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
	static lpad(s,c,l) {
		if(c.length <= 0) {
			return s;
		}
		let buf_b = "";
		l -= s.length;
		while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
		buf_b += s == null ? "null" : "" + s;
		return buf_b;
	}
	static rpad(s,c,l) {
		if(c.length <= 0) {
			return s;
		}
		let buf_b = "";
		buf_b = "" + (s == null ? "null" : "" + s);
		while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
		return buf_b;
	}
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
	static hex(n,digits) {
		let s = "";
		do {
			s = "0123456789ABCDEF".charAt(n & 15) + s;
			n >>>= 4;
		} while(n > 0);
		if(digits != null) {
			while(s.length < digits) s = "0" + s;
		}
		return s;
	}
}
StringTools.__name__ = "StringTools";
class Sys {
	static systemName() {
		let _g = process.platform;
		switch(_g) {
		case "darwin":
			return "Mac";
		case "freebsd":
			return "BSD";
		case "linux":
			return "Linux";
		case "win32":
			return "Windows";
		default:
			return _g;
		}
	}
}
Sys.__name__ = "Sys";
class haxe_io_Output {
	writeByte(c) {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Output.hx", lineNumber : 47, className : "haxe.io.Output", methodName : "writeByte"});
	}
	writeBytes(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		let b = s.b;
		let k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	writeFullBytes(s,pos,len) {
		while(len > 0) {
			let k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	writeString(s,encoding) {
		let b = haxe_io_Bytes.ofString(s,encoding);
		this.writeFullBytes(b,0,b.length);
	}
}
haxe_io_Output.__name__ = "haxe.io.Output";
Object.assign(haxe_io_Output.prototype, {
	__class__: haxe_io_Output
});
class Type {
	static enumEq(a,b) {
		if(a == b) {
			return true;
		}
		try {
			let e = a.__enum__;
			if(e == null || e != b.__enum__) {
				return false;
			}
			if(a._hx_index != b._hx_index) {
				return false;
			}
			let enm = $hxEnums[e];
			let params = enm.__constructs__[a._hx_index].__params__;
			let _g = 0;
			while(_g < params.length) {
				let f = params[_g];
				++_g;
				if(!Type.enumEq(a[f],b[f])) {
					return false;
				}
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			return false;
		}
		return true;
	}
	static enumParameters(e) {
		let enm = $hxEnums[e.__enum__];
		let params = enm.__constructs__[e._hx_index].__params__;
		if(params != null) {
			let _g = [];
			let _g1 = 0;
			while(_g1 < params.length) {
				let p = params[_g1];
				++_g1;
				_g.push(e[p]);
			}
			return _g;
		} else {
			return [];
		}
	}
}
Type.__name__ = "Type";
class XmlType {
	static toString(this1) {
		switch(this1) {
		case 0:
			return "Element";
		case 1:
			return "PCData";
		case 2:
			return "CData";
		case 3:
			return "Comment";
		case 4:
			return "DocType";
		case 5:
			return "ProcessingInstruction";
		case 6:
			return "Document";
		}
	}
}
class Xml {
	constructor(nodeType) {
		this.nodeType = nodeType;
		this.children = [];
		this.attributeMap = new haxe_ds_StringMap();
	}
	get(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return this.attributeMap.h[att];
	}
	set(att,value) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		this.attributeMap.h[att] = value;
	}
	exists(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return Object.prototype.hasOwnProperty.call(this.attributeMap.h,att);
	}
	attributes() {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.attributeMap.h);
	}
	elements() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = this.children;
		while(_g1 < _g2.length) {
			let child = _g2[_g1];
			++_g1;
			if(child.nodeType == Xml.Element) {
				_g.push(child);
			}
		}
		return new haxe_iterators_ArrayIterator(_g);
	}
	firstElement() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			if(child.nodeType == Xml.Element) {
				return child;
			}
		}
		return null;
	}
	addChild(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(x.parent != null) {
			x.parent.removeChild(x);
		}
		this.children.push(x);
		x.parent = this;
	}
	removeChild(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(HxOverrides.remove(this.children,x)) {
			x.parent = null;
			return true;
		}
		return false;
	}
	toString() {
		return haxe_xml_Printer.print(this);
	}
	static parse(str) {
		return haxe_xml_Parser.parse(str);
	}
	static createElement(name) {
		let xml = new Xml(Xml.Element);
		if(xml.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeName = name;
		return xml;
	}
	static createPCData(data) {
		let xml = new Xml(Xml.PCData);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createCData(data) {
		let xml = new Xml(Xml.CData);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createComment(data) {
		let xml = new Xml(Xml.Comment);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createDocType(data) {
		let xml = new Xml(Xml.DocType);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createProcessingInstruction(data) {
		let xml = new Xml(Xml.ProcessingInstruction);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createDocument() {
		return new Xml(Xml.Document);
	}
}
Xml.__name__ = "Xml";
Object.assign(Xml.prototype, {
	__class__: Xml
});
class formatter_FormatStats {
}
formatter_FormatStats.__name__ = "formatter.FormatStats";
var formatter_Result = $hxEnums["formatter.Result"] = { __ename__:true,__constructs__:null
	,Success: ($_=function(formattedCode) { return {_hx_index:0,formattedCode:formattedCode,__enum__:"formatter.Result",toString:$estr}; },$_._hx_name="Success",$_.__params__ = ["formattedCode"],$_)
	,Failure: ($_=function(errorMessage) { return {_hx_index:1,errorMessage:errorMessage,__enum__:"formatter.Result",toString:$estr}; },$_._hx_name="Failure",$_.__params__ = ["errorMessage"],$_)
	,Disabled: {_hx_name:"Disabled",_hx_index:2,__enum__:"formatter.Result",toString:$estr}
};
formatter_Result.__constructs__ = [formatter_Result.Success,formatter_Result.Failure,formatter_Result.Disabled];
class formatter_Formatter {
	static format(input,config,lineSeparator,entryPoint,range) {
		if(config == null) {
			config = new formatter_config_Config();
		}
		let inputData;
		switch(input._hx_index) {
		case 0:
			let _gfileName = input.fileName;
			if(!sys_FileSystem.exists(_gfileName)) {
				process.stdout.write(Std.string("Skipping '" + _gfileName + "' (path does not exist)"));
				process.stdout.write("\n");
				return formatter_Result.Failure("File \"" + _gfileName + "\" not found");
			}
			let content = js_node_buffer__$Buffer_Helper.bytesOfBuffer(js_node_Fs.readFileSync(_gfileName));
			inputData = { fileName : _gfileName, content : content, config : config, lineSeparator : lineSeparator, entryPoint : entryPoint, range : range};
			return formatter_Formatter.formatInputData(inputData);
		case 1:
			let _gorigin = input.origin;
			let content1 = haxe_io_Bytes.ofString(input.code);
			let inputData1;
			switch(_gorigin._hx_index) {
			case 0:
				inputData1 = _gorigin.fileName;
				break;
			case 1:
				inputData1 = "code snippet";
				break;
			}
			inputData = { fileName : inputData1, content : content1, config : config, lineSeparator : lineSeparator, entryPoint : entryPoint, range : range};
			return formatter_Formatter.formatInputData(inputData);
		case 2:
			let _gtokenList = input.tokenList;
			let _gtokenTree = input.tokenTree;
			let _gcode = input.code;
			let _gorigin1 = input.origin;
			let inputData2;
			switch(_gorigin1._hx_index) {
			case 0:
				inputData2 = _gorigin1.fileName;
				break;
			case 1:
				inputData2 = "code snippet";
				break;
			}
			inputData = { fileName : inputData2, content : _gcode, tokenList : _gtokenList, tokenTree : _gtokenTree, config : config, lineSeparator : lineSeparator, entryPoint : entryPoint, range : range};
			return formatter_Formatter.formatInputData(inputData);
		}
	}
	static loadConfig(path) {
		let configFileName = formatter_Formatter.determineConfig(path);
		if(configFileName == null) {
			return null;
		}
		let config = new formatter_config_Config();
		config.readConfig(configFileName);
		return config;
	}
	static formatInputData(inputData) {
		try {
			let config = inputData.config;
			if(config.disableFormatting) {
				return formatter_Result.Disabled;
			}
			if(config.isExcluded(inputData.fileName)) {
				return formatter_Result.Disabled;
			}
			tokentree_TokenStream.MODE = tokentree_TokenStreamMode.Relaxed;
			let parsedCode = new formatter_codedata_ParsedCode(inputData);
			formatter_FormatStats.totalLinesOrig += parsedCode.lines.length;
			let indenter = new formatter_marker_Indenter(config.indentation);
			indenter.setParsedCode(parsedCode);
			let markTokenText = new formatter_marker_MarkTokenText(config,parsedCode,indenter);
			let markWhitespace = new formatter_marker_MarkWhitespace(config,parsedCode,indenter);
			let markLineEnds = new formatter_marker_MarkLineEnds(config,parsedCode,indenter);
			let markSameLine = new formatter_marker_MarkSameLine(config,parsedCode,indenter);
			let markWrapping = new formatter_marker_wrapping_MarkWrapping(config,parsedCode,indenter);
			let markEmptyLines = new formatter_marker_MarkEmptyLines(config,parsedCode,indenter);
			let markAdditionalIndent = new formatter_marker_MarkAdditionalIndentation(config,parsedCode,indenter);
			markTokenText.run();
			markWhitespace.run();
			markLineEnds.run();
			markSameLine.run();
			markWrapping.run();
			markEmptyLines.run();
			markTokenText.finalRun();
			markAdditionalIndent.run();
			let outputLineEnds = formatter_marker_MarkLineEnds.outputLineSeparator(config.lineEnds,parsedCode);
			let lines = new formatter_codedata_CodeLines(parsedCode,indenter,inputData.range);
			lines.applyWrapping(config.wrapping,outputLineEnds);
			markEmptyLines.finalRun(lines);
			let formatted = lines.print(outputLineEnds);
			formatter_FormatStats.totalLinesFormatted += formatted.split(outputLineEnds).length;
			return formatter_Result.Success(formatted);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			let callstack = haxe_CallStack.toString(haxe_CallStack.exceptionStack());
			return formatter_Result.Failure((_g1 == null ? "null" : Std.string(_g1)) + "\n" + callstack + "\n\n");
		}
	}
	static determineConfig(fileName) {
		let path = js_node_Path.resolve(fileName);
		if(!sys_FileSystem.isDirectory(path)) {
			path = haxe_io_Path.directory(path);
		}
		while(path.length > 0) {
			let configFile = haxe_io_Path.join([path,"hxformat.json"]);
			if(sys_FileSystem.exists(configFile)) {
				return configFile;
			}
			path = haxe_io_Path.normalize(haxe_io_Path.join([path,".."]));
		}
		return null;
	}
}
formatter_Formatter.__name__ = "formatter.Formatter";
var formatter_FormatterInput = $hxEnums["formatter.FormatterInput"] = { __ename__:true,__constructs__:null
	,FileInput: ($_=function(fileName) { return {_hx_index:0,fileName:fileName,__enum__:"formatter.FormatterInput",toString:$estr}; },$_._hx_name="FileInput",$_.__params__ = ["fileName"],$_)
	,Code: ($_=function(code,origin) { return {_hx_index:1,code:code,origin:origin,__enum__:"formatter.FormatterInput",toString:$estr}; },$_._hx_name="Code",$_.__params__ = ["code","origin"],$_)
	,Tokens: ($_=function(tokenList,tokenTree,code,origin) { return {_hx_index:2,tokenList:tokenList,tokenTree:tokenTree,code:code,origin:origin,__enum__:"formatter.FormatterInput",toString:$estr}; },$_._hx_name="Tokens",$_.__params__ = ["tokenList","tokenTree","code","origin"],$_)
};
formatter_FormatterInput.__constructs__ = [formatter_FormatterInput.FileInput,formatter_FormatterInput.Code,formatter_FormatterInput.Tokens];
var formatter_CodeOrigin = $hxEnums["formatter.CodeOrigin"] = { __ename__:true,__constructs__:null
	,SourceFile: ($_=function(fileName) { return {_hx_index:0,fileName:fileName,__enum__:"formatter.CodeOrigin",toString:$estr}; },$_._hx_name="SourceFile",$_.__params__ = ["fileName"],$_)
	,Snippet: {_hx_name:"Snippet",_hx_index:1,__enum__:"formatter.CodeOrigin",toString:$estr}
};
formatter_CodeOrigin.__constructs__ = [formatter_CodeOrigin.SourceFile,formatter_CodeOrigin.Snippet];
class formatter_codedata_CodeLine {
	constructor(indent) {
		this.indent = indent;
		this.parts = [];
		this.emptyLinesAfter = 0;
		this.verbatim = false;
		this.partialLine = false;
	}
	addToken(tokenInfo) {
		if(tokenInfo.emptyLinesAfter > this.emptyLinesAfter) {
			this.emptyLinesAfter = tokenInfo.emptyLinesAfter;
		}
		if(this.currentPart == null) {
			this.currentPart = { firstToken : tokenInfo.token, lastToken : tokenInfo.token, text : "", multiLine : false, firstLineLength : -1, lastLineLength : -1};
			this.parts.push(this.currentPart);
		}
		this.currentPart.lastToken = tokenInfo.token;
		if(tokenInfo.spacesBefore > 0) {
			this.currentPart.text += StringTools.lpad(""," ",tokenInfo.spacesBefore);
		}
		if(tokenInfo.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space && tokenInfo.spacesAfter > 0) {
			this.currentPart.text += tokenInfo.text + StringTools.lpad(""," ",tokenInfo.spacesAfter);
		} else {
			this.currentPart.text += tokenInfo.text;
		}
		if(tokenInfo.wrapAfter) {
			this.currentPart = null;
		}
	}
	applyWrapping(config,parsedCode,indenter,lineSeparator) {
		let lineLength = indenter.calcAbsoluteIndent(this.indent);
		let _g = 0;
		let _g1 = this.parts;
		while(_g < _g1.length) this.calcLineLengths(_g1[_g++],lineSeparator);
		let _g2 = 0;
		let _g3 = this.parts.length;
		while(_g2 < _g3) {
			let index = _g2++;
			let part = this.parts[index];
			if(part.multiLine) {
				if(lineLength + part.firstLineLength > config.maxLineLength) {
					return this.wrappedAt(index,config,parsedCode,indenter);
				}
				lineLength = part.lastLineLength;
				continue;
			}
			lineLength += part.text.length;
			if(lineLength > config.maxLineLength) {
				return this.wrappedAt(index,config,parsedCode,indenter);
			}
		}
		return [this];
	}
	calcLineLengths(part,lineSeparator) {
		let lines = part.text.split(lineSeparator);
		part.multiLine = lines.length > 1;
		if(part.multiLine) {
			part.firstLineLength = lines[0].length;
			part.lastLineLength = lines[lines.length - 1].length;
		} else {
			part.firstLineLength = part.text.length;
			part.lastLineLength = -1;
		}
	}
	wrappedAt(index,config,parsedCode,indenter) {
		return this.wrapNormal(config,parsedCode,indenter);
	}
	wrapNormal(config,parsedCode,indenter) {
		if(this.parts.length <= 0) {
			return [this];
		}
		let line = new formatter_codedata_CodeLine(this.indent);
		let part = this.parts.shift();
		line.parts = [part];
		let lineLength = indenter.calcAbsoluteIndent(this.indent) + part.text.length;
		let lines = [line];
		let lastPart = part;
		while(this.parts.length > 0) {
			let p = this.parts.shift();
			let partLength = p.firstLineLength;
			if(!p.multiLine) {
				partLength = StringTools.rtrim(p.text).length;
			}
			if(lineLength + partLength >= config.maxLineLength) {
				parsedCode.tokenList.lineEndAfter(lastPart.lastToken);
				let info = parsedCode.tokenList.getTokenAt(p.firstToken.index);
				let additionalIndent = 0;
				if(info != null) {
					additionalIndent = info.additionalIndent;
				}
				let newIndent = indenter.calcIndent(p.firstToken) + additionalIndent;
				line = new formatter_codedata_CodeLine(newIndent);
				lineLength = indenter.calcAbsoluteIndent(newIndent);
				lines.push(line);
			}
			line.parts.push(p);
			if(p.lastLineLength <= 0) {
				lineLength += p.firstLineLength;
			} else {
				lineLength += p.lastLineLength;
			}
			lastPart = p;
		}
		line.emptyLinesAfter = this.emptyLinesAfter;
		return lines;
	}
	print(indenter,lineSeparator) {
		let line = "";
		let _g = 0;
		let _g1 = this.parts;
		while(_g < _g1.length) line += _g1[_g++].text;
		if(this.partialLine) {
			line = indenter.makeIndentString(this.indent) + line;
		} else {
			line = indenter.makeIndentString(this.indent) + StringTools.rtrim(line);
		}
		let _g2 = 0;
		let _g3 = this.emptyLinesAfter;
		while(_g2 < _g3) {
			++_g2;
			line += lineSeparator;
			if(indenter.shouldAddTrailingWhitespace()) {
				line += indenter.makeIndentString(this.indent);
			}
		}
		return line;
	}
}
formatter_codedata_CodeLine.__name__ = "formatter.codedata.CodeLine";
Object.assign(formatter_codedata_CodeLine.prototype, {
	__class__: formatter_codedata_CodeLine
});
class formatter_codedata_CodeLines {
	constructor(parsedCode,indenter,range) {
		this.lines = [];
		this.indenter = indenter;
		this.parsedCode = parsedCode;
		this.range = null;
		this.posRange = range;
		this.trailingWhitespaceAfterRange = "";
		this.rangeStartOffset = 0;
		this.rangeEndOffset = 0;
		if(range != null) {
			let start = parsedCode.tokenList.getTokenAtOffset(range.startPos);
			let end = parsedCode.tokenList.getTokenAtOffset(range.endPos);
			if(end != null && range.endPos - 1 < end.token.pos.min) {
				end = parsedCode.tokenList.getPreviousToken(end.token);
			}
			if(start != null && end != null) {
				if(start.token.tok._hx_index == 7) {
					this.rangeStartOffset = this.calcStartCommentOffset(start);
				} else {
					let startLine = parsedCode.getLinePos(start.token.pos.min);
					let rangeStartLine = parsedCode.getLinePos(range.startPos);
					parsedCode.getLinePos(start.token.pos.max);
					if(startLine.line != rangeStartLine.line) {
						this.rangeStartOffset = range.startPos - rangeStartLine.ofs - start.token.pos.min;
					}
				}
				if(end.token.tok._hx_index == 7) {
					this.rangeEndOffset = this.calcEndCommentOffset(end);
				} else if(this.posRange.endPos >= end.token.pos.min && this.posRange.endPos < end.token.pos.max) {
					this.rangeEndOffset = end.text.length - (end.token.pos.max - this.posRange.endPos);
				}
				this.range = { startPos : start.token.index, endPos : end.token.index};
			}
		}
		this.buildLines();
	}
	calcStartCommentOffset(info) {
		let commentLines = this.parsedCode.getString(info.token.pos.min,info.token.pos.max).split(this.parsedCode.lineSeparator);
		let index = 0;
		let offset = 0;
		let sepLength = this.parsedCode.lineSeparator.length;
		let pos = this.posRange.startPos - info.token.pos.min;
		let _g = 0;
		while(_g < commentLines.length) {
			let line = commentLines[_g];
			++_g;
			if(line.length + offset + sepLength > pos) {
				break;
			}
			offset += line.length + sepLength;
			++index;
		}
		commentLines = info.text.split(this.parsedCode.lineSeparator);
		offset = 0;
		let _g1 = 0;
		let _g2 = index;
		while(_g1 < _g2) offset += commentLines[_g1++].length + sepLength;
		return offset;
	}
	calcEndCommentOffset(info) {
		let commentLines = this.parsedCode.getString(info.token.pos.min,info.token.pos.max).split(this.parsedCode.lineSeparator);
		let index = 0;
		let offset = 0;
		let trailCount = 0;
		let pos = this.posRange.endPos - info.token.pos.min;
		let sepLength = this.parsedCode.lineSeparator.length;
		let _g = 0;
		while(_g < commentLines.length) {
			let line = commentLines[_g];
			++_g;
			if(line.length + offset + sepLength > pos) {
				trailCount = line.length - (pos - offset);
				break;
			}
			offset += line.length + sepLength;
			++index;
		}
		commentLines = info.text.split(this.parsedCode.lineSeparator);
		offset = 0;
		let _g1 = 0;
		let _g2 = index;
		while(_g1 < _g2) offset += commentLines[_g1++].length + sepLength;
		return offset + commentLines[index].length - trailCount;
	}
	buildLines() {
		let line = null;
		let index = 0;
		while(index < this.parsedCode.tokenList.tokens.length) {
			if(this.range != null) {
				if(index > this.range.endPos) {
					break;
				}
			}
			let tokenInfo = this.parsedCode.tokenList.getTokenAt(index);
			if(tokenInfo == null) {
				++index;
				continue;
			}
			let _g = tokenInfo.token.tok;
			if(_g._hx_index == 8) {
				if(_g.s == " @formatter:off") {
					line = null;
					index = this.skipFormatterOff(index);
					continue;
				}
			}
			if(this.range != null) {
				if(index < this.range.startPos) {
					++index;
					continue;
				}
			}
			if(line == null) {
				line = new formatter_codedata_CodeLine(this.indenter.calcIndent(tokenInfo.token) + tokenInfo.additionalIndent);
				this.lines.push(line);
			}
			if(this.range != null) {
				if(index == this.range.startPos && this.rangeStartOffset > 0) {
					tokenInfo.text = HxOverrides.substr(tokenInfo.text,this.rangeStartOffset,null);
					line.indent = 0;
				}
			}
			if(this.range != null && index == this.range.endPos) {
				if(this.posRange.endPos >= tokenInfo.token.pos.min && this.posRange.endPos < tokenInfo.token.pos.max) {
					let index = 0;
					if(this.range.endPos == this.range.startPos) {
						index = this.rangeStartOffset;
					}
					tokenInfo.text = HxOverrides.substr(tokenInfo.text,0,this.rangeEndOffset - index);
					tokenInfo.spacesAfter = 0;
					tokenInfo.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
					tokenInfo.emptyLinesAfter = 0;
					line.partialLine = true;
				}
				if(this.posRange.endPos > tokenInfo.token.pos.max) {
					this.trailingWhitespaceAfterRange = this.parsedCode.getString(tokenInfo.token.pos.max,this.posRange.endPos);
					line.partialLine = true;
				}
			}
			line.addToken(tokenInfo);
			if(tokenInfo.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				line = null;
			}
			++index;
		}
	}
	skipFormatterOff(index) {
		let startIndex = index++;
		let startInfo = this.parsedCode.tokenList.getTokenAt(startIndex);
		let startLine = this.parsedCode.getLinePos(startInfo.token.pos.min).line;
		while(index < this.parsedCode.tokenList.tokens.length) {
			let endIndex = index++;
			let tokenInfo = this.parsedCode.tokenList.getTokenAt(endIndex);
			if(tokenInfo == null) {
				continue;
			}
			if(this.range != null) {
				if(endIndex < this.range.startPos) {
					continue;
				}
				if(endIndex == this.range.startPos) {
					startInfo = this.parsedCode.tokenList.getTokenAt(endIndex);
					startLine = this.parsedCode.getLinePos(startInfo.token.pos.min).line;
				}
				if(endIndex >= this.range.endPos) {
					this.copyVerbatimChars(startInfo.token.pos.min,tokenInfo.token.pos.max);
					return index;
				}
			}
			let _g = tokenInfo.token.tok;
			if(_g._hx_index == 8) {
				if(_g.s == " @formatter:on") {
					if(this.range != null) {
						if(startIndex < this.range.startPos) {
							this.copyVerbatimChars(startInfo.token.pos.min,tokenInfo.token.pos.max);
							return index;
						}
					}
					this.copyVerbatimLines(startLine,this.parsedCode.getLinePos(tokenInfo.token.pos.max).line);
					return index;
				}
			}
		}
		this.copyVerbatimLines(startLine,this.parsedCode.lines.length - 1);
		return index;
	}
	copyVerbatimLines(startLine,endLine) {
		let content = this.parsedCode.getString(this.parsedCode.linesIdx[startLine].l,this.parsedCode.linesIdx[endLine].r);
		if(endLine < this.parsedCode.lines.length - 1) {
			content = StringTools.rtrim(content);
		}
		this.lines.push(new formatter_codedata_VerbatimCodeLine(content));
	}
	copyVerbatimChars(startPos,endPos) {
		let content = this.parsedCode.getString(startPos,endPos);
		this.lines.push(new formatter_codedata_VerbatimCodeLine(content));
	}
	applyWrapping(config,lineSeparator) {
		let wrappedLines = [];
		let _g = 0;
		let _g1 = this.lines;
		while(_g < _g1.length) wrappedLines = wrappedLines.concat(_g1[_g++].applyWrapping(config,this.parsedCode,this.indenter,lineSeparator));
		this.lines = wrappedLines;
	}
	print(lineSeparator) {
		let prefix = "";
		if(this.parsedCode.tokenList.leadingEmptyLInes > 0) {
			prefix = StringTools.lpad("",lineSeparator,lineSeparator.length * this.parsedCode.tokenList.leadingEmptyLInes);
		}
		if(this.range != null) {
			if(this.range.startPos > 0) {
				prefix = "";
			}
			if(this.lines.length > 0) {
				this.lines[this.lines.length - 1].emptyLinesAfter = 0;
			}
		}
		let _this = this.lines;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _this[i].print(this.indenter,lineSeparator);
		}
		return prefix + result.join(lineSeparator) + this.trailingWhitespaceAfterRange;
	}
}
formatter_codedata_CodeLines.__name__ = "formatter.codedata.CodeLines";
Object.assign(formatter_codedata_CodeLines.prototype, {
	__class__: formatter_codedata_CodeLines
});
class formatter_codedata_ParsedCode {
	constructor(inputData) {
		this.file = { name : inputData.fileName, content : inputData.content};
		try {
			this.removeBOM();
			if(inputData.lineSeparator == null) {
				this.detectLineSeparator();
			} else {
				this.lineSeparator = inputData.lineSeparator;
			}
			this.makeLines();
			this.makePosIndices();
			if(inputData.tokenList == null) {
				this.makeTokens();
				this.getTokenTree(inputData.entryPoint);
			} else {
				this.tokens = inputData.tokenList;
				this.root = inputData.tokenTree;
				this.makeTokenList();
			}
			this.checkTokens();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			throw haxe_Exception.thrown("failed to create parser context: " + (_g1 == null ? "null" : Std.string(_g1)));
		}
	}
	checkTokens() {
		if(this.tokens.length != this.tokenList.tokens.length) {
			throw haxe_Exception.thrown("token count mismatch");
		}
		let skipCount = 0;
		let _g = 0;
		let _g1 = this.tokens.length;
		while(_g < _g1) {
			let index = _g++;
			let info = this.tokenList.tokens[index];
			if(info == null) {
				if(skipCount <= 0) {
					throw haxe_Exception.thrown("missing token \"" + Std.string(this.tokens[index]) + "\" [" + index + "] detected!");
				}
				--skipCount;
				continue;
			}
			let token = info.token;
			let _g1 = token.tok;
			switch(_g1._hx_index) {
			case 2:
				let _gc = _g1.c;
				switch(_gc._hx_index) {
				case 0:
					if(_gc.v.startsWith("-")) {
						skipCount = 1;
					}
					break;
				case 1:
					if(_gc.f.startsWith("-")) {
						skipCount = 1;
					}
					break;
				case 5:
					let skipIndex = index + 1;
					while(this.tokens[skipIndex].pos.min < token.pos.max) {
						++skipCount;
						++skipIndex;
					}
					break;
				default:
					skipCount = 0;
				}
				break;
			case 6:
				let _gop = _g1.op;
				switch(_gop._hx_index) {
				case 8:
					skipCount = 1;
					break;
				case 17:
					skipCount = 1;
					break;
				case 18:
					skipCount = 2;
					break;
				case 20:
					switch(_gop.op._hx_index) {
					case 17:
						skipCount = 2;
						break;
					case 18:
						skipCount = 3;
						break;
					default:
						skipCount = 0;
					}
					break;
				default:
					skipCount = 0;
				}
				break;
			default:
				skipCount = 0;
			}
		}
	}
	getTokenTree(entryPoint) {
		if(this.tokens == null) {
			return null;
		}
		if(entryPoint == null) {
			entryPoint = tokentree_TokenTreeEntryPoint.TypeLevel;
		}
		if(this.root == null) {
			this.root = tokentree_TokenTreeBuilder.buildTokenTree(this.tokens,this.file.content,entryPoint);
			this.makeTokenList();
		}
		return this.root;
	}
	removeBOM() {
		if(this.file.content == null || this.file.content.length <= 2) {
			return;
		}
		if(this.file.content.b[0] == 239 && this.file.content.b[1] == 187 && this.file.content.b[2] == 191) {
			this.file.content = this.file.content.sub(3,this.file.content.length - 3);
		}
	}
	makeTokenList() {
		this.tokenList = new formatter_codedata_TokenList();
		this.tokenList.buildList(this.root);
	}
	makePosIndices() {
		let code = this.file.content;
		this.linesIdx = [];
		let last = 0;
		let left = false;
		let skip0A = false;
		let _g = 0;
		let _g1 = code.length;
		while(_g < _g1) {
			let i = _g++;
			let charCode = code.b[i];
			if(skip0A && charCode == 10) {
				skip0A = false;
				continue;
			}
			if(charCode == 10 || charCode == 13) {
				if(charCode == 13 && i + 1 < code.length && code.b[i + 1] == 10) {
					skip0A = true;
					this.linesIdx.push({ l : last, r : i + 1});
					last = i + 2;
				} else {
					this.linesIdx.push({ l : last, r : i});
					last = i + 1;
				}
			}
			left = true;
		}
		if(left) {
			this.linesIdx.push({ l : last, r : code.length});
		}
	}
	getLinePos(off) {
		let lowerBound = 0;
		let upperBound = this.linesIdx.length - 1;
		if(this.linesIdx.length <= 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off < 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off > this.linesIdx[upperBound].r) {
			throw haxe_Exception.thrown("Bad offset");
		}
		while(true) {
			if(lowerBound > upperBound) {
				throw haxe_Exception.thrown("Bad offset");
			}
			let center = lowerBound + Math.floor((upperBound - lowerBound) / 2);
			let matchLeft = this.linesIdx[center].l <= off;
			let matchRight = this.linesIdx[center].r >= off;
			if(matchLeft && matchRight) {
				return { line : center, ofs : off - this.linesIdx[center].l};
			}
			if(matchLeft) {
				lowerBound = center + 1;
				continue;
			}
			if(matchRight) {
				upperBound = center - 1;
				continue;
			}
		}
	}
	getString(off,off2) {
		let code = this.file.content;
		if(off >= code.length || off + (off2 - off) > code.length) {
			return "";
		}
		return code.sub(off,off2 - off).toString();
	}
	isOriginalNewlineBefore(token) {
		if(token == null) {
			return false;
		}
		let prev = this.tokenList.getPreviousToken(token);
		if(prev == null) {
			return false;
		}
		return !this.isOriginalSameLine(prev.token,token);
	}
	isOriginalSameLine(first,second) {
		return this.getLinePos(first.pos.max).line == this.getLinePos(second.pos.min).line;
	}
	linesBetweenOriginal(first,second) {
		let startLine = this.getLinePos(first.pos.min).line;
		return this.getLinePos(second.pos.min).line - startLine;
	}
	detectLineSeparator() {
		let code = this.file.content.toString();
		let _g = 0;
		let _g1 = code.length;
		while(_g < _g1) {
			let i = _g++;
			let char = code.charAt(i);
			if(char == "\r" || char == "\n") {
				this.lineSeparator = char;
				if(char == "\r" && i + 1 < code.length) {
					char = code.charAt(i + 1);
					if(char == "\n") {
						this.lineSeparator += char;
					}
				}
				return;
			}
		}
		this.lineSeparator = "\n";
	}
	makeLines() {
		this.lines = this.file.content.toString().split(this.lineSeparator);
		this.emptyLines = [];
		let _g = 0;
		let _g1 = this.lines.length;
		while(_g < _g1) {
			let index = _g++;
			let line = this.lines[index];
			if(line.startsWith("<<<<<<<")) {
				throw haxe_Exception.thrown("not formatting \"" + this.file.name + "\" - file contains a merge conflict");
			}
			if(new EReg("^\\s*$","").match(line)) {
				this.emptyLines.push(index);
			}
		}
	}
	makeTokens() {
		try {
			this.tokens = [];
			this.root = null;
			let lexer = new haxeparser_HaxeLexer(this.file.content,this.file.name);
			let t = lexer.token(haxeparser_HaxeLexer.tok);
			while(t.tok != haxeparser_TokenDef.Eof) {
				this.tokens.push(t);
				t = lexer.token(haxeparser_HaxeLexer.tok);
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof hxparse_ParserError)) {
				let e = _g1;
				throw haxe_Exception.thrown("failed to make tokens - ParserError: " + Std.string(e) + " (" + Std.string(e.pos) + ")");
			} else if(((_g1) instanceof haxeparser_LexerError)) {
				let e = _g1;
				throw haxe_Exception.thrown("failed to make tokens - LexerError: " + Std.string(e.msg) + " (" + Std.string(e.pos) + ")");
			} else {
				throw haxe_Exception.thrown("failed to make tokens " + (_g1 == null ? "null" : Std.string(_g1)));
			}
		}
	}
}
formatter_codedata_ParsedCode.__name__ = "formatter.codedata.ParsedCode";
Object.assign(formatter_codedata_ParsedCode.prototype, {
	__class__: formatter_codedata_ParsedCode
});
class formatter_codedata_TokenList {
	constructor() {
		this.tokens = [];
		this.leadingEmptyLInes = 0;
		this.closeTokenCache = new haxe_ds_IntMap();
	}
	buildList(token) {
		if(token.children == null) {
			return;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let index = child.index;
			if(index < 0 || child.inserted) {
				continue;
			}
			if(child.index >= this.tokens.length) {
				this.fill(child.index - this.tokens.length);
			}
			this.tokens[index] = { token : child, whitespaceAfter : formatter_codedata_WhitespaceAfterType.None, spacesBefore : 0, spacesAfter : 0, emptyLinesAfter : 0, wrapAfter : false, text : null, additionalIndent : 0};
			this.buildList(child);
		}
	}
	fill(count) {
		while(count-- > 0) this.tokens.push(null);
	}
	getCloseToken(token) {
		if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
			return null;
		}
		if(token.index < 0 || token.index >= this.tokens.length) {
			return null;
		}
		if(this.closeTokenCache.h.hasOwnProperty(token.index)) {
			return this.closeTokenCache.h[token.index];
		}
		let result;
		switch(token.tok._hx_index) {
		case 16:
			result = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.BkClose);
			break;
		case 18:
			result = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.BrClose);
			break;
		case 20:
			result = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.PClose);
			break;
		default:
			return null;
		}
		if(result == null) {
			return null;
		}
		this.closeTokenCache.h[token.index] = result;
		return result;
	}
	getTokenAtOffset(off) {
		if(this.tokens.length <= 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off < 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off > this.tokens[this.tokens.length - 1].token.pos.max) {
			throw haxe_Exception.thrown("Bad offset");
		}
		let _g = 0;
		let _g1 = this.tokens;
		while(_g < _g1.length) {
			let token = _g1[_g];
			++_g;
			if(token == null) {
				continue;
			}
			if(token.token.pos.max >= off) {
				return token;
			}
		}
		throw haxe_Exception.thrown("Bad offset");
	}
	getTokenAt(index) {
		if(index < 0 || index >= this.tokens.length) {
			return null;
		}
		return this.tokens[index];
	}
	getPreviousToken(token) {
		if(token == null || token.index <= 0) {
			return null;
		}
		let prevToken = null;
		let prevIndex = token.index - 1;
		if(prevIndex >= this.tokens.length) {
			return null;
		}
		while(prevToken == null) {
			prevToken = this.tokens[prevIndex--];
			if(prevIndex < 0) {
				return null;
			}
		}
		return prevToken;
	}
	getNextToken(token) {
		if(token == null || token.index <= 0) {
			return null;
		}
		let nextToken = null;
		let nextIndex = token.index + 1;
		if(nextIndex >= this.tokens.length) {
			return null;
		}
		while(nextToken == null) {
			nextToken = this.tokens[nextIndex++];
			if(nextIndex < 0) {
				return null;
			}
		}
		return nextToken;
	}
	whitespace(token,where) {
		if(token.index < 0) {
			return;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		let prev = null;
		let prevIndex = token.index - 1;
		while(prev == null) {
			if(prevIndex < 0) {
				break;
			}
			prev = this.tokens[prevIndex--];
		}
		if(prev != null && this.needsLineBreak(prev.token)) {
			prev = null;
		}
		switch(where) {
		case "after":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "around":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.Space);
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "before":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "none":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.None);
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.None);
			break;
		case "noneAfter":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.None);
			break;
		case "noneBefore":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.None);
			break;
		case "onlyAfter":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.None);
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "onlyBefore":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.Space);
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.None);
			break;
		}
	}
	applyWhitespace(info,policy) {
		if(info == null) {
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			info.whitespaceAfter = policy;
			switch(policy._hx_index) {
			case 0:
				info.spacesAfter = 0;
				break;
			case 1:
				this.shouldHaveOneSpaceAfter(info);
				break;
			case 2:
				break;
			}
			break;
		case 1:
			switch(policy._hx_index) {
			case 0:
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
				info.spacesAfter = 0;
				break;
			case 1:
				this.shouldHaveOneSpaceAfter(info);
				break;
			case 2:
				info.whitespaceAfter = policy;
				break;
			}
			break;
		case 2:
			switch(policy._hx_index) {
			case 0:
				if(info.spacesAfter > 0) {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				} else {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
					info.spacesAfter = 0;
				}
				break;
			case 1:
				info.whitespaceAfter = policy;
				this.shouldHaveOneSpaceAfter(info);
				break;
			case 2:
				break;
			}
			break;
		}
	}
	shouldHaveOneSpaceAfter(info) {
		if(info == null) {
			return;
		}
		if(info.spacesAfter <= 0) {
			info.spacesAfter = 1;
		}
	}
	spacesBefore(token,count) {
		if(token.index < 0) {
			return;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.spacesBefore = count;
	}
	lineEndAfter(token) {
		if(token.index < 0) {
			return;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 1:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 2:
			break;
		}
	}
	lineEndBefore(token) {
		let info = this.getPreviousToken(token);
		if(info == null) {
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 1:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 2:
			break;
		}
	}
	needsLineBreak(token) {
		if(token == null) {
			return false;
		}
		if(token.tok._hx_index == 8) {
			return true;
		}
		return false;
	}
	noLineEndAfter(token) {
		if(token.index < 0) {
			return;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		if(this.needsLineBreak(info.token)) {
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			return;
		case 1:
			break;
		case 2:
			if(info.spacesAfter <= 0) {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
			} else {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				this.shouldHaveOneSpaceAfter(info);
			}
			break;
		}
	}
	noLineEndBefore(token) {
		let info = this.getPreviousToken(token);
		if(info == null) {
			return;
		}
		if(this.needsLineBreak(info.token)) {
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			return;
		case 1:
			break;
		case 2:
			if(info.spacesAfter <= 0) {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
			} else {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				this.shouldHaveOneSpaceAfter(info);
			}
			break;
		}
	}
	emptyLinesAfter(token,count) {
		if(token.index < 0) {
			return;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.emptyLinesAfter = count;
	}
	emptyLinesBefore(token,count) {
		if(token.index <= 0) {
			this.leadingEmptyLInes = count;
			return;
		}
		let info = this.getPreviousToken(token);
		if(info == null) {
			return;
		}
		info.emptyLinesAfter = count;
	}
	emptyLinesAfterSubTree(token,count) {
		let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
		if(lastToken == null) {
			return;
		}
		let info = this.tokens[lastToken.index];
		if(info == null) {
			return;
		}
		info.emptyLinesAfter = count;
	}
	tokenText(token,text) {
		if(token.index < 0) {
			return;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.text = text;
	}
	wrapAfter(token,wrap) {
		if(token.index < 0) {
			return;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.wrapAfter = wrap;
	}
	wrapBefore(token,wrap) {
		let prev = this.getPreviousToken(token);
		if(prev == null) {
			return;
		}
		prev.wrapAfter = wrap;
	}
	noWrappingBetween(tokenStart,tokenEnd,config,allowCommas) {
		if(allowCommas == null) {
			allowCommas = true;
		}
		if(tokenStart == null || tokenEnd == null) {
			return;
		}
		let index = tokenStart.index;
		while(index < tokenEnd.index) {
			let first = index == tokenStart.index;
			let info = this.tokens[index++];
			let next = this.tokens[index];
			if(info == null) {
				continue;
			}
			let _g = info.token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 41:
					let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(info.token);
					if(lastChild != null) {
						if(lastChild.index > index) {
							index = lastChild.index;
						}
						continue;
					}
					break;
				default:
				}
				break;
			case 7:
				continue;
			case 8:
				continue;
			case 14:
				let lastChild1 = tokentree_utils_TokenTreeCheckUtils.getLastToken(info.token);
				if(lastChild1 != null) {
					if(lastChild1.index > index) {
						index = lastChild1.index;
					}
					continue;
				}
				break;
			case 15:
				if(allowCommas) {
					continue;
				}
				break;
			case 16:
				if(!first) {
					let close = this.getCloseToken(info.token);
					if(close != null) {
						index = close.index;
						continue;
					}
				}
				break;
			case 18:
				if(!first) {
					let close = this.getCloseToken(info.token);
					if(close != null) {
						index = close.index;
						continue;
					}
				}
				break;
			case 20:
				if(!first) {
					let close = this.getCloseToken(info.token);
					if(close != null) {
						index = close.index;
						continue;
					}
				}
				break;
			default:
			}
			info.wrapAfter = false;
			if(next != null) {
				if(next.token.tok._hx_index == 18) {
					switch(config.lineEnds.leftCurly) {
					case "after":case "none":
						break;
					case "before":case "both":
						continue;
					}
				}
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				if(info.spacesAfter <= 0) {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
				} else {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
					this.shouldHaveOneSpaceAfter(info);
				}
				break;
			}
		}
	}
	additionalIndent(token,indent) {
		if(indent == null || token == null || token.index < 0) {
			return;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.additionalIndent = indent;
	}
	increaseIndentBetween(start,end,depth) {
		if(depth == 0 || start == null || start.index < 0 || end == null || end.index < 0) {
			return;
		}
		let startIndex = start.index;
		if(depth > 0) {
			++startIndex;
		}
		let endIndex = end.index;
		let _g = startIndex;
		while(_g < endIndex) {
			let info = this.tokens[_g++];
			if(info == null) {
				continue;
			}
			info.additionalIndent += depth;
		}
	}
	findTokenAtOffset(offset) {
		let lastInfo = null;
		let _g = 0;
		let _g1 = this.tokens;
		while(_g < _g1.length) {
			let info = _g1[_g];
			++_g;
			if(info == null) {
				continue;
			}
			if(info.token.pos.min >= offset) {
				return lastInfo;
			}
			lastInfo = info;
		}
		return lastInfo;
	}
	isSameLine(first,second) {
		let startIndex = first.index;
		let endIndex = second.index;
		if(startIndex == endIndex) {
			return true;
		}
		if(startIndex < 0 || endIndex < 0) {
			return false;
		}
		if(startIndex > endIndex) {
			startIndex = second.index;
			endIndex = first.index;
		}
		while(startIndex < endIndex) {
			let currTok = this.tokens[startIndex++];
			if(currTok == null) {
				continue;
			}
			if(currTok.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				return false;
			}
		}
		return true;
	}
	findLowestIndex(start) {
		let lowest = start;
		if(!start.hasChildren()) {
			return start;
		}
		let _g = 0;
		let _g1 = start.children;
		while(_g < _g1.length) {
			let token = this.findLowestIndex(_g1[_g++]);
			if(token.index < lowest.index) {
				lowest = token;
			}
		}
		return lowest;
	}
	calcLength(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		let current = this.tokens[token.index];
		if(current == null) {
			return 0;
		}
		let spaceAdd = 0;
		if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space) {
			spaceAdd = 1;
		}
		if(current.text == null) {
			current.text = "" + Std.string(current.token);
		}
		let length = current.text.length + spaceAdd;
		if(token.children == null || token.children.length <= 0) {
			return length;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) length += this.calcLength(_g1[_g++]);
		return length;
	}
	isMultilineToken(token) {
		if(token == null || token.index < 0) {
			return false;
		}
		let current = this.tokens[token.index];
		if(current == null) {
			return false;
		}
		if(current.text.indexOf("\r") >= 0 || current.text.indexOf("\n") >= 0) {
			return true;
		}
		return false;
	}
	calcLengthUntilNewline(token,stop) {
		if(token == null || token.index < 0) {
			return 0;
		}
		let endIndex = this.tokens.length - 1;
		if(stop != null) {
			endIndex = stop.index;
		}
		let index = token.index;
		let length = 0;
		while(index <= endIndex) {
			let current = this.tokens[index++];
			if(current == null) {
				continue;
			}
			if(current.text == null) {
				current.text = "" + Std.string(current.token);
			}
			if(current.text.indexOf("\r") >= 0) {
				length += current.text.indexOf("\r");
				break;
			}
			if(current.text.indexOf("\n") >= 0) {
				length += current.text.indexOf("\n");
				break;
			}
			length += current.spacesBefore;
			if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space) {
				length += current.spacesAfter;
			}
			length += current.text.length;
			if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				break;
			}
		}
		return length;
	}
	calcLengthBetween(tokenStart,tokenEnd) {
		if(tokenStart == null || tokenEnd == null) {
			return 0;
		}
		if(tokenStart.index < 0 || tokenEnd.index < 0) {
			return 0;
		}
		let length = 0;
		let _g = tokenStart.index;
		let _g1 = tokenEnd.index;
		while(_g < _g1) {
			let current = this.tokens[_g++];
			if(current == null) {
				continue;
			}
			if(current.text == null) {
				current.text = "" + Std.string(current.token);
			}
			length += current.text.length;
			if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space) {
				++length;
			}
		}
		return length;
	}
	calcLineLength(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		let start = token.index - 1;
		while(start >= 0) {
			let info = this.tokens[start--];
			if(info == null) {
				continue;
			}
			if(info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				start += 2;
				break;
			}
		}
		let length = 0;
		_hx_loop2: while(start < this.tokens.length) {
			let info = this.tokens[start++];
			if(info == null) {
				continue;
			}
			length += info.text.length;
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				length += info.spacesAfter;
				break;
			case 2:
				break _hx_loop2;
			}
		}
		return length;
	}
	calcLineLengthBefore(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		let start = token.index - 1;
		let length = 0;
		_hx_loop1: while(start >= 0) {
			let info = this.tokens[start--];
			if(info == null) {
				continue;
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				length += info.spacesAfter;
				break;
			case 2:
				break _hx_loop1;
			}
			length += info.text.length;
		}
		return length;
	}
	calcLineLengthAfter(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		let start = token.index + 1;
		let length = 0;
		_hx_loop1: while(start < this.tokens.length) {
			let info = this.tokens[start++];
			if(info == null) {
				continue;
			}
			let tokenLength = info.text.length;
			let linefeed = info.text.lastIndexOf("\r");
			if(linefeed >= 0) {
				tokenLength -= linefeed;
			}
			linefeed = info.text.lastIndexOf("\n");
			if(linefeed >= 0) {
				tokenLength -= linefeed;
			}
			length += tokenLength;
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				length += info.spacesAfter;
				break;
			case 2:
				break _hx_loop1;
			}
		}
		return length;
	}
	calcTokenLength(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		let info = this.tokens[token.index];
		if(info == null) {
			return 0;
		}
		let length = info.text.length;
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			break;
		case 1:
			length += info.spacesAfter;
			break;
		case 2:
			break;
		}
		return length;
	}
	isNewLineBefore(token) {
		let info = this.getPreviousToken(token);
		if(info == null) {
			return false;
		}
		return info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline;
	}
	isNewLineAfter(token) {
		let info = this.getTokenAt(token.index);
		if(info == null) {
			return false;
		}
		return info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline;
	}
	isSameLineBetween(tokenStart,tokenEnd,exclude) {
		if(tokenStart == null || tokenEnd == null) {
			return true;
		}
		let start = tokenStart.index;
		let end = tokenEnd.index;
		if(exclude) {
			++start;
		}
		let _g = start;
		while(_g < end) {
			let info = this.tokens[_g++];
			if(info == null) {
				continue;
			}
			if(info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				return false;
			}
			if(info.text == null) {
				continue;
			}
			if(info.text.indexOf("\r") >= 0 || info.text.indexOf("\n") >= 0) {
				return false;
			}
		}
		return true;
	}
	findLineStartToken(token) {
		if(token == null || token.index < 0) {
			return null;
		}
		let start = token.index - 1;
		while(true) {
			if(start < 0) {
				return this.tokens[0].token;
			}
			let info = this.tokens[start--];
			if(info == null) {
				continue;
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				return token;
			}
			token = info.token;
		}
	}
}
formatter_codedata_TokenList.__name__ = "formatter.codedata.TokenList";
Object.assign(formatter_codedata_TokenList.prototype, {
	__class__: formatter_codedata_TokenList
});
class formatter_codedata_VerbatimCodeLine extends formatter_codedata_CodeLine {
	constructor(content) {
		super(0);
		this.content = content;
		this.verbatim = true;
	}
	applyWrapping(config,parsedCode,indenter,lineSeparator) {
		return [this];
	}
	print(indenter,lineSeparator) {
		return this.content;
	}
}
formatter_codedata_VerbatimCodeLine.__name__ = "formatter.codedata.VerbatimCodeLine";
formatter_codedata_VerbatimCodeLine.__super__ = formatter_codedata_CodeLine;
Object.assign(formatter_codedata_VerbatimCodeLine.prototype, {
	__class__: formatter_codedata_VerbatimCodeLine
});
var formatter_codedata_WhitespaceAfterType = $hxEnums["formatter.codedata.WhitespaceAfterType"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"formatter.codedata.WhitespaceAfterType",toString:$estr}
	,Space: {_hx_name:"Space",_hx_index:1,__enum__:"formatter.codedata.WhitespaceAfterType",toString:$estr}
	,Newline: {_hx_name:"Newline",_hx_index:2,__enum__:"formatter.codedata.WhitespaceAfterType",toString:$estr}
};
formatter_codedata_WhitespaceAfterType.__constructs__ = [formatter_codedata_WhitespaceAfterType.None,formatter_codedata_WhitespaceAfterType.Space,formatter_codedata_WhitespaceAfterType.Newline];
class formatter_config_Config {
	constructor() {
		this.excludes = [];
		this.readConfigFromString("{}","hxformat.json");
	}
	readConfig(fileName) {
		if(!sys_FileSystem.exists(fileName)) {
			return;
		}
		this.readConfigFromString(js_node_Fs.readFileSync(fileName,{ encoding : "utf8"}),fileName);
	}
	readConfigFromString(jsonContent,fileName) {
		let data = new JsonParser_$1().fromJson(jsonContent,fileName);
		this.emptyLines = data.emptyLines;
		this.indentation = data.indentation;
		this.lineEnds = data.lineEnds;
		this.sameLine = data.sameLine;
		this.whitespace = data.whitespace;
		this.wrapping = data.wrapping;
		this.disableFormatting = data.disableFormatting;
		this.excludes = [];
		this.configFileName = fileName;
		let _g = 0;
		let _g1 = data.excludes;
		while(_g < _g1.length) this.excludes.push(new EReg(_g1[_g++],""));
	}
	isExcluded(fileName) {
		let _g = 0;
		let _g1 = this.excludes;
		while(_g < _g1.length) if(_g1[_g++].match(fileName)) {
			return true;
		}
		return false;
	}
}
formatter_config_Config.__name__ = "formatter.config.Config";
Object.assign(formatter_config_Config.prototype, {
	__class__: formatter_config_Config
});
class formatter_config_WhitespacePolicy {
	static remove(policy,removePolicy) {
		switch(removePolicy) {
		case "after":
			break;
		case "around":
			return "none";
		case "before":
			break;
		case "none":
			return policy;
		case "noneAfter":
			removePolicy = "after";
			break;
		case "noneBefore":
			removePolicy = "before";
			break;
		case "onlyAfter":
			removePolicy = "after";
			break;
		case "onlyBefore":
			removePolicy = "before";
			break;
		}
		switch(policy) {
		case "after":
			if(removePolicy == "after") {
				return "none";
			}
			break;
		case "around":
			if(removePolicy == "before") {
				return "after";
			}
			if(removePolicy == "after") {
				return "before";
			}
			break;
		case "before":
			if(removePolicy == "before") {
				return "none";
			}
			break;
		case "none":
			return "none";
		case "noneAfter":
			return "noneAfter";
		case "noneBefore":
			return "noneBefore";
		case "onlyAfter":
			if(removePolicy == "after") {
				return "none";
			}
			break;
		case "onlyBefore":
			if(removePolicy == "before") {
				return "none";
			}
			break;
		}
		return policy;
	}
	static add(policy,addPolicy) {
		switch(addPolicy) {
		case "after":
			break;
		case "around":
			return "none";
		case "before":
			break;
		case "none":
			return policy;
		case "noneAfter":
			addPolicy = "after";
			break;
		case "noneBefore":
			addPolicy = "before";
			break;
		case "onlyAfter":
			addPolicy = "after";
			break;
		case "onlyBefore":
			addPolicy = "before";
			break;
		}
		switch(policy) {
		case "after":
			if(addPolicy == "before") {
				return "around";
			}
			break;
		case "around":
			break;
		case "before":
			if(addPolicy == "after") {
				return "around";
			}
			break;
		case "none":
			return addPolicy;
		case "noneAfter":
			if(addPolicy == "before") {
				return "onlyBefore";
			}
			if(addPolicy == "after") {
				return "onlyAfter";
			}
			break;
		case "noneBefore":
			if(addPolicy == "before") {
				return "onlyBefore";
			}
			if(addPolicy == "after") {
				return "onlyAfter";
			}
			break;
		case "onlyAfter":
			if(addPolicy == "before") {
				return "around";
			}
			break;
		case "onlyBefore":
			if(addPolicy == "after") {
				return "around";
			}
			break;
		}
		return policy;
	}
}
class formatter_marker_Indenter {
	constructor(config) {
		this.config = config;
		if(config.character.toLowerCase() == "tab") {
			config.character = "\t";
		}
	}
	setParsedCode(parsedCode) {
		this.parsedCode = parsedCode;
	}
	makeIndentString(count) {
		return StringTools.lpad("",this.config.character,this.config.character.length * count);
	}
	calcAbsoluteIndent(indent) {
		if(this.config.character == "\t") {
			return indent * this.config.tabWidth;
		}
		return indent * this.config.character.length;
	}
	calcIndent(token) {
		if(token == null) {
			return 0;
		}
		if(token.tok._hx_index == 3) {
			if(this.config.conditionalPolicy == "fixedZero") {
				return 0;
			}
			if(this.config.conditionalPolicy == "fixedZeroIncrease") {
				return this.calcConditionalLevel(token);
			}
			if(this.config.conditionalPolicy == "fixedZeroIncreaseBlocks") {
				if(this.hasBlockParent(token)) {
					return this.calcConditionalLevel(token);
				}
				return 0;
			}
		}
		return this.calcFromCandidates(this.findEffectiveParent(token));
	}
	calcConditionalLevel(token) {
		let count = -1;
		while(token != null && token.tok != tokentree_TokenTreeDef.Root) {
			let _g = token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "if") {
					++count;
				}
			}
			token = token.parent;
		}
		if(count <= 0) {
			return 0;
		}
		return count;
	}
	calcConsecutiveConditionalLevel(token) {
		let count = -1;
		let maxCount = -1;
		while(token != null && token.tok != tokentree_TokenTreeDef.Root) {
			let _g = token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "if") {
					++count;
				}
			} else {
				if(count > maxCount) {
					maxCount = count;
				}
				count = -1;
			}
			token = token.parent;
		}
		if(count > maxCount) {
			maxCount = count;
		}
		if(maxCount <= 0) {
			return 0;
		}
		return maxCount;
	}
	shouldAddTrailingWhitespace() {
		return this.config.trailingWhitespace;
	}
	findEffectiveParent(token) {
		if(token.tok == tokentree_TokenTreeDef.Root) {
			return token.getFirstChild();
		}
		let _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				let parent = token.parent;
				if(parent.tok == tokentree_TokenTreeDef.Root) {
					return token;
				}
				if(parent.tok._hx_index == 20) {
					if(this.parsedCode.tokenList.isNewLineBefore(token)) {
						return token;
					}
					return this.findEffectiveParent(token.parent);
				}
				break;
			case 3:
				let prev = this.parsedCode.tokenList.getPreviousToken(token);
				if(prev == null) {
					return token;
				}
				if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
					return token;
				}
				let this1 = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.At);
				if(this1 != null) {
					if(!this.parsedCode.tokenList.isSameLineBetween(this1,token,false)) {
						return token;
					}
					prev = this.parsedCode.tokenList.getPreviousToken(this1);
					if(prev == null) {
						return token;
					}
					if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
						return token;
					}
				}
				let parent1 = token.parent;
				if(parent1.tok == tokentree_TokenTreeDef.Root) {
					return token;
				}
				let _g1 = parent1.tok;
				switch(_g1._hx_index) {
				case 1:
					if(_g1.k._hx_index != 4) {
						return token;
					}
					break;
				case 6:
					return token;
				default:
				}
				return this.findEffectiveParent(token.parent);
			case 5:
				let parent2 = token.parent;
				if(parent2.tok == tokentree_TokenTreeDef.Root) {
					return token;
				}
				let tmp;
				if(parent2 != null) {
					let _g = parent2.tok;
					tmp = _g._hx_index == 1 && _g.k._hx_index == 6;
				} else {
					tmp = false;
				}
				if(tmp) {
					return this.findEffectiveParent(token.parent);
				}
				break;
			case 4:case 21:
				return this.findEffectiveParent(token.parent);
			default:
			}
			break;
		case 3:
			switch(_g.s) {
			case "else":case "elseif":case "end":
				return this.findEffectiveParent(token.parent);
			default:
			}
			break;
		case 7:
			let next = this.parsedCode.tokenList.getNextToken(token);
			if(next == null) {
				return token;
			}
			let _g2 = next.token.tok;
			if(_g2._hx_index == 1) {
				switch(_g2.k._hx_index) {
				case 4:
					return this.findEffectiveParent(next.token);
				case 21:
					return this.findEffectiveParent(next.token);
				default:
					return token;
				}
			} else {
				return token;
			}
			break;
		case 8:
			let next1 = this.parsedCode.tokenList.getNextToken(token);
			if(next1 == null) {
				return token;
			}
			let _g3 = next1.token.tok;
			if(_g3._hx_index == 1) {
				switch(_g3.k._hx_index) {
				case 4:
					return this.findEffectiveParent(next1.token);
				case 21:
					return this.findEffectiveParent(next1.token);
				default:
					return token;
				}
			} else {
				return token;
			}
			break;
		case 14:
			return this.findEffectiveParent(token.parent);
		case 17:case 19:
			return this.findEffectiveParent(token.parent);
		case 18:
			let parent3 = token.parent;
			if(parent3.tok == tokentree_TokenTreeDef.Root) {
				return token;
			}
			let firstToken = this.findEffectiveParentLineStart(token);
			if(firstToken != null) {
				return firstToken;
			}
			switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token)._hx_index) {
			case 0:
				break;
			case 1:
				return token.parent;
			case 2:
				return token;
			case 3:
				return token;
			case 4:
				break;
			}
			let _g4 = parent3.tok;
			switch(_g4._hx_index) {
			case 1:
				switch(_g4.k._hx_index) {
				case 0:
					if(this.parsedCode.tokenList.isNewLineBefore(parent3)) {
						return parent3;
					}
					return this.findEffectiveParent(parent3);
				case 3:case 4:
					return this.findEffectiveParent(parent3);
				case 5:case 6:case 7:
					return this.findEffectiveParent(parent3);
				case 14:
					return this.findEffectiveParent(parent3);
				case 20:case 21:
					return this.findEffectiveParent(parent3);
				case 22:
					let _g5 = parent3.parent.tok;
					if(_g5._hx_index == 1 && _g5.k._hx_index == 0) {
						return this.findEffectiveParent(parent3.parent);
					}
					break;
				case 29:
					return this.findEffectiveParent(parent3);
				default:
				}
				break;
			case 2:
				if(_g4.c._hx_index == 3) {
					let _g = parent3.parent.tok;
					if(_g._hx_index == 1 && _g.k._hx_index == 0) {
						return this.findEffectiveParent(parent3.parent);
					}
				}
				break;
			case 6:
				switch(_g4.op._hx_index) {
				case 4:
					let access = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(parent3)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef));
					if(access != null) {
						return access;
					}
					break;
				case 20:
					let access1 = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(parent3)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef));
					if(access1 != null) {
						return access1;
					}
					break;
				default:
				}
				break;
			default:
			}
			break;
		case 20:
			let firstToken1 = this.findEffectiveParentLineStart(token);
			if(firstToken1 != null) {
				return firstToken1;
			}
			break;
		case 21:
			return this.findEffectiveParent(token.parent);
		default:
		}
		return token;
	}
	findEffectiveParentLineStart(token) {
		let firstToken = this.parsedCode.tokenList.findLineStartToken(token);
		if(firstToken == null) {
			return null;
		}
		if(firstToken.index == token.index) {
			return null;
		}
		switch(firstToken.tok._hx_index) {
		case 17:case 19:
			let next = this.parsedCode.tokenList.getNextToken(firstToken);
			if(next != null) {
				switch(next.token.tok._hx_index) {
				case 6:
					return this.findEffectiveParent(firstToken);
				case 11:case 15:case 17:case 19:case 21:
					return this.findEffectiveParent(firstToken);
				default:
				}
			}
			break;
		case 21:
			let next1 = this.parsedCode.tokenList.getNextToken(firstToken);
			if(next1 != null) {
				switch(next1.token.tok._hx_index) {
				case 6:
					return this.findEffectiveParent(firstToken);
				case 11:
					return this.findEffectiveParent(firstToken);
				default:
				}
			}
			break;
		default:
		}
		return null;
	}
	countLineBreaks(indentingTokensCandidates,indentComplexValueExpressions) {
		let count = 0;
		let prevToken = null;
		let currentToken = null;
		let mustIndent;
		let lastIndentingToken = null;
		let skipToToken = null;
		let _g = 0;
		while(_g < indentingTokensCandidates.length) {
			let token = indentingTokensCandidates[_g];
			++_g;
			prevToken = currentToken;
			if(prevToken == null) {
				prevToken = token;
			}
			currentToken = token;
			if(skipToToken != null) {
				if(token.index >= skipToToken.index) {
					continue;
				}
				prevToken = skipToToken;
				skipToToken = null;
			}
			if(prevToken.index == token.index) {
				continue;
			}
			switch(token.tok._hx_index) {
			case 16:case 18:
				let close = this.parsedCode.tokenList.getCloseToken(token);
				if(close != null && close.index >= 0 && close.index < prevToken.index) {
					currentToken = prevToken;
					continue;
				}
				break;
			default:
			}
			mustIndent = false;
			let _g1 = prevToken.tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 0:
					if(token.tok._hx_index == 20) {
						if(this.parsedCode.tokenList.isSameLineBetween(token,prevToken,false)) {
							continue;
						}
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							let firstToken = this.parsedCode.tokenList.getPreviousToken(prevToken);
							while(firstToken != null && !this.parsedCode.tokenList.isNewLineBefore(firstToken.token)) firstToken = this.parsedCode.tokenList.getPreviousToken(firstToken.token);
							let this1 = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.BrOpen);
							if(this1 != null) {
								if(!this.parsedCode.tokenList.isSameLineBetween(prevToken,this1,false)) {
									continue;
								}
							}
							return count + this.calcIndent(firstToken.token);
						}
					}
					break;
				case 3:
					let _g2 = token.tok;
					if(_g2._hx_index == 6) {
						if(_g2.op._hx_index == 4) {
							if(indentComplexValueExpressions) {
								mustIndent = true;
							}
						} else if(this.parsedCode.tokenList.isSameLineBetween(token,prevToken,false)) {
							let this1 = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
							if(this1 != null) {
								if(this.parsedCode.tokenList.isSameLineBetween(prevToken,this1,false)) {
									continue;
								}
								if(indentComplexValueExpressions) {
									mustIndent = true;
								}
							}
							let this2 = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.BrOpen);
							if(this2 != null) {
								if(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(this2)._hx_index == 0) {
									continue;
								}
							}
						}
					} else if(this.parsedCode.tokenList.isSameLineBetween(token,prevToken,false)) {
						let this1 = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
						if(this1 != null) {
							if(this.parsedCode.tokenList.isSameLineBetween(prevToken,this1,false)) {
								continue;
							}
							if(indentComplexValueExpressions) {
								mustIndent = true;
							}
						}
						let this2 = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.BrOpen);
						if(this2 != null) {
							if(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(this2)._hx_index == 0) {
								continue;
							}
						}
					}
					break;
				case 4:
					continue;
				case 14:
					switch(token.tok._hx_index) {
					case 6:
						if(indentComplexValueExpressions) {
							mustIndent = true;
						}
						break;
					case 20:
						switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(token)._hx_index) {
						case 0:
							break;
						case 1:
							mustIndent = true;
							break;
						case 2:
							break;
						case 3:
							mustIndent = true;
							break;
						case 4:
							mustIndent = true;
							break;
						case 5:
							mustIndent = true;
							break;
						case 6:
							mustIndent = true;
							break;
						case 7:
							mustIndent = true;
							break;
						case 8:
							break;
						case 9:
							break;
						}
						break;
					default:
					}
					break;
				case 15:case 16:
					if(!this.config.indentCaseLabels) {
						continue;
					}
					break;
				case 21:
					let _g3 = token.tok;
					if(_g3._hx_index == 1 && _g3.k._hx_index == 20) {
						continue;
					}
					break;
				default:
				}
				break;
			case 2:
				let _gc = _g1.c;
				if(_gc._hx_index == 3) {
					switch(_gc.s) {
					case "from":case "to":
						if(this.isAbstractFromTo(token) && this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							mustIndent = true;
						}
						break;
					default:
					}
				}
				break;
			case 11:
				let _g4 = token.tok;
				switch(_g4._hx_index) {
				case 1:
					switch(_g4.k._hx_index) {
					case 15:case 16:
						continue;
					case 10:case 22:case 29:
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							continue;
						}
						break;
					default:
						if(this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							++count;
							continue;
						}
					}
					break;
				case 6:
					switch(_g4.op._hx_index) {
					case 4:
						if(this.parsedCode.tokenList.isSameLineBetween(token,prevToken,false)) {
							continue;
						}
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							let firstToken = this.parsedCode.tokenList.getPreviousToken(prevToken);
							while(firstToken != null && !this.parsedCode.tokenList.isNewLineBefore(firstToken.token)) firstToken = this.parsedCode.tokenList.getPreviousToken(firstToken.token);
							return count + this.calcIndent(firstToken.token);
						}
						break;
					case 20:
						if(this.parsedCode.tokenList.isSameLineBetween(token,prevToken,false)) {
							continue;
						}
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							let firstToken = this.parsedCode.tokenList.getPreviousToken(prevToken);
							while(firstToken != null && !this.parsedCode.tokenList.isNewLineBefore(firstToken.token)) firstToken = this.parsedCode.tokenList.getPreviousToken(firstToken.token);
							return count + this.calcIndent(firstToken.token);
						}
						break;
					default:
						if(this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							++count;
							continue;
						}
					}
					break;
				case 11:
					if(!(prevToken.pos.min == token.pos.min && this.parsedCode.tokenList.isNewLineBefore(token))) {
						continue;
					}
					break;
				case 16:case 18:case 20:
					if(this.parsedCode.tokenList.isSameLine(token,prevToken)) {
						continue;
					}
					mustIndent = true;
					break;
				default:
					if(this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
						++count;
						continue;
					}
				}
				break;
			case 12:
				let _g5 = token.tok;
				if(_g5._hx_index == 1) {
					switch(_g5.k._hx_index) {
					case 15:case 16:
						if(lastIndentingToken != null && lastIndentingToken.pos.min == prevToken.pos.min) {
							continue;
						}
						mustIndent = true;
						break;
					default:
					}
				}
				break;
			case 14:case 16:
				if(token.tok._hx_index == 20) {
					if(this.parsedCode.tokenList.isSameLineBetween(token,prevToken,false)) {
						continue;
					}
					if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
						let firstToken = this.parsedCode.tokenList.getPreviousToken(prevToken);
						while(firstToken != null && !this.parsedCode.tokenList.isNewLineBefore(firstToken.token)) firstToken = this.parsedCode.tokenList.getPreviousToken(firstToken.token);
						let this1 = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.BrOpen);
						if(this1 != null) {
							if(!this.parsedCode.tokenList.isSameLineBetween(prevToken,this1,false)) {
								continue;
							}
						}
						return count + this.calcIndent(firstToken.token);
					}
				}
				break;
			case 18:
				let _g6 = token.tok;
				switch(_g6._hx_index) {
				case 1:
					switch(_g6.k._hx_index) {
					case 0:case 3:case 4:case 5:case 6:case 7:case 10:case 14:case 20:case 21:case 29:case 40:
						if(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken)._hx_index == 2) {
							let brClose = this.parsedCode.tokenList.getCloseToken(prevToken);
							if(brClose != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose) && !this.config.indentObjectLiteral) {
								continue;
							}
						} else {
							continue;
						}
						break;
					default:
					}
					break;
				case 6:
					switch(_g6.op._hx_index) {
					case 4:
						switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken)._hx_index) {
						case 1:
							continue;
						case 2:
							let brClose = this.parsedCode.tokenList.getCloseToken(prevToken);
							if(brClose != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose) && !this.config.indentObjectLiteral) {
								continue;
							}
							break;
						default:
						}
						break;
					case 20:
						switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken)._hx_index) {
						case 1:
							continue;
						case 2:
							let brClose1 = this.parsedCode.tokenList.getCloseToken(prevToken);
							if(brClose1 != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose1) && !this.config.indentObjectLiteral) {
								continue;
							}
							break;
						default:
						}
						break;
					default:
					}
					break;
				case 12:
					switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken)._hx_index) {
					case 1:
						continue;
					case 2:
						let brClose2 = this.parsedCode.tokenList.getCloseToken(prevToken);
						if(brClose2 != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose2) && !this.config.indentObjectLiteral) {
							continue;
						}
						break;
					default:
					}
					break;
				case 14:
					if(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken)._hx_index == 2) {
						let brClose = this.parsedCode.tokenList.getCloseToken(prevToken);
						if(brClose != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose) && !this.config.indentObjectLiteral) {
							continue;
						}
					} else {
						continue;
					}
					break;
				case 16:case 20:
					this.parsedCode.tokenList.isNewLineBefore(prevToken);
					break;
				default:
				}
				break;
			default:
			}
			if(!mustIndent && this.parsedCode.tokenList.isSameLineBetween(token,prevToken,false)) {
				continue;
			}
			skipToToken = this.findSkippingToken(token);
			if(!this.isIndentingToken(token,prevToken)) {
				continue;
			}
			lastIndentingToken = token;
			++count;
		}
		return count;
	}
	findSkippingToken(token) {
		let firstToken = this.parsedCode.tokenList.findLineStartToken(token);
		if(firstToken == null) {
			return null;
		}
		if(firstToken.index == token.index) {
			return null;
		}
		let skipToToken = null;
		switch(firstToken.tok._hx_index) {
		case 17:case 19:case 21:
			skipToToken = this.findSkippingToken(firstToken.parent);
			if(skipToToken == null) {
				skipToToken = firstToken.parent;
			}
			return skipToToken;
		default:
			return null;
		}
	}
	isFieldLevelVar(indentingTokensCandidates) {
		let tokens = indentingTokensCandidates.slice();
		tokens.reverse();
		let _g = 0;
		while(_g < tokens.length) {
			let _g1 = tokens[_g++].tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 0:
					return false;
				case 2:
					return true;
				case 42:
					break;
				default:
				}
				break;
			case 6:
				if(_g1.op._hx_index == 4) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	calcFromCandidates(token) {
		let indentingTokensCandidates = this.findIndentingCandidates(token);
		if(indentingTokensCandidates.length <= 0) {
			return 0;
		}
		let indentComplexValueExpressions = this.config.indentComplexValueExpressions;
		if(this.isFieldLevelVar(indentingTokensCandidates)) {
			indentComplexValueExpressions = true;
		}
		if(indentComplexValueExpressions) {
			indentingTokensCandidates = this.compressElseIfCandidates(indentingTokensCandidates);
		}
		let count = this.countLineBreaks(indentingTokensCandidates,indentComplexValueExpressions);
		if(this.hasConditional(indentingTokensCandidates)) {
			switch(this.config.conditionalPolicy) {
			case "aligned":
				break;
			case "alignedDecrease":
				--count;
				break;
			case "alignedIncrease":
				break;
			case "alignedNestedIncrease":
				count += this.calcConsecutiveConditionalLevel(token);
				break;
			case "fixedZero":
				break;
			case "fixedZeroIncrease":
				--count;
				if(this.calcConditionalLevel(token) == count) {
					++count;
				}
				break;
			case "fixedZeroIncreaseBlocks":
				if(this.hasBlock(indentingTokensCandidates)) {
					--count;
					if(this.calcConditionalLevel(token) == count) {
						++count;
					}
				}
				break;
			}
		}
		return count;
	}
	hasConditional(tokens) {
		let _g = 0;
		while(_g < tokens.length) {
			let _g1 = tokens[_g++].tok;
			if(_g1._hx_index == 3) {
				if(_g1.s == "if") {
					return true;
				}
			}
		}
		return false;
	}
	hasBlock(tokens) {
		let _g = 0;
		while(_g < tokens.length) if(tokens[_g++].tok._hx_index == 18) {
			return true;
		}
		return false;
	}
	hasBlockParent(token) {
		let parent = token.parent;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) if(parent.tok._hx_index == 18) {
			return true;
		} else {
			parent = parent.parent;
		}
		return false;
	}
	findIndentingCandidates(token) {
		let indentingTokensCandidates = [];
		let lastIndentingToken = null;
		if(token.tok._hx_index == 11) {
			lastIndentingToken = token;
		}
		indentingTokensCandidates.push(token);
		let parent = token;
		while(parent.parent != null && parent.parent.tok != tokentree_TokenTreeDef.Root) {
			parent = parent.parent;
			if(parent.pos.min > token.pos.min) {
				continue;
			}
			if(this.isIndentingToken(parent,parent)) {
				if(lastIndentingToken != null) {
					if(lastIndentingToken.tok._hx_index == 11 && parent.tok._hx_index == 11) {
						continue;
					}
				}
				indentingTokensCandidates.push(parent);
				lastIndentingToken = parent;
			} else if(this.parsedCode.tokenList.isNewLineBefore(parent)) {
				indentingTokensCandidates.push(parent);
				lastIndentingToken = parent;
			}
		}
		return indentingTokensCandidates;
	}
	compressElseIfCandidates(indentingTokensCandidates) {
		let compressedCandidates = [];
		let state = formatter_marker_IndentationCompressElseIf.Copy;
		let _g = 0;
		while(_g < indentingTokensCandidates.length) {
			let token = indentingTokensCandidates[_g];
			++_g;
			let _g1 = token.tok;
			if(_g1._hx_index == 1) {
				switch(_g1.k._hx_index) {
				case 3:
					switch(state._hx_index) {
					case 0:
						if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse)) != null) {
							state = formatter_marker_IndentationCompressElseIf.SkipElseIf;
						}
						break;
					case 1:
						state = formatter_marker_IndentationCompressElseIf.SkipElseIf;
						break;
					case 2:
						continue;
					}
					break;
				case 4:
					if(state == formatter_marker_IndentationCompressElseIf.SeenElse || state == formatter_marker_IndentationCompressElseIf.SkipElseIf) {
						state = formatter_marker_IndentationCompressElseIf.SkipElseIf;
						continue;
					}
					state = formatter_marker_IndentationCompressElseIf.SeenElse;
					break;
				default:
					state = formatter_marker_IndentationCompressElseIf.Copy;
				}
			} else {
				state = formatter_marker_IndentationCompressElseIf.Copy;
			}
			compressedCandidates.push(token);
		}
		return compressedCandidates;
	}
	isIndentingToken(token,prevToken) {
		if(token == null) {
			return false;
		}
		let _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return true;
			case 2:
				return true;
			case 3:case 4:
				return true;
			case 5:
				let parent = token.parent;
				let tmp;
				if(parent != null) {
					let _g = parent.tok;
					tmp = _g._hx_index == 1 && _g.k._hx_index == 6;
				} else {
					tmp = false;
				}
				if(tmp) {
					return false;
				}
				return true;
			case 6:case 7:
				return true;
			case 14:case 15:case 16:
				return true;
			case 22:
				let _g1 = token.parent.tok;
				if(_g1._hx_index == 1) {
					if(_g1.k._hx_index == 0) {
						return false;
					} else {
						return true;
					}
				} else {
					return true;
				}
				break;
			case 20:case 21:case 24:
				return true;
			case 10:case 29:
				return true;
			case 40:
				return true;
			default:
			}
			break;
		case 2:
			let _gc = _g.c;
			if(_gc._hx_index == 3) {
				switch(_gc.s) {
				case "from":case "to":
					return this.isAbstractFromTo(token);
				default:
					if(prevToken.tok._hx_index == 11) {
						return true;
					}
				}
			}
			break;
		case 3:
			if(_g.s == "if") {
				switch(this.config.conditionalPolicy) {
				case "aligned":
					return false;
				case "alignedDecrease":case "alignedIncrease":
					return true;
				case "alignedNestedIncrease":
					return false;
				case "fixedZero":
					return false;
				case "fixedZeroIncrease":
					return true;
				case "fixedZeroIncreaseBlocks":
					return this.hasBlockParent(token);
				}
			}
			break;
		case 6:
			switch(_g.op._hx_index) {
			case 4:
				return true;
			case 9:
				return tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token);
			case 20:
				return true;
			default:
			}
			break;
		case 11:case 16:case 18:case 20:
			return true;
		case 12:
			let tmp1;
			let _g2 = token.parent.tok;
			if(!(_g2._hx_index == 1 && _g2.k._hx_index == 15)) {
				let _g = token.parent.tok;
				tmp1 = _g._hx_index == 1 && _g.k._hx_index == 16;
			} else {
				tmp1 = true;
			}
			if(tmp1) {
				return true;
			}
			let info = this.parsedCode.tokenList.getTokenAt(token.index);
			if(info == null) {
				return false;
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:case 1:
				return false;
			case 2:
				return true;
			}
			break;
		case 14:
			return true;
		default:
		}
		return false;
	}
	isAbstractFromTo(token) {
		let parent = token.parent;
		if(parent == null) {
			return false;
		}
		let _g = parent.tok;
		if(_g._hx_index == 2) {
			if(_g.c._hx_index != 3) {
				return false;
			}
		} else {
			return false;
		}
		parent = parent.parent;
		if(parent == null) {
			return false;
		}
		let _g1 = parent.tok;
		if(_g1._hx_index == 1) {
			if(_g1.k._hx_index == 40) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
}
formatter_marker_Indenter.__name__ = "formatter.marker.Indenter";
Object.assign(formatter_marker_Indenter.prototype, {
	__class__: formatter_marker_Indenter
});
var formatter_marker_IndentationCompressElseIf = $hxEnums["formatter.marker.IndentationCompressElseIf"] = { __ename__:true,__constructs__:null
	,Copy: {_hx_name:"Copy",_hx_index:0,__enum__:"formatter.marker.IndentationCompressElseIf",toString:$estr}
	,SeenElse: {_hx_name:"SeenElse",_hx_index:1,__enum__:"formatter.marker.IndentationCompressElseIf",toString:$estr}
	,SkipElseIf: {_hx_name:"SkipElseIf",_hx_index:2,__enum__:"formatter.marker.IndentationCompressElseIf",toString:$estr}
};
formatter_marker_IndentationCompressElseIf.__constructs__ = [formatter_marker_IndentationCompressElseIf.Copy,formatter_marker_IndentationCompressElseIf.SeenElse,formatter_marker_IndentationCompressElseIf.SkipElseIf];
class formatter_marker_MarkerBase {
	constructor(config,parsedCode,indenter) {
		this.config = config;
		this.parsedCode = parsedCode;
		this.indenter = indenter;
	}
	getCloseToken(token) {
		return this.parsedCode.tokenList.getCloseToken(token);
	}
	getNextToken(token) {
		return this.parsedCode.tokenList.getNextToken(token);
	}
	getPreviousToken(token) {
		return this.parsedCode.tokenList.getPreviousToken(token);
	}
	getTokenAt(index) {
		return this.parsedCode.tokenList.getTokenAt(index);
	}
	whitespace(token,where) {
		this.parsedCode.tokenList.whitespace(token,where);
	}
	spacesBefore(token,count) {
		this.parsedCode.tokenList.spacesBefore(token,count);
	}
	lineEndAfter(token) {
		this.parsedCode.tokenList.lineEndAfter(token);
	}
	lineEndBefore(token) {
		this.parsedCode.tokenList.lineEndBefore(token);
	}
	noLineEndAfter(token) {
		this.parsedCode.tokenList.noLineEndAfter(token);
	}
	noLineEndBefore(token) {
		this.parsedCode.tokenList.noLineEndBefore(token);
	}
	emptyLinesAfter(token,count) {
		this.parsedCode.tokenList.emptyLinesAfter(token,count);
	}
	emptyLinesBefore(token,count) {
		this.parsedCode.tokenList.emptyLinesBefore(token,count);
	}
	emptyLinesAfterSubTree(token,count) {
		this.parsedCode.tokenList.emptyLinesAfterSubTree(token,count);
	}
	tokenText(token,text) {
		this.parsedCode.tokenList.tokenText(token,text);
	}
	wrapAfter(token,wrap) {
		this.parsedCode.tokenList.wrapAfter(token,wrap);
	}
	wrapBefore(token,wrap) {
		this.parsedCode.tokenList.wrapBefore(token,wrap);
	}
	noWrappingBetween(tokenStart,tokenEnd,allowCommas) {
		if(allowCommas == null) {
			allowCommas = true;
		}
		this.parsedCode.tokenList.noWrappingBetween(tokenStart,tokenEnd,this.config,allowCommas);
	}
	additionalIndent(token,indent) {
		this.parsedCode.tokenList.additionalIndent(token,indent);
	}
	increaseIndentBetween(start,end,depth) {
		this.parsedCode.tokenList.increaseIndentBetween(start,end,depth);
	}
	findTokenAtOffset(offset) {
		return this.parsedCode.tokenList.findTokenAtOffset(offset);
	}
	isSameLine(first,second) {
		return this.parsedCode.tokenList.isSameLine(first,second);
	}
	calcLength(token) {
		return this.parsedCode.tokenList.calcLength(token);
	}
	isMultilineToken(token) {
		return this.parsedCode.tokenList.isMultilineToken(token);
	}
	calcLengthUntilNewline(token,stop) {
		return this.parsedCode.tokenList.calcLengthUntilNewline(token,stop);
	}
	calcLengthBetween(tokenStart,tokenEnd) {
		return this.parsedCode.tokenList.calcLengthBetween(tokenStart,tokenEnd);
	}
	calcLineLength(token) {
		return this.parsedCode.tokenList.calcLineLength(token);
	}
	calcLineLengthBefore(token) {
		return this.parsedCode.tokenList.calcLineLengthBefore(token);
	}
	calcLineLengthAfter(token) {
		return this.parsedCode.tokenList.calcLineLengthAfter(token);
	}
	calcTokenLength(token) {
		return this.parsedCode.tokenList.calcTokenLength(token);
	}
	isNewLineBefore(token) {
		return this.parsedCode.tokenList.isNewLineBefore(token);
	}
	isNewLineAfter(token) {
		return this.parsedCode.tokenList.isNewLineAfter(token);
	}
	isSameLineBetween(tokenStart,tokenEnd,exclude) {
		return this.parsedCode.tokenList.isSameLineBetween(tokenStart,tokenEnd,exclude);
	}
	findLineStartToken(token) {
		return this.parsedCode.tokenList.findLineStartToken(token);
	}
}
formatter_marker_MarkerBase.__name__ = "formatter.marker.MarkerBase";
Object.assign(formatter_marker_MarkerBase.prototype, {
	__class__: formatter_marker_MarkerBase
});
class formatter_marker_MarkAdditionalIndentation extends formatter_marker_MarkerBase {
	constructor(config,parsedCode,indenter) {
		super(config,parsedCode,indenter);
	}
	run() {
		let _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "if") {
					_gthis.markBlockBreakingConditional(token,_gthis.calcDepthDifferenceLeftCurly(token));
					_gthis.markBlockBreakingConditional(token,_gthis.calcDepthDifferenceRightCurly(token));
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	markBlockBreakingConditional(token,depthDifference) {
		if(token.children == null) {
			return;
		}
		let this1 = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Sharp("end"));
		let start = this1;
		if(this1 == null) {
			return;
		}
		if(depthDifference == 0) {
			return;
		}
		if(depthDifference < 0) {
			start = token;
		}
		let parent = token.parent;
		let topLevelToken = null;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			topLevelToken = parent;
			parent = parent.parent;
		}
		if(topLevelToken == null) {
			return;
		}
		let sibling = topLevelToken.nextSibling;
		while(sibling != null) if(sibling.tok._hx_index == 19) {
			this.increaseIndentBetween(start,sibling,depthDifference);
			return;
		} else {
			sibling = sibling.nextSibling;
		}
		this.increaseIndentBetween(start,tokentree_utils_TokenTreeCheckUtils.getLastToken(topLevelToken),depthDifference);
	}
	calcDepthDifferenceLeftCurly(token) {
		if(token.children == null) {
			return 0;
		}
		let depthIncrease = 0;
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let brOpens = _g1[_g++].filterCallback(function(token,index) {
				switch(token.tok._hx_index) {
				case 3:
					return tokentree_FilterResult.SkipSubtree;
				case 18:
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			});
			if(brOpens.length <= 0) {
				continue;
			}
			let depth = 0;
			let _g2 = 0;
			while(_g2 < brOpens.length) {
				if(tokentree_TokenTreeAccessHelper.firstOf(brOpens[_g2++],tokentree_TokenTreeDef.BrClose) != null) {
					continue;
				}
				++depth;
			}
			if(depth > depthIncrease) {
				depthIncrease = depth;
			}
		}
		return depthIncrease;
	}
	calcDepthDifferenceRightCurly(token) {
		if(token.children == null) {
			return 0;
		}
		let depthDecrease = 0;
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let brClose = _g1[_g++].filterCallback(function(token,index) {
				if(token.tok._hx_index == 19) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			if(brClose.length <= 0) {
				continue;
			}
			let depth = 0;
			let _g2 = 0;
			while(_g2 < brClose.length) {
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(brClose[_g2++]),tokentree_TokenTreeDef.BrOpen) != null) {
					continue;
				}
				++depth;
			}
			if(depth > depthDecrease) {
				depthDecrease = depth;
			}
		}
		return -depthDecrease;
	}
}
formatter_marker_MarkAdditionalIndentation.__name__ = "formatter.marker.MarkAdditionalIndentation";
formatter_marker_MarkAdditionalIndentation.__super__ = formatter_marker_MarkerBase;
Object.assign(formatter_marker_MarkAdditionalIndentation.prototype, {
	__class__: formatter_marker_MarkAdditionalIndentation
});
class formatter_marker_MarkEmptyLines extends formatter_marker_MarkerBase {
	constructor(config,parsedCode,indenter) {
		super(config,parsedCode,indenter);
	}
	run() {
		this.keepExistingEmptyLines();
		let packs = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 34) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		packs.reverse();
		let _g = 0;
		while(_g < packs.length) {
			let pack = packs[_g];
			++_g;
			if(tokentree_utils_TokenTreeCheckUtils.isMetadata(pack)) {
				continue;
			}
			this.emptyLinesBefore(pack,this.config.emptyLines.beforePackage);
			this.emptyLinesAfter(pack,this.config.emptyLines.afterPackage);
		}
		this.betweenTypes();
		this.markImports();
		this.markClassesAndAbstracts();
		this.markMacroClasses();
		this.markInterfaces();
		this.markEnums();
		this.markTypedefs();
		this.markSharp();
		if(this.config.emptyLines.beforeDocCommentEmptyLines != "ignore" || this.config.emptyLines.afterFieldsWithDocComments != "ignore") {
			this.markDocComments();
		}
		this.markMultilineComments();
		this.markFileHeader();
		if(this.config.emptyLines.beforeRightCurly == "remove") {
			this.markRightCurly();
		}
		if(this.config.emptyLines.afterLeftCurly == "remove") {
			this.markLeftCurly();
		}
		if(this.config.emptyLines.afterReturn == "remove") {
			this.markReturn();
		}
		if(this.config.emptyLines.beforeBlocks == "remove" || this.config.emptyLines.afterBlocks == "remove") {
			this.markAroundBlocks();
		}
	}
	finalRun(codeLines) {
		if(codeLines.lines.length <= 0) {
			return;
		}
		let _g = 0;
		let _g1 = codeLines.lines;
		while(_g < _g1.length) {
			let line = _g1[_g];
			++_g;
			if(line.verbatim) {
				continue;
			}
			if(line.emptyLinesAfter > this.config.emptyLines.maxAnywhereInFile) {
				line.emptyLinesAfter = this.config.emptyLines.maxAnywhereInFile;
			}
		}
		let lastLine = codeLines.lines[codeLines.lines.length - 1];
		if(lastLine.verbatim) {
			return;
		}
		lastLine.emptyLinesAfter = this.config.emptyLines.finalNewline ? 1 : 0;
	}
	markImports() {
		let imports = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 13:case 36:
					if(tokentree_utils_TokenTreeCheckUtils.isMetadata(token)) {
						return tokentree_FilterResult.SkipSubtree;
					} else {
						return tokentree_FilterResult.FoundSkipSubtree;
					}
					break;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(imports.length <= 0) {
			return;
		}
		let lastImport = imports[imports.length - 1];
		let afterImport = this.getNextToken(tokentree_utils_TokenTreeCheckUtils.getLastToken(lastImport));
		if(afterImport != null) {
			let _g = afterImport.token.tok;
			if(_g._hx_index == 3) {
				switch(_g.s) {
				case "else":case "elseif":
					break;
				case "end":
					this.emptyLinesAfterSubTree(afterImport.token,this.config.emptyLines.importAndUsing.beforeType);
					break;
				default:
					this.emptyLinesAfterSubTree(lastImport,this.config.emptyLines.importAndUsing.beforeType);
				}
			} else {
				this.emptyLinesAfterSubTree(lastImport,this.config.emptyLines.importAndUsing.beforeType);
			}
		}
		let prevInfo = null;
		let _g = 0;
		while(_g < imports.length) {
			let token = imports[_g];
			++_g;
			let newInfo = this.getImportInfo(token);
			let next = this.getNextToken(tokentree_utils_TokenTreeCheckUtils.getLastToken(token));
			if(next != null) {
				let _g = next.token.tok;
				if(_g._hx_index == 3) {
					if(_g.s == "end") {
						newInfo.token = next.token;
					}
				}
			}
			if(prevInfo == null) {
				prevInfo = newInfo;
				continue;
			}
			if(prevInfo.isImport == newInfo.isImport) {
				switch(this.config.emptyLines.importAndUsing.betweenImportsLevel) {
				case "all":
					this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					break;
				case "fifthLevelPackage":
					if(prevInfo.fifthLevelPackage != newInfo.fifthLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "firstLevelPackage":
					if(prevInfo.firstLevelPackage != newInfo.firstLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "fourthLevelPackage":
					if(prevInfo.fourthLevelPackage != newInfo.fourthLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "fullPackage":
					if(prevInfo.fullPackage != newInfo.fullPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "secondLevelPackage":
					if(prevInfo.secondLevelPackage != newInfo.secondLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "thirdLevelPackage":
					if(prevInfo.thirdLevelPackage != newInfo.thirdLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				}
			} else {
				this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.beforeUsing);
			}
			prevInfo = newInfo;
		}
	}
	getImportInfo(token) {
		let info = { token : token, isImport : false, firstLevelPackage : "", secondLevelPackage : "", thirdLevelPackage : "", fourthLevelPackage : "", fifthLevelPackage : "", fullPackage : "", moduleName : ""};
		let _g = token.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 13:
				info.isImport = true;
				break;
			case 36:
				info.isImport = false;
				break;
			default:
			}
		}
		let parts = [];
		token = token.getFirstChild();
		do {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				parts.push("" + Std.string(token));
				break;
			case 2:
				let _gc = _g.c;
				if(_gc._hx_index == 3) {
					parts.push(_gc.s);
				}
				break;
			default:
			}
			token = token.getFirstChild();
			if(token == null || token.tok._hx_index != 11) {
				break;
			}
			token = token.getFirstChild();
		} while(token != null);
		info.moduleName = parts.pop();
		info.fullPackage = parts.join(".");
		if(parts.length > 0) {
			info.firstLevelPackage = parts[0];
		}
		if(parts.length > 1) {
			info.secondLevelPackage = parts.slice(0,2).join(".");
		} else {
			info.secondLevelPackage = info.firstLevelPackage;
		}
		if(parts.length > 2) {
			info.thirdLevelPackage = parts.slice(0,3).join(".");
		} else {
			info.thirdLevelPackage = info.secondLevelPackage;
		}
		if(parts.length > 3) {
			info.fourthLevelPackage = parts.slice(0,4).join(".");
		} else {
			info.fourthLevelPackage = info.thirdLevelPackage;
		}
		if(parts.length > 4) {
			info.fifthLevelPackage = parts.slice(0,5).join(".");
		} else {
			info.fifthLevelPackage = info.fourthLevelPackage;
		}
		return info;
	}
	markClassesAndAbstracts() {
		let classes = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 1:case 40:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < classes.length) {
			let c = classes[_g];
			++_g;
			if(tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract(c)) {
				this.markEnumAbstracts(c);
				continue;
			}
			let typeConfig = null;
			let _g1 = c.tok;
			if(_g1._hx_index == 1) {
				switch(_g1.k._hx_index) {
				case 1:
					typeConfig = this.config.emptyLines.classEmptyLines;
					if(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(c),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdExtern)) != null) {
						this.markExternClass(c,this.config.emptyLines.externClassEmptyLines);
						continue;
					}
					break;
				case 40:
					typeConfig = this.config.emptyLines.abstractEmptyLines;
					break;
				default:
					continue;
				}
			} else {
				continue;
			}
			this.markBeginAndEndType(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(c),tokentree_TokenTreeDef.BrOpen),typeConfig.beginType,typeConfig.endType);
			let fields = this.findClassAndAbstractFields(c);
			let prevToken = null;
			let prevTokenType = null;
			let currTokenType = null;
			let _g2 = 0;
			while(_g2 < fields.length) {
				let field = fields[_g2];
				++_g2;
				currTokenType = tokentree_utils_FieldUtils.getFieldType(field,tokentree_utils_TokenFieldVisibility.Private);
				this.markClassFieldEmptyLines(prevToken,prevTokenType,field,currTokenType,typeConfig);
				prevToken = field;
				prevTokenType = currTokenType;
			}
		}
	}
	markMacroClasses() {
		let classes = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 1) {
					if(token.parent == null || token.parent.tok == tokentree_TokenTreeDef.Root) {
						return tokentree_FilterResult.GoDeeper;
					}
					let _g = token.parent.tok;
					if(_g._hx_index == 1) {
						if(_g.k._hx_index == 41) {
							return tokentree_FilterResult.FoundSkipSubtree;
						} else {
							return tokentree_FilterResult.GoDeeper;
						}
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < classes.length) {
			let c = classes[_g];
			++_g;
			let typeConfig = this.config.emptyLines.macroClassEmptyLines;
			this.markBeginAndEndType(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(c),tokentree_TokenTreeDef.BrOpen),typeConfig.beginType,typeConfig.endType);
			let functions = this.findClassAndAbstractFields(c);
			let prevToken = null;
			let prevTokenType = null;
			let currTokenType = null;
			let _g1 = 0;
			while(_g1 < functions.length) {
				let func = functions[_g1];
				++_g1;
				currTokenType = tokentree_utils_FieldUtils.getFieldType(func,tokentree_utils_TokenFieldVisibility.Private);
				this.markClassFieldEmptyLines(prevToken,prevTokenType,func,currTokenType,typeConfig);
				prevToken = func;
				prevTokenType = currTokenType;
			}
		}
	}
	findClassAndAbstractFields(c) {
		return c.filterCallback(function(token,index) {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 2:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 42:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			case 23:
				return tokentree_FilterResult.SkipSubtree;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
	}
	markBeginAndEndType(brOpen,beginType,endType) {
		if(brOpen == null) {
			return;
		}
		this.emptyLinesAfter(brOpen,beginType);
		let brClose = this.getCloseToken(brOpen);
		if(brClose == null) {
			return;
		}
		this.emptyLinesBefore(brClose,endType);
	}
	markClassFieldEmptyLines(prevToken,prevTokenType,currToken,currTokenType,conf) {
		if(prevToken == null) {
			return;
		}
		let prevVar = false;
		let currVar = false;
		let prevStatic = false;
		let currStatic = false;
		let prevPrivate = false;
		let currPrivate = false;
		switch(prevTokenType._hx_index) {
		case 0:
			prevVar = false;
			prevStatic = prevTokenType.isStatic;
			prevPrivate = prevTokenType.visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 1:
			prevVar = true;
			prevStatic = prevTokenType.isStatic;
			prevPrivate = prevTokenType.visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 2:
			prevVar = true;
			prevStatic = prevTokenType.isStatic;
			prevPrivate = prevTokenType.visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 3:
			return;
		}
		switch(currTokenType._hx_index) {
		case 0:
			currVar = false;
			currStatic = currTokenType.isStatic;
			currPrivate = currTokenType.visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 1:
			currVar = true;
			currStatic = currTokenType.isStatic;
			currPrivate = currTokenType.visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 2:
			currVar = true;
			currStatic = currTokenType.isStatic;
			currPrivate = currTokenType.visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 3:
			return;
		}
		if(!currVar) {
			this.markLineCommentsBefore(currToken,this.config.emptyLines.lineCommentsBetweenFunctions);
			this.markLineCommentsAfter(currToken,1);
		}
		prevToken = this.skipSharpFields(prevToken);
		if(prevToken == null) {
			return;
		}
		if(conf.existingBetweenFields == "keep") {
			if(this.hasEmptyLinesBetweenFields(prevToken,currToken)) {
				this.emptyLinesAfterSubTree(prevToken,1);
				return;
			}
		}
		if(prevVar != currVar) {
			this.emptyLinesAfterSubTree(prevToken,conf.afterVars);
			return;
		}
		if(prevVar) {
			if(prevStatic != currStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterStaticVars);
				return;
			}
			if(prevStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.betweenStaticVars);
				return;
			}
			if(prevPrivate != currPrivate) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterPrivateVars);
				return;
			}
			this.emptyLinesAfterSubTree(prevToken,conf.betweenVars);
			return;
		} else {
			if(prevStatic != currStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterStaticFunctions);
				return;
			}
			if(prevStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.betweenStaticFunctions);
				return;
			}
			if(prevPrivate != currPrivate) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterPrivateFunctions);
				return;
			}
			this.emptyLinesAfterSubTree(prevToken,conf.betweenFunctions);
			return;
		}
	}
	hasEmptyLinesBetweenFields(prevToken,currToken) {
		let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(prevToken);
		if(lastToken == null) {
			return false;
		}
		let prevLine = this.parsedCode.getLinePos(lastToken.pos.max).line;
		let currLine = this.parsedCode.getLinePos(currToken.pos.min).line;
		let _g = 0;
		let _g1 = this.parsedCode.emptyLines;
		while(_g < _g1.length) {
			let emptyLine = _g1[_g];
			++_g;
			if(prevLine >= emptyLine) {
				continue;
			}
			if(currLine > emptyLine) {
				return true;
			}
			return false;
		}
		return false;
	}
	markLineCommentsBefore(token,policy) {
		if(policy == "none") {
			return;
		}
		if(token.previousSibling == null) {
			return;
		}
		let prev = token.previousSibling;
		while(prev != null) {
			switch(prev.tok._hx_index) {
			case 7:
				break;
			case 8:
				let prevInfo = this.getPreviousToken(prev);
				if(prevInfo == null || prevInfo.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
					switch(policy) {
					case "keep":
						if(this.parsedCode.linesBetweenOriginal(prev,token) > 1) {
							this.emptyLinesAfter(prev,1);
						}
						break;
					case "none":
						break;
					case "one":
						this.emptyLinesAfter(prev,1);
						break;
					}
				}
				return;
			default:
				return;
			}
			prev = prev.previousSibling;
		}
	}
	markLineCommentsAfter(token,count) {
		if(count <= 0) {
			return;
		}
		if(token.nextSibling == null) {
			return;
		}
		let next = token.nextSibling;
		if(next.tok._hx_index == 8) {
			if(this.isNewLineBefore(next)) {
				this.emptyLinesBefore(next,count);
			}
		}
	}
	markExternClass(c,conf) {
		let this1 = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(c),tokentree_TokenTreeDef.BrOpen);
		if(this1 == null) {
			return;
		}
		this.markBeginAndEndType(this1,conf.beginType,conf.endType);
		let fields = this.findClassAndAbstractFields(this1);
		let prevToken = null;
		let prevTokenType = null;
		let currTokenType = null;
		let _g = 0;
		while(_g < fields.length) {
			let field = fields[_g];
			++_g;
			currTokenType = tokentree_utils_FieldUtils.getFieldType(field,tokentree_utils_TokenFieldVisibility.Public);
			this.markInterfaceEmptyLines(prevToken,prevTokenType,field,currTokenType,conf);
			prevToken = field;
			prevTokenType = currTokenType;
		}
	}
	markInterfaces() {
		let interfaces = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 28) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < interfaces.length) this.markExternClass(interfaces[_g++],this.config.emptyLines.interfaceEmptyLines);
	}
	markInterfaceEmptyLines(prevToken,prevTokenType,currToken,currTokenType,conf) {
		if(prevToken == null) {
			return;
		}
		let prevVar = false;
		let currVar = false;
		switch(prevTokenType._hx_index) {
		case 0:
			prevVar = false;
			break;
		case 1:
			prevVar = true;
			break;
		case 2:
			prevVar = true;
			break;
		case 3:
			return;
		}
		switch(currTokenType._hx_index) {
		case 0:
			currVar = false;
			break;
		case 1:
			currVar = true;
			break;
		case 2:
			currVar = true;
			break;
		case 3:
			return;
		}
		prevToken = this.skipSharpFields(prevToken);
		if(prevToken == null) {
			return;
		}
		if(conf.existingBetweenFields == "keep") {
			if(this.hasEmptyLinesBetweenFields(prevToken,currToken)) {
				this.emptyLinesAfterSubTree(prevToken,1);
				return;
			}
		}
		if(prevVar != currVar) {
			this.emptyLinesAfterSubTree(prevToken,conf.afterVars);
			return;
		}
		if(prevVar) {
			this.emptyLinesAfterSubTree(prevToken,conf.betweenVars);
			return;
		} else {
			this.emptyLinesAfterSubTree(prevToken,conf.betweenFunctions);
			return;
		}
	}
	markEnumAbstracts(token) {
		this.markBeginAndEndType(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.BrOpen),this.config.emptyLines.enumAbstractEmptyLines.beginType,this.config.emptyLines.enumAbstractEmptyLines.endType);
		let functions = this.findClassAndAbstractFields(token);
		let prevToken = null;
		let prevTokenType = null;
		let currTokenType = null;
		let _g = 0;
		while(_g < functions.length) {
			let func = functions[_g];
			++_g;
			currTokenType = tokentree_utils_FieldUtils.getFieldType(func,tokentree_utils_TokenFieldVisibility.Public);
			this.markEnumAbstractFieldEmptyLines(prevToken,prevTokenType,func,currTokenType);
			prevToken = func;
			prevTokenType = currTokenType;
		}
	}
	markEnumAbstractFieldEmptyLines(prevToken,prevTokenType,currToken,currTokenType) {
		if(prevToken == null) {
			return;
		}
		let prevVar = false;
		let currVar = false;
		switch(prevTokenType._hx_index) {
		case 0:
			prevVar = false;
			break;
		case 1:
			prevVar = true;
			break;
		case 2:
			prevVar = true;
			break;
		case 3:
			return;
		}
		switch(currTokenType._hx_index) {
		case 0:
			currVar = false;
			break;
		case 1:
			currVar = true;
			break;
		case 2:
			currVar = true;
			break;
		case 3:
			return;
		}
		prevToken = this.skipSharpFields(prevToken);
		if(prevToken == null) {
			return;
		}
		if(prevVar != currVar) {
			this.emptyLinesAfterSubTree(prevToken,this.config.emptyLines.enumAbstractEmptyLines.afterVars);
			return;
		}
		if(prevVar) {
			this.emptyLinesAfterSubTree(prevToken,this.config.emptyLines.enumAbstractEmptyLines.betweenVars);
			return;
		} else {
			this.emptyLinesAfterSubTree(prevToken,this.config.emptyLines.enumAbstractEmptyLines.betweenFunctions);
			return;
		}
	}
	markEnums() {
		let enums = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 26) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < enums.length) {
			let e = enums[_g];
			++_g;
			if(e.parent.tok != tokentree_TokenTreeDef.Root) {
				switch(e.parent.tok._hx_index) {
				case 2:
					continue;
				case 12:case 23:
					continue;
				default:
				}
			}
			let this1 = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(e),tokentree_TokenTreeDef.BrOpen);
			if(this1 == null) {
				continue;
			}
			this.markEnumFields(this1,this.config.emptyLines.enumEmptyLines);
		}
	}
	markEnumFields(block,config) {
		this.markBeginAndEndType(block,config.beginType,config.endType);
		if(block.children == null || block.children.length <= 0) {
			return;
		}
		let prevToken = null;
		let _g = 0;
		let _g1 = block.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			switch(child.tok._hx_index) {
			case 7:
				continue;
			case 8:
				continue;
			case 19:
				return;
			default:
			}
			if(prevToken == null) {
				prevToken = child;
				continue;
			}
			if(config.existingBetweenFields == "keep") {
				if(this.hasEmptyLinesBetweenFields(prevToken,child)) {
					this.emptyLinesAfterSubTree(prevToken,1);
					return;
				}
			}
			this.emptyLinesAfterSubTree(prevToken,config.betweenFields);
			prevToken = child;
		}
	}
	markTypedefs() {
		let typedefs = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 32) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < typedefs.length) {
			let this1 = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(typedefs[_g++]),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign)),tokentree_TokenTreeDef.BrOpen);
			if(this1 == null) {
				continue;
			}
			this.markEnumFields(this1,this.config.emptyLines.typedefEmptyLines);
		}
	}
	skipSharpFields(prevToken) {
		let next = prevToken.nextSibling;
		if(next == null) {
			next = prevToken.parent;
			if(next.tok._hx_index == 3) {
				next = next.nextSibling;
			} else {
				return prevToken;
			}
		}
		let _g = next.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "end":
				return next;
			case "if":
				return prevToken;
			default:
				return null;
			}
		}
		return prevToken;
	}
	betweenTypes() {
		if(this.config.emptyLines.betweenTypes <= 0 && this.config.emptyLines.betweenSingleLineTypes <= 0) {
			return;
		}
		let types = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:case 2:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 1:case 26:case 28:case 32:case 40:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 42:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(types.length <= 1) {
			return;
		}
		let prevTypeInfo = null;
		let _g = 0;
		while(_g < types.length) {
			let type = types[_g];
			++_g;
			let newTypeInfo = this.getTypeInfo(type);
			this.markLineCommentsBefore(type,this.config.emptyLines.lineCommentsBetweenTypes);
			this.markLineCommentsAfter(type,1);
			if(prevTypeInfo == null) {
				prevTypeInfo = newTypeInfo;
				continue;
			}
			let next = this.getNextToken(prevTypeInfo.lastToken);
			if(next != null) {
				let _g = next.token.tok;
				if(_g._hx_index == 3) {
					switch(_g.s) {
					case "else":case "elseif":
						prevTypeInfo = newTypeInfo;
						continue;
					default:
					}
				}
			}
			let emptyLines = this.config.emptyLines.betweenTypes;
			if(prevTypeInfo.oneLine && newTypeInfo.oneLine) {
				emptyLines = this.config.emptyLines.betweenSingleLineTypes;
			}
			this.emptyLinesAfterSubTree(prevTypeInfo.lastToken,emptyLines);
			this.markLineCommentsAfter(prevTypeInfo.typeToken,1);
			prevTypeInfo = newTypeInfo;
		}
	}
	getTypeInfo(token) {
		let info = { lastToken : tokentree_utils_TokenTreeCheckUtils.getLastToken(token), typeToken : token, oneLine : false};
		if(this.isSameLine(this.parsedCode.tokenList.findLowestIndex(token),info.lastToken)) {
			info.oneLine = true;
		}
		while(true) {
			let next = this.getNextToken(info.lastToken);
			if(next == null) {
				break;
			}
			let _g = next.token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "end") {
					info.lastToken = next.token;
				} else {
					break;
				}
			} else {
				break;
			}
		}
		return info;
	}
	markLeftCurly() {
		let brOpens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 18) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < brOpens.length) this.emptyLinesAfter(brOpens[_g++],0);
	}
	markRightCurly() {
		let brCloses = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 19) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < brCloses.length) this.emptyLinesBefore(brCloses[_g++],0);
	}
	markReturn() {
		let returns = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 10) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < returns.length) {
			let ret = returns[_g];
			++_g;
			if(this.isReturnBody(ret)) {
				continue;
			}
			let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(ret);
			if(lastChild == null) {
				continue;
			}
			let next = this.getNextToken(lastChild);
			if(next == null) {
				continue;
			}
			if(next.token.tok._hx_index == 19) {
				this.emptyLinesAfterSubTree(ret,0);
			}
		}
	}
	isReturnBody(ret) {
		let parent = ret.parent;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				if(_g.k._hx_index == 0) {
					return true;
				} else {
					parent = parent.parent;
				}
				break;
			case 18:
				return false;
			default:
				parent = parent.parent;
			}
		}
		return true;
	}
	markSharp() {
		let sharps = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 3) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < sharps.length) {
			let sharp = sharps[_g];
			++_g;
			let prev = this.getPreviousToken(sharp);
			if(prev != null && prev.whitespaceAfter != formatter_codedata_WhitespaceAfterType.Newline) {
				continue;
			}
			let _g1 = sharp.tok;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "else":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeElse);
					this.emptyLinesAfter(sharp,this.config.emptyLines.conditionalsEmptyLines.afterElse);
					break;
				case "elseif":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeElse);
					this.emptyLinesAfterSubTree(sharp.getFirstChild(),this.config.emptyLines.conditionalsEmptyLines.afterIf);
					break;
				case "end":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeEnd);
					break;
				case "error":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeError);
					this.emptyLinesAfterSubTree(sharp,this.config.emptyLines.conditionalsEmptyLines.afterError);
					break;
				case "if":
					this.emptyLinesAfterSubTree(sharp.getFirstChild(),this.config.emptyLines.conditionalsEmptyLines.afterIf);
					break;
				default:
				}
			}
		}
	}
	markDocComments() {
		let comments = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 7) {
				if(_g.s.startsWith("*")) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < comments.length) {
			let comment = comments[_g];
			++_g;
			let effectiveToken = null;
			effectiveToken = comment;
			if(comment.previousSibling != null) {
				if(comment.parent != null) {
					if(comment.parent.tok._hx_index == 3) {
						if(comment.parent.getFirstChild() == comment.previousSibling) {
							effectiveToken = comment.parent;
						}
					}
				}
			} else if(comment.parent == null || comment.parent.tok == tokentree_TokenTreeDef.Root) {
				continue;
			}
			if(comment.nextSibling == null) {
				continue;
			}
			let next = comment.nextSibling;
			let found = true;
			while(next != null) {
				let _g = next.tok;
				switch(_g._hx_index) {
				case 1:
					switch(_g.k._hx_index) {
					case 0:
						break;
					case 1:
						break;
					case 2:
						break;
					case 26:
						break;
					case 28:
						break;
					case 32:
						break;
					case 40:
						break;
					case 42:
						break;
					default:
						found = false;
					}
					break;
				case 2:
					if(_g.c._hx_index != 3) {
						found = false;
					}
					break;
				case 3:
					next = null;
					break;
				case 8:
					next = next.nextSibling;
					continue;
				default:
					found = false;
				}
				break;
			}
			if(!found) {
				continue;
			}
			switch(this.config.emptyLines.beforeDocCommentEmptyLines) {
			case "ignore":
				break;
			case "none":
				this.emptyLinesBefore(effectiveToken,0);
				break;
			case "one":
				this.emptyLinesBefore(effectiveToken,1);
				break;
			}
			if(next == null) {
				continue;
			}
			let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(next);
			let nextInfo = this.getNextToken(lastToken);
			if(nextInfo == null) {
				continue;
			}
			let _g1 = nextInfo.token.tok;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "end":
					lastToken = nextInfo.token;
					break;
				case "error":
					break;
				case "if":
					break;
				default:
					continue;
				}
			}
			switch(this.config.emptyLines.afterFieldsWithDocComments) {
			case "ignore":
				break;
			case "none":
				this.emptyLinesAfter(lastToken,0);
				break;
			case "one":
				this.emptyLinesAfter(lastToken,1);
				break;
			}
		}
	}
	markMultilineComments() {
		let comments = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 7) {
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < comments.length) {
			let comment = comments[_g];
			++_g;
			let sibling = comment.nextSibling;
			if(sibling == null) {
				continue;
			}
			if(!this.isNewLineAfter(comment)) {
				continue;
			}
			if(sibling.tok._hx_index == 7) {
				this.emptyLinesAfter(comment,this.config.emptyLines.betweenMultilineComments);
			} else {
				continue;
			}
		}
	}
	markAroundBlocks() {
		let _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:
					break;
				case 3:
					if(token.children != null && token.children.length > 0) {
						_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					}
					let this1 = tokentree_TokenTreeAccessHelper.previousSibling(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse)));
					if(this1 != null) {
						_gthis.removeEmptyLinesAroundBlock(this1,"keep",_gthis.config.emptyLines.afterBlocks);
					}
					break;
				case 4:
					_gthis.removeEmptyLinesAroundBlock(token.getFirstChild(),_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				case 5:
					let tmp;
					if(token.children != null && token.children.length > 0) {
						if(token.parent != null) {
							let _g = token.parent.tok;
							tmp = !(_g._hx_index == 1 && _g.k._hx_index == 6);
						} else {
							tmp = true;
						}
					} else {
						tmp = false;
					}
					if(tmp) {
						_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					}
					break;
				case 6:
					_gthis.removeEmptyLinesAroundBlock(token.getFirstChild(),_gthis.config.emptyLines.beforeBlocks,"keep");
					let this2 = tokentree_TokenTreeAccessHelper.previousSibling(tokentree_TokenTreeAccessHelper.lastChild(token));
					_gthis.removeEmptyLinesAroundBlock(this2,"keep",_gthis.config.emptyLines.afterBlocks);
					break;
				case 7:
					if(token.children != null && token.children.length > 0) {
						_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					}
					break;
				case 15:case 16:
					let this3 = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.DblDot));
					_gthis.removeEmptyLinesAroundBlock(this3,_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				case 20:
					_gthis.removeEmptyLinesAroundBlock(token.getFirstChild(),_gthis.config.emptyLines.beforeBlocks,"keep");
					let this4 = tokentree_TokenTreeAccessHelper.previousSibling(tokentree_TokenTreeAccessHelper.lastChild(token));
					_gthis.removeEmptyLinesAroundBlock(this4,"keep",_gthis.config.emptyLines.afterBlocks);
					break;
				case 21:
					if(token.children != null && token.children.length > 0) {
						_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					}
					break;
				default:
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	removeEmptyLinesAroundBlock(block,before,after) {
		if(block == null) {
			return;
		}
		if(before == "remove") {
			let prev = this.getPreviousToken(block);
			if(prev != null) {
				this.emptyLinesAfter(prev.token,0);
			}
		}
		if(after == "remove") {
			this.emptyLinesAfterSubTree(block,0);
		}
	}
	keepExistingEmptyLines() {
		let funcs = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 0) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < funcs.length) {
			let func = funcs[_g];
			++_g;
			let this1 = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(func),tokentree_TokenTreeDef.BrOpen);
			let block = this1;
			if(this1 == null) {
				block = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(func),tokentree_TokenTreeDef.BrOpen);
			}
			if(block == null) {
				block = tokentree_TokenTreeAccessHelper.firstOf(func,tokentree_TokenTreeDef.BrOpen);
			}
			if(block == null) {
				continue;
			}
			let fullPos = block.getPos();
			let startLine = this.parsedCode.getLinePos(fullPos.min).line;
			let endLine = this.parsedCode.getLinePos(fullPos.max).line;
			let _g1 = 0;
			let _g2 = this.parsedCode.emptyLines;
			while(_g1 < _g2.length) {
				let emptyLine = _g2[_g1];
				++_g1;
				if(startLine >= emptyLine || endLine <= emptyLine) {
					continue;
				}
				let tokenInf = this.findTokenAtOffset(this.parsedCode.linesIdx[emptyLine].l);
				if(tokenInf == null) {
					continue;
				}
				if(tokentree_utils_TokenTreeCheckUtils.isMetadata(tokenInf.token)) {
					continue;
				}
				tokenInf.emptyLinesAfter++;
			}
		}
	}
	markFileHeader() {
		let info = this.getTokenAt(0);
		let info2 = this.getTokenAt(1);
		let packagesAndImports = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 13:case 34:case 36:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(info == null) {
			return;
		}
		if(info.token.tok._hx_index == 7) {
			if(packagesAndImports.length == 0) {
				if(info2.token.tok._hx_index != 7) {
					return;
				}
			}
			info.emptyLinesAfter = this.config.emptyLines.afterFileHeaderComment;
		}
	}
}
formatter_marker_MarkEmptyLines.__name__ = "formatter.marker.MarkEmptyLines";
formatter_marker_MarkEmptyLines.__super__ = formatter_marker_MarkerBase;
Object.assign(formatter_marker_MarkEmptyLines.prototype, {
	__class__: formatter_marker_MarkEmptyLines
});
class formatter_marker_MarkLineEnds extends formatter_marker_MarkerBase {
	constructor(config,parsedCode,indenter) {
		super(config,parsedCode,indenter);
	}
	run() {
		let semicolonTokens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 10) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < semicolonTokens.length) this.lineEndAfter(semicolonTokens[_g++]);
		this.markBrOpenClose();
		this.markAt();
		this.markDblDot();
		this.markSharp();
		this.markComments();
		this.markStructureExtension();
	}
	markComments() {
		let commentTokens = this.parsedCode.root.filterCallback(function(token,index) {
			switch(token.tok._hx_index) {
			case 7:
				return tokentree_FilterResult.FoundSkipSubtree;
			case 8:
				return tokentree_FilterResult.FoundSkipSubtree;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < commentTokens.length) {
			let token = commentTokens[_g];
			++_g;
			switch(token.tok._hx_index) {
			case 7:
				let prev = this.getPreviousToken(token);
				let noneBefore = false;
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(token,prev.token)) {
						if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
							this.lineEndAfter(token);
						}
						this.noLineEndBefore(token);
						noneBefore = !this.isMultilineToken(token);
					}
				}
				let commentLine = this.parsedCode.getLinePos(token.pos.min);
				let prefix = this.parsedCode.getString(this.parsedCode.linesIdx[commentLine.line].l,token.pos.min);
				commentLine = this.parsedCode.getLinePos(token.pos.max);
				let postfix = this.parsedCode.getString(token.pos.max,this.parsedCode.linesIdx[commentLine.line].r);
				if(new EReg("^\\s*$","").match(prefix) && new EReg("^\\s*$","").match(postfix)) {
					this.lineEndAfter(token);
					continue;
				}
				let next = this.getNextToken(token);
				if(next == null) {
					continue;
				}
				if(this.parsedCode.isOriginalSameLine(token,next.token)) {
					this.noLineEndAfter(token);
				}
				let _g1 = next.token.tok;
				switch(_g1._hx_index) {
				case 1:
					if(!noneBefore) {
						this.lineEndAfter(token);
					}
					continue;
				case 2:
					let _gc = _g1.c;
					if(_gc._hx_index == 3) {
						if(_gc.s == "final") {
							if(!noneBefore) {
								this.lineEndAfter(token);
							}
							continue;
						}
					}
					break;
				default:
				}
				break;
			case 8:
				let prev1 = this.getPreviousToken(token);
				if(prev1 != null) {
					if(this.parsedCode.isOriginalSameLine(token,prev1.token)) {
						this.noLineEndBefore(token);
					}
				}
				this.lineEndAfter(token);
				break;
			default:
			}
		}
	}
	markBrOpenClose() {
		let brTokens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 18) {
				return tokentree_FilterResult.FoundGoDeeper;
			}
			return tokentree_FilterResult.GoDeeper;
		});
		let _g = 0;
		while(_g < brTokens.length) {
			let brOpen = brTokens[_g];
			++_g;
			let curlyPolicy = this.detectCurlyPolicy(brOpen);
			this.fixMissingSemicolonsInBlock(brOpen);
			let brClose = this.getCloseToken(brOpen);
			if(brClose == null) {
				switch(curlyPolicy.leftCurly) {
				case "after":
					this.lineEndAfter(brOpen);
					break;
				case "before":
					this.beforeLeftCurly(brOpen);
					break;
				case "both":
					this.beforeLeftCurly(brOpen);
					this.lineEndAfter(brOpen);
					break;
				case "none":
					break;
				}
				continue;
			}
			let prev = this.getPreviousToken(brOpen);
			if(prev != null) {
				let _g = prev.token.tok;
				if(_g._hx_index == 4) {
					switch(_g.s) {
					case "":case "a":case "b":case "e":case "i":case "p":case "v":
						if(this.parsedCode.isOriginalSameLine(brOpen,brClose)) {
							this.noLineEndAfter(brOpen);
							this.noLineEndBefore(brClose);
							this.whitespace(brOpen,"none");
							this.whitespace(brClose,"noneBefore");
							let next = this.getNextToken(brClose);
							if(next != null) {
								if(next.token.tok._hx_index == 12) {
									this.whitespace(brClose,"after");
								}
							}
							continue;
						}
						this.whitespace(brOpen,"noneBefore");
						break;
					default:
					}
				}
			}
			let next = this.getNextToken(brOpen);
			let isEmpty = false;
			if(next != null) {
				if(next.token.tok._hx_index == 19) {
					if(curlyPolicy.emptyCurly == "noBreak") {
						isEmpty = true;
					}
				}
			}
			if(!isEmpty) {
				switch(curlyPolicy.leftCurly) {
				case "after":
					this.lineEndAfter(brOpen);
					break;
				case "before":
					this.beforeLeftCurly(brOpen);
					break;
				case "both":
					this.beforeLeftCurly(brOpen);
					this.lineEndAfter(brOpen);
					break;
				case "none":
					break;
				}
			}
			let preventBefore = isEmpty;
			let preventAfter = false;
			next = this.getNextToken(brClose);
			if(next != null) {
				if(next.token.tok._hx_index == 12) {
					preventAfter = true;
				}
			}
			switch(curlyPolicy.rightCurly) {
			case "after":
				if(!preventAfter) {
					this.afterRightCurly(brClose);
				}
				break;
			case "before":
				if(!preventBefore) {
					this.beforeRightCurly(brClose);
				}
				break;
			case "both":
				if(!preventBefore) {
					this.beforeRightCurly(brClose);
				}
				if(!preventAfter) {
					this.afterRightCurly(brClose);
				}
				break;
			case "none":
				break;
			}
		}
	}
	fixMissingSemicolonsInBlock(token) {
		switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token)._hx_index) {
		case 0:
			break;
		case 1:case 2:case 3:case 4:
			return;
		}
		if(!token.hasChildren()) {
			return;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			switch(child.tok._hx_index) {
			case 3:
				continue;
			case 19:
				return;
			default:
				let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
				if(lastChild == null) {
					continue;
				}
				if(lastChild.tok._hx_index == 10) {
					continue;
				} else if(this.isMissingSemicolon(lastChild)) {
					this.lineEndAfter(lastChild);
				}
			}
		}
	}
	isMissingSemicolon(token) {
		while(true) {
			let next = this.getNextToken(token);
			if(next == null) {
				return true;
			}
			token = next.token;
			switch(token.tok._hx_index) {
			case 10:
				return false;
			case 17:case 21:
				continue;
			default:
				return true;
			}
		}
	}
	detectCurlyPolicy(brOpen) {
		let type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(brOpen);
		let curlyPolicy = { leftCurly : this.config.lineEnds.leftCurly, rightCurly : this.config.lineEnds.rightCurly, emptyCurly : this.config.lineEnds.emptyCurly};
		switch(type._hx_index) {
		case 0:
			if(brOpen.parent != null && this.config.lineEnds.anonFunctionCurly != null) {
				let _g = brOpen.parent.tok;
				switch(_g._hx_index) {
				case 1:
					if(_g.k._hx_index == 0) {
						return this.config.lineEnds.anonFunctionCurly;
					}
					break;
				case 14:
					return this.config.lineEnds.anonFunctionCurly;
				default:
				}
			}
			if(this.config.lineEnds.blockCurly != null) {
				return this.config.lineEnds.blockCurly;
			}
			break;
		case 1:
			if(this.config.lineEnds.typedefCurly != null) {
				return this.config.lineEnds.typedefCurly;
			}
			break;
		case 2:
			if(this.config.lineEnds.objectLiteralCurly != null) {
				return this.config.lineEnds.objectLiteralCurly;
			}
			break;
		case 3:
			if(this.config.lineEnds.anonTypeCurly != null) {
				return this.config.lineEnds.anonTypeCurly;
			} else {
				let brClose = this.getCloseToken(brOpen);
				if(this.parsedCode.isOriginalSameLine(brOpen,brClose)) {
					let _g = curlyPolicy.leftCurly;
					if(_g != null) {
						switch(_g) {
						case "before":
							curlyPolicy.leftCurly = "none";
							break;
						case "both":
							curlyPolicy.leftCurly = "after";
							break;
						default:
						}
					}
				}
			}
			break;
		case 4:
			break;
		}
		return curlyPolicy;
	}
	beforeLeftCurly(token) {
		this.lineEndBefore(token);
	}
	beforeRightCurly(token) {
		this.lineEndBefore(token);
	}
	afterRightCurly(token) {
		let next = token.index + 1;
		if(this.parsedCode.tokenList.tokens.length <= next) {
			this.lineEndAfter(token);
			return;
		}
		let nextToken = this.getTokenAt(next);
		if(nextToken == null) {
			this.lineEndAfter(token);
			return;
		}
		let _g = nextToken.token.tok;
		switch(_g._hx_index) {
		case 2:
			let _gc = _g.c;
			if(_gc._hx_index == 3) {
				if(_gc.s != "is") {
					this.lineEndAfter(token);
				}
			} else {
				this.lineEndAfter(token);
			}
			break;
		case 6:
			switch(_g.op._hx_index) {
			case 4:
				break;
			case 7:
				break;
			default:
				this.lineEndAfter(token);
			}
			break;
		case 10:
			break;
		case 11:
			break;
		case 14:
			break;
		case 15:
			break;
		case 18:
			switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(nextToken.token)._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				this.lineEndAfter(token);
				break;
			case 3:
				break;
			case 4:
				break;
			}
			break;
		case 21:
			break;
		default:
			this.lineEndAfter(token);
		}
	}
	markAt() {
		let atTokens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 23) {
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _gthis = this;
		let addLineEndBefore = function(atToken) {
			let prev = _gthis.getPreviousToken(atToken);
			if(prev == null) {
				_gthis.lineEndBefore(atToken);
				return;
			}
			let _g = prev.token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 2:case 42:
					_gthis.noLineEndBefore(atToken);
					break;
				case 4:
					_gthis.lineEndBefore(atToken);
					break;
				default:
				}
				break;
			case 18:
				_gthis.lineEndBefore(atToken);
				break;
			default:
			}
		};
		let _g = 0;
		while(_g < atTokens.length) {
			let token = atTokens[_g];
			++_g;
			let metadataPolicy = this.determineMetadataPolicy(token);
			let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			if(lastChild == null) {
				continue;
			}
			let isNotFirst = token.previousSibling != null && token.previousSibling.tok._hx_index == 23;
			if(!isNotFirst) {
				addLineEndBefore(token);
			}
			if(metadataPolicy == "after") {
				this.lineEndAfter(lastChild);
				continue;
			}
			if(isNotFirst) {
				continue;
			}
			let next = token.nextSibling;
			let metadata = [token];
			while(next != null && next.tok._hx_index == 23) {
				metadata.push(next);
				next = next.nextSibling;
			}
			let _g1 = 0;
			while(_g1 < metadata.length) {
				lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(metadata[_g1++]);
				if(lastChild == null) {
					continue;
				}
				switch(metadataPolicy) {
				case "after":
					this.lineEndAfter(lastChild);
					break;
				case "afterLast":
					let next = this.getNextToken(lastChild);
					if(next != null && !this.parsedCode.isOriginalSameLine(lastChild,next.token)) {
						this.lineEndAfter(lastChild);
						continue;
					}
					this.whitespace(lastChild,"after");
					break;
				case "forceAfterLast":
					this.whitespace(lastChild,"after");
					break;
				case "none":
					let next1 = this.getNextToken(lastChild);
					if(next1 != null && !this.parsedCode.isOriginalSameLine(lastChild,next1.token)) {
						this.lineEndAfter(lastChild);
						continue;
					}
					this.whitespace(lastChild,"after");
					break;
				}
			}
			if(metadataPolicy == "afterLast" || metadataPolicy == "forceAfterLast") {
				this.lineEndAfter(lastChild);
			}
		}
	}
	determineMetadataPolicy(token) {
		if(token == null) {
			return this.config.lineEnds.metadataOther;
		}
		let parent = token.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return this.config.lineEnds.metadataType;
		}
		let _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return this.config.lineEnds.metadataFunction;
			case 22:
				if(parent.parent == null) {
					return this.config.lineEnds.metadataOther;
				}
				let _g1 = parent.parent.tok;
				if(_g1._hx_index == 1) {
					switch(_g1.k._hx_index) {
					case 0:
						return this.config.lineEnds.metadataFunction;
					case 2:
						return this.config.lineEnds.metadataVar;
					case 1:case 26:case 28:case 32:case 40:
						return this.config.lineEnds.metadataType;
					default:
						return this.config.lineEnds.metadataOther;
					}
				} else {
					return this.config.lineEnds.metadataOther;
				}
				break;
			default:
				return this.config.lineEnds.metadataOther;
			}
			break;
		case 2:
			if(_g.c._hx_index == 3) {
				if(parent.parent == null) {
					return this.config.lineEnds.metadataOther;
				}
				let _g = parent.parent.tok;
				if(_g._hx_index == 1) {
					switch(_g.k._hx_index) {
					case 0:
						return this.config.lineEnds.metadataFunction;
					case 2:
						return this.config.lineEnds.metadataVar;
					case 1:case 26:case 28:case 32:case 40:
						return this.config.lineEnds.metadataType;
					default:
						return this.config.lineEnds.metadataOther;
					}
				} else {
					return this.config.lineEnds.metadataOther;
				}
			} else {
				return this.config.lineEnds.metadataOther;
			}
			break;
		case 3:
			return "after";
		case 4:
			if(parent.parent == null) {
				return this.config.lineEnds.metadataOther;
			}
			let _g2 = parent.parent.tok;
			if(_g2._hx_index == 1) {
				switch(_g2.k._hx_index) {
				case 0:
					return this.config.lineEnds.metadataFunction;
				case 2:
					return this.config.lineEnds.metadataVar;
				case 1:case 26:case 28:case 32:case 40:
					return this.config.lineEnds.metadataType;
				default:
					return this.config.lineEnds.metadataOther;
				}
			} else {
				return this.config.lineEnds.metadataOther;
			}
			break;
		default:
			return this.config.lineEnds.metadataOther;
		}
	}
	markDblDot() {
		let dblDotTokens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 12) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < dblDotTokens.length) {
			let token = dblDotTokens[_g];
			++_g;
			let tmp;
			let _g1 = token.parent.tok;
			if(!(_g1._hx_index == 1 && _g1.k._hx_index == 15)) {
				let _g = token.parent.tok;
				tmp = !(_g._hx_index == 1 && _g.k._hx_index == 16);
			} else {
				tmp = false;
			}
			if(tmp) {
				continue;
			}
			if(this.config.lineEnds.caseColon != "none") {
				this.lineEndAfter(token);
			}
			let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			if(lastChild == null) {
				continue;
			}
			this.lineEndAfter(lastChild);
		}
	}
	markSharp() {
		let sharpTokens = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 3) {
				switch(_g.s) {
				case "else":case "elseif":case "end":case "error":case "if":
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < sharpTokens.length) {
			let token = sharpTokens[_g];
			++_g;
			let _g1 = token.tok;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "else":
					if(this.isInlineSharp(token)) {
						this.noLineEndBefore(token);
						continue;
					}
					this.lineEndBefore(token);
					this.lineEndAfter(token);
					break;
				case "elseif":case "if":
					let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.getFirstChild());
					if(lastChild == null) {
						continue;
					}
					if(this.config.lineEnds.sharp == "none") {
						this.whitespace(lastChild,"after");
						continue;
					}
					if(this.isInlineSharp(token)) {
						let _g = token.tok;
						if(_g._hx_index == 3 && _g.s == "if" && this.isOnlyWhitespaceBeforeToken(token)) {
							continue;
						}
						this.noLineEndBefore(token);
						continue;
					}
					this.lineEndBefore(token);
					this.lineEndAfter(lastChild);
					break;
				case "end":
					if(this.isInlineSharp(token)) {
						this.noLineEndBefore(token);
					} else {
						this.lineEndBefore(token);
					}
					let next = this.getNextToken(token);
					if(next != null) {
						switch(next.token.tok._hx_index) {
						case 10:case 15:
							continue;
						default:
						}
					}
					if(!this.isOnlyWhitespaceAfterToken(token,true)) {
						continue;
					}
					this.lineEndAfter(token);
					break;
				case "error":
					let lastChild1 = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.getFirstChild());
					if(lastChild1 == null) {
						lastChild1 = token;
					}
					this.lineEndAfter(lastChild1);
					break;
				default:
					this.lineEndAfter(token);
				}
			} else {
				this.lineEndAfter(token);
			}
		}
	}
	isInlineSharp(token) {
		let _g = token.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "else":
				return this.isInlineSharp(token.parent);
			case "elseif":
				return this.isInlineSharp(token.parent);
			case "end":
				return this.isInlineSharp(token.parent);
			case "if":
				let sharpEnd = token.getLastChild();
				if(sharpEnd == null) {
					return false;
				}
				let _g1 = sharpEnd.tok;
				switch(_g1._hx_index) {
				case 3:
					if(_g1.s == "end") {
						let count = this.parsedCode.linesBetweenOriginal(token,sharpEnd);
						let next = this.getNextToken(sharpEnd);
						if(next != null) {
							switch(next.token.tok._hx_index) {
							case 10:case 15:
								if(count > 5) {
									return false;
								}
								return true;
							default:
							}
						}
						if(count == 0) {
							return true;
						}
						if(count > 3) {
							return false;
						}
					} else {
						return false;
					}
					break;
				case 10:case 15:
					sharpEnd = sharpEnd.previousSibling;
					if(sharpEnd == null) {
						return false;
					}
					let _g2 = sharpEnd.tok;
					if(!(_g2._hx_index == 3 && _g2.s == "end")) {
						return false;
					}
					break;
				default:
					return false;
				}
				if(!this.isOnlyWhitespaceAfterToken(sharpEnd,true)) {
					return true;
				}
				if(!this.isOnlyWhitespaceBeforeToken(token)) {
					return true;
				}
				let prev = this.getPreviousToken(token);
				if(prev == null) {
					return !this.isOnlyWhitespaceBeforeToken(token);
				}
				if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
					return false;
				}
				switch(prev.token.tok._hx_index) {
				case 6:
					return true;
				case 7:
					return false;
				case 8:
					return false;
				case 10:case 15:case 16:case 19:
					return false;
				case 21:
					if(this.parsedCode.isOriginalSameLine(prev.token,token)) {
						return true;
					}
					return false;
				default:
					return true;
				}
				break;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	isOnlyWhitespaceBeforeToken(token) {
		let tokenLine = this.parsedCode.getLinePos(token.pos.min);
		let prefix = this.parsedCode.getString(this.parsedCode.linesIdx[tokenLine.line].l,token.pos.min);
		return new EReg("^\\s*$","").match(prefix);
	}
	isOnlyWhitespaceAfterToken(token,allowLineComments) {
		let tokenLine = this.parsedCode.getLinePos(token.pos.max);
		let prefix = this.parsedCode.getString(token.pos.max,this.parsedCode.linesIdx[tokenLine.line].r);
		if(allowLineComments) {
			return new EReg("^\\s*(|//.*)$","").match(prefix);
		} else {
			return new EReg("^\\s*$","").match(prefix);
		}
	}
	findTypedefBrOpen(token) {
		let this1 = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(token)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign));
		if(this1 == null) {
			return null;
		}
		return tokentree_TokenTreeAccessHelper.firstOf(this1,tokentree_TokenTreeDef.BrOpen);
	}
	markStructureExtension() {
		let typedefTokens = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 32) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < typedefTokens.length) {
			let token = typedefTokens[_g];
			++_g;
			this.markAfterTypedef(token);
			let brOpen = this.findTypedefBrOpen(token);
			if(brOpen == null) {
				continue;
			}
			if(brOpen.children == null || brOpen.children.length <= 0) {
				continue;
			}
			let assignParent = brOpen.parent;
			if(assignParent.children.length > 1) {
				let _g = 0;
				let _g1 = assignParent.children;
				while(_g < _g1.length) {
					let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(_g1[_g++]);
					if(lastChild == null) {
						continue;
					}
					let next = this.getNextToken(lastChild);
					if(next == null) {
						continue;
					}
					if(lastChild.tok._hx_index == 19) {
						let _g = next.token.tok;
						switch(_g._hx_index) {
						case 6:
							if(_g.op._hx_index == 11) {
								this.noLineEndAfter(lastChild);
								continue;
							}
							break;
						case 10:
							this.whitespace(lastChild,"noneAfter");
							continue;
						case 14:
							this.whitespace(lastChild,"none");
							continue;
						default:
						}
					}
					switch(next.token.tok._hx_index) {
					case 10:case 18:
						continue;
					default:
					}
					this.lineEndAfter(lastChild);
				}
			}
			let _g1 = 0;
			let _g2 = brOpen.children;
			while(_g1 < _g2.length) {
				let child = _g2[_g1];
				++_g1;
				let _g = child.tok;
				switch(_g._hx_index) {
				case 2:
					if(_g.c._hx_index == 3) {
						let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
						if(lastChild == null) {
							continue;
						}
						let next = this.getNextToken(lastChild);
						if(next != null) {
							switch(next.token.tok._hx_index) {
							case 7:
								if(this.parsedCode.isOriginalSameLine(lastChild,next.token)) {
									this.lineEndAfter(next.token);
									continue;
								}
								break;
							case 8:
								if(this.parsedCode.isOriginalSameLine(lastChild,next.token)) {
									continue;
								}
								break;
							default:
							}
						}
						this.lineEndAfter(lastChild);
					}
					break;
				case 6:
					if(_g.op._hx_index == 7) {
						let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
						if(lastChild == null) {
							continue;
						}
						let next = this.getNextToken(lastChild);
						if(next != null) {
							switch(next.token.tok._hx_index) {
							case 7:
								if(this.parsedCode.isOriginalSameLine(lastChild,next.token)) {
									this.lineEndAfter(next.token);
									continue;
								}
								break;
							case 8:
								if(this.parsedCode.isOriginalSameLine(lastChild,next.token)) {
									continue;
								}
								break;
							default:
							}
						}
						this.lineEndAfter(lastChild);
					}
					break;
				case 19:
					let next = this.getNextToken(child);
					if(next == null) {
						continue;
					}
					let _g3 = next.token.tok;
					if(_g3._hx_index == 6 && _g3.op._hx_index == 11) {
						this.noLineEndAfter(child);
					}
					let _g4 = next.token.tok;
					if(_g4._hx_index == 6 && _g4.op._hx_index == 7) {
						this.whitespace(child,"noneAfter");
					}
					break;
				case 22:
					let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
					if(lastChild == null) {
						continue;
					}
					let next1 = this.getNextToken(lastChild);
					if(next1 != null) {
						switch(next1.token.tok._hx_index) {
						case 7:
							if(this.parsedCode.isOriginalSameLine(lastChild,next1.token)) {
								this.lineEndAfter(next1.token);
								continue;
							}
							break;
						case 8:
							if(this.parsedCode.isOriginalSameLine(lastChild,next1.token)) {
								continue;
							}
							break;
						default:
						}
					}
					this.lineEndAfter(lastChild);
					break;
				default:
				}
			}
		}
	}
	markAfterTypedef(token) {
		let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
		if(lastChild == null) {
			return;
		}
		let next = this.getNextToken(lastChild);
		if(next != null) {
			switch(next.token.tok._hx_index) {
			case 8:
				if(!this.parsedCode.isOriginalNewlineBefore(next.token)) {
					return;
				}
				break;
			case 10:
				this.whitespace(lastChild,"noneAfter");
				return;
			default:
			}
		}
		this.lineEndAfter(lastChild);
	}
	static outputLineSeparator(config,parsedCode) {
		let _g = config.lineEndCharacter;
		if(_g == null) {
			return parsedCode.lineSeparator;
		} else {
			switch(_g) {
			case "CR":
				return "\r";
			case "CRLF":
				return "\r\n";
			case "LF":
				return "\n";
			default:
				return parsedCode.lineSeparator;
			}
		}
	}
}
formatter_marker_MarkLineEnds.__name__ = "formatter.marker.MarkLineEnds";
formatter_marker_MarkLineEnds.__super__ = formatter_marker_MarkerBase;
Object.assign(formatter_marker_MarkLineEnds.prototype, {
	__class__: formatter_marker_MarkLineEnds
});
class formatter_marker_MarkSameLine extends formatter_marker_MarkerBase {
	constructor(config,parsedCode,indenter) {
		super(config,parsedCode,indenter);
	}
	run() {
		this.markDollarSameLine();
		let _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			if(token.parent != null && token.parent.tok._hx_index == 23) {
				return tokentree_FilterResult.GoDeeper;
			}
			let _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:
					_gthis.markFunction(token);
					break;
				case 3:
					_gthis.markIf(token);
					break;
				case 4:
					_gthis.markElse(token);
					break;
				case 5:
					let tmp;
					if(token.parent != null) {
						let _g = token.parent.tok;
						tmp = _g._hx_index == 1 && _g.k._hx_index == 6;
					} else {
						tmp = false;
					}
					if(tmp) {
						return tokentree_FilterResult.GoDeeper;
					}
					_gthis.markWhile(token);
					break;
				case 6:
					_gthis.markDoWhile(token);
					break;
				case 7:
					_gthis.markFor(token);
					break;
				case 10:
					_gthis.markReturn(token);
					break;
				case 15:
					_gthis.markCase(token);
					break;
				case 16:
					_gthis.markCase(token);
					break;
				case 20:
					_gthis.markTry(token);
					break;
				case 21:
					_gthis.markCatch(token);
					break;
				case 29:
					_gthis.markUntyped(token);
					break;
				case 41:
					_gthis.markMacro(token);
					break;
				default:
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	isExpression(token) {
		if(token == null) {
			return false;
		}
		let parent = token.parent;
		let _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 4:
				return this.shouldElseBeSameLine(parent);
			case 5:case 7:
				if(parent.parent.tok._hx_index == 16) {
					return true;
				}
				break;
			case 10:
				return true;
			case 29:
				return this.isExpression(parent);
			default:
			}
			break;
		case 6:
			return true;
		case 12:
			let lastChild = parent.getLastChild();
			if(lastChild == null) {
				return false;
			}
			if(lastChild.index != token.index) {
				return false;
			}
			return this.isReturnExpression(parent);
		case 14:
			return true;
		case 20:
			let pos = parent.getPos();
			if(pos.min < token.pos.min && pos.max > token.pos.max) {
				return true;
			}
			break;
		default:
		}
		return false;
	}
	isReturnExpression(token) {
		let parent = token;
		while(parent.parent.tok != tokentree_TokenTreeDef.Root) {
			parent = parent.parent;
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					return false;
				case 10:
					return true;
				default:
				}
				break;
			case 6:
				return true;
			case 12:
				return true;
			case 14:
				return true;
			case 16:
				return false;
			case 18:
				switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent)._hx_index) {
				case 0:
					break;
				case 1:
					break;
				case 2:
					return true;
				case 3:
					break;
				case 4:
					break;
				}
				break;
			case 20:
				return true;
			default:
			}
		}
		return false;
	}
	shouldIfBeSameLine(token) {
		if(token == null) {
			return false;
		}
		let _g = token.tok;
		if(!(_g._hx_index == 1 && _g.k._hx_index == 3)) {
			return false;
		}
		if(this.getBodyAfterCondition(token) == null) {
			return false;
		}
		return this.isExpression(token);
	}
	shouldElseBeSameLine(token) {
		if(token == null) {
			return false;
		}
		let _g = token.tok;
		if(!(_g._hx_index == 1 && _g.k._hx_index == 4)) {
			return false;
		}
		return this.shouldIfBeSameLine(token.parent);
	}
	shouldTryBeSameLine(token) {
		if(token == null) {
			return false;
		}
		let _g = token.tok;
		if(!(_g._hx_index == 1 && _g.k._hx_index == 20)) {
			return false;
		}
		return this.isExpression(token);
	}
	shouldCatchBeSameLine(token) {
		if(token == null) {
			return false;
		}
		let _g = token.tok;
		if(!(_g._hx_index == 1 && _g.k._hx_index == 21)) {
			return false;
		}
		return this.shouldTryBeSameLine(token.parent);
	}
	markIf(token) {
		if(this.shouldIfBeSameLine(token)) {
			switch(this.config.sameLine.expressionIf) {
			case "keep":
				this.markBodyAfterPOpen(token,"keep",this.config.sameLine.expressionIfWithBlocks);
				return;
			case "next":
				break;
			case "same":
				this.markBodyAfterPOpen(token,"same",this.config.sameLine.expressionIfWithBlocks);
				return;
			}
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.ifBody,false);
		let prev = this.getPreviousToken(token);
		let tmp;
		if(prev != null) {
			let _g = prev.token.tok;
			tmp = _g._hx_index == 1 && _g.k._hx_index == 4;
		} else {
			tmp = false;
		}
		if(tmp) {
			this.applySameLinePolicy(token,this.config.sameLine.elseIf);
		}
	}
	markElse(token) {
		if(this.shouldElseBeSameLine(token)) {
			switch(this.config.sameLine.expressionIf) {
			case "keep":
				this.markBody(token,"keep",this.config.sameLine.expressionIfWithBlocks);
				if(this.parsedCode.isOriginalNewlineBefore(token)) {
					this.lineEndBefore(token);
				}
				let prev = this.getPreviousToken(token);
				if(prev == null) {
					return;
				}
				if(prev.token.tok._hx_index == 19) {
					this.applySameLinePolicyChained(token,"keep","keep");
				}
				return;
			case "next":
				break;
			case "same":
				this.markBody(token,"same",this.config.sameLine.expressionIfWithBlocks);
				let prev1 = this.getPreviousToken(token);
				if(prev1 == null) {
					return;
				}
				if(prev1.token.tok._hx_index == 19) {
					this.applySameLinePolicyChained(token,this.config.sameLine.ifBody,this.config.sameLine.ifElse);
				}
				return;
			}
		}
		this.markBody(token,this.config.sameLine.elseBody,false);
		let policy = this.config.sameLine.ifElse;
		let prev2 = this.getPreviousToken(token);
		if(prev2 != null) {
			if(prev2.token.tok._hx_index == 19) {
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(prev2.token),tokentree_TokenTreeDef.BrOpen)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdIf)) == null) {
					switch(policy) {
					case "keep":
						break;
					case "next":
						break;
					case "same":
						policy = "next";
						break;
					}
				}
			}
		}
		this.applySameLinePolicyChained(token,this.config.sameLine.ifBody,policy);
	}
	markTry(token) {
		if(this.shouldTryBeSameLine(token) && this.config.sameLine.expressionTry == "same") {
			this.markBody(token,"same",false);
			return;
		}
		this.markBody(token,this.config.sameLine.tryBody,false);
	}
	markCatch(token) {
		if(this.shouldCatchBeSameLine(token) && this.config.sameLine.expressionTry == "same") {
			this.markBodyAfterPOpen(token,"same",false);
			this.applySameLinePolicy(token,this.config.sameLine.tryCatch);
			return;
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.catchBody,false);
		this.applySameLinePolicyChained(token,this.config.sameLine.tryBody,this.config.sameLine.tryCatch);
	}
	markCase(token) {
		if(token == null) {
			return;
		}
		let this1 = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.DblDot);
		if(this1 == null) {
			return;
		}
		if(this.isReturnExpression(token)) {
			this.markExpressionCase(token,this1);
			return;
		}
		if(this1.children == null || this1.children.length > 1) {
			return;
		}
		switch(this.config.sameLine.caseBody) {
		case "keep":
			if(!this.parsedCode.isOriginalSameLine(this1,this1.getFirstChild())) {
				return;
			}
			break;
		case "next":
			return;
		case "same":
			break;
		}
		let first = this1.getFirstChild();
		let last = tokentree_utils_TokenTreeCheckUtils.getLastToken(first);
		if(this.parsedCode.linesBetweenOriginal(first,last) > 2) {
			return;
		}
		this.noLineEndAfter(this1);
	}
	markExpressionCase(token,dblDot) {
		if(dblDot.children == null) {
			return;
		}
		switch(this.config.sameLine.expressionCase) {
		case "keep":
			if(!this.parsedCode.isOriginalSameLine(dblDot,dblDot.getFirstChild())) {
				return;
			}
			break;
		case "next":
			return;
		case "same":
			break;
		}
		if(dblDot.children.length == 2) {
			let second = dblDot.children[1];
			if(second.tok._hx_index == 8) {
				let prev = this.getPreviousToken(second);
				if(prev != null) {
					if(!this.parsedCode.isOriginalSameLine(dblDot,prev.token)) {
						return;
					}
				}
			} else {
				return;
			}
		}
		if(dblDot.children.length > 2) {
			return;
		}
		this.noLineEndAfter(dblDot);
	}
	isArrayComprehension(token) {
		if(token == null) {
			return false;
		}
		let parent = token.parent;
		while(parent != null) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 3:case 4:case 5:case 7:
					parent = parent.parent;
					break;
				default:
					return false;
				}
				break;
			case 16:
				return true;
			default:
				return false;
			}
		}
		return false;
	}
	markFor(token) {
		if(token == null) {
			return;
		}
		let parent = token.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return;
		}
		if(this.isArrayComprehension(token)) {
			this.markArrayComprehension(token,parent);
			return;
		}
		let _g = parent.tok;
		if(_g._hx_index == 1) {
			if(_g.k._hx_index == 41) {
				let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
				if(lastToken == null) {
					return;
				}
				if(this.parsedCode.isOriginalSameLine(token,lastToken)) {
					this.markBodyAfterPOpen(token,"same",false);
					return;
				}
			}
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.forBody,false);
	}
	markWhile(token) {
		if(token == null) {
			return;
		}
		let parent = token.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return;
		}
		if(this.isArrayComprehension(token)) {
			this.markArrayComprehension(token,parent);
			return;
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.whileBody,false);
	}
	markArrayComprehension(token,bkOpen) {
		let bkClose = this.getCloseToken(bkOpen);
		switch(this.config.sameLine.comprehensionFor) {
		case "keep":
			if(this.parsedCode.isOriginalNewlineBefore(token)) {
				this.lineEndBefore(token);
			}
			this.markBodyAfterPOpen(token,this.config.sameLine.comprehensionFor,false);
			if(bkClose != null && this.parsedCode.isOriginalNewlineBefore(bkClose)) {
				this.lineEndBefore(bkClose);
			}
			break;
		case "next":
			break;
		case "same":
			let origSame = false;
			if(bkClose != null) {
				origSame = this.parsedCode.isOriginalSameLine(bkOpen,bkClose);
			} else {
				let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(bkOpen);
				if(lastToken != null) {
					origSame = this.parsedCode.isOriginalSameLine(bkOpen,lastToken);
				}
			}
			if(origSame) {
				this.markBodyAfterPOpen(token,this.config.sameLine.comprehensionFor,false);
				if(bkClose != null) {
					this.whitespace(token,"noneBefore");
					this.whitespace(bkClose,"noneBefore");
				}
			} else {
				this.markBodyAfterPOpen(token,this.config.sameLine.forBody,false);
			}
			break;
		}
	}
	getBodyAfterCondition(token) {
		let this1 = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.POpen),tokentree_TokenTreeDef.PClose);
		if(this1 != null) {
			let next = this.getNextToken(this1);
			if(next != null) {
				if(next.token.tok._hx_index != 12) {
					return next.token;
				}
			}
		}
		if(token.children == null) {
			return null;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 1:
				switch(_g2.k._hx_index) {
				case 37:case 38:case 39:
					return child.nextSibling;
				default:
				}
				break;
			case 2:
				if(_g2.c._hx_index == 3) {
					return child.nextSibling;
				}
				break;
			case 18:
				return child;
			case 23:
				break;
			default:
			}
		}
		return null;
	}
	markBodyAfterPOpen(token,policy,includeBrOpen) {
		let body = this.getBodyAfterCondition(token);
		_hx_loop1: while(body != null) {
			let _g = body.tok;
			switch(_g._hx_index) {
			case 3:
				switch(_g.s) {
				case "else":case "elseif":case "end":
					return;
				default:
					break _hx_loop1;
				}
				break;
			case 8:
				let prev = this.getPreviousToken(body);
				if(prev != null) {
					if(!this.parsedCode.isOriginalSameLine(body,prev.token)) {
						this.applySameLinePolicy(body,policy);
						return;
					}
				}
				body = body.nextSibling;
				break;
			case 18:
				switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(body)._hx_index) {
				case 0:
					if(includeBrOpen) {
						this.markBlockBody(body,policy);
					}
					return;
				case 1:
					break;
				case 2:
					this.applySameLinePolicy(body,policy);
					break;
				case 3:
					break;
				case 4:
					break;
				}
				body = body.nextSibling;
				break;
			default:
				break _hx_loop1;
			}
		}
		if(body == null) {
			return;
		}
		this.applySameLinePolicy(body,policy);
	}
	markBody(token,policy,includeBrOpen) {
		let this1 = tokentree_TokenTreeAccessHelper.firstChild(token);
		if(this1 == null) {
			return;
		}
		if(this1.tok._hx_index == 18) {
			switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(this1)._hx_index) {
			case 0:
				if(includeBrOpen) {
					this.markBlockBody(this1,policy);
				}
				return;
			case 1:
				break;
			case 2:
				this.applySameLinePolicy(this1,policy);
				break;
			case 3:
				break;
			case 4:
				break;
			}
			return;
		}
		this.applySameLinePolicy(this1,policy);
	}
	markBlockBody(token,policy) {
		if(token == null) {
			return;
		}
		if(token.tok._hx_index != 18) {
			return;
		}
		if(token.children == null) {
			return;
		}
		if(token.getLastChild().tok._hx_index == 10) {
			if(token.children.length > 3) {
				return;
			}
		} else if(token.children.length > 2) {
			return;
		}
		this.noLineEndAfter(token);
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			if(child.tok._hx_index == 19) {
				let _g = this.getNextToken(child).token.tok;
				switch(_g._hx_index) {
				case 1:
					switch(_g.k._hx_index) {
					case 4:
						this.noLineEndAfter(child);
						break;
					case 21:
						this.noLineEndAfter(child);
						break;
					default:
					}
					break;
				case 10:
					this.whitespace(child,"noneAfter");
					break;
				case 15:
					this.whitespace(child,"noneAfter");
					break;
				default:
				}
				return;
			} else {
				let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
				if(lastToken == null) {
					return;
				}
				this.noLineEndAfter(lastToken);
			}
		}
	}
	applySameLinePolicyChained(token,previousBlockPolicy,policy) {
		if(policy == "same") {
			let prev = this.getPreviousToken(token);
			if(prev == null) {
				policy = "next";
			}
			if(prev.token.tok._hx_index != 19 && previousBlockPolicy != "same") {
				policy = "next";
			}
		}
		this.applySameLinePolicy(token,policy);
	}
	applySameLinePolicy(token,policy) {
		switch(policy) {
		case "keep":
			if(this.parsedCode.isOriginalNewlineBefore(token)) {
				this.applySameLinePolicy(token,"next");
			} else {
				this.applySameLinePolicy(token,"same");
			}
			break;
		case "next":
			switch(token.tok._hx_index) {
			case 8:
				if(!this.parsedCode.isOriginalNewlineBefore(token)) {
					return;
				}
				break;
			case 16:
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFor)) != null) {
					return;
				}
				break;
			default:
			}
			let prev = this.getPreviousToken(token);
			if(prev == null || !tokentree_utils_TokenTreeCheckUtils.isMetadata(prev.token)) {
				this.lineEndBefore(token);
				return;
			}
			if(!this.parsedCode.isOriginalNewlineBefore(token)) {
				return;
			}
			this.lineEndBefore(token);
			break;
		case "same":
			this.wrapBefore(token,true);
			let prev1 = this.getPreviousToken(token);
			if(prev1 == null) {
				this.noLineEndBefore(token);
			} else if(token.tok._hx_index == 23) {
				switch(prev1.token.tok._hx_index) {
				case 1:
					break;
				case 3:
					break;
				case 6:
					this.lineEndBefore(token);
					break;
				case 11:case 20:
					this.whitespace(token,"noneBefore");
					break;
				case 10:case 12:case 18:case 19:
					break;
				default:
					this.noLineEndBefore(token);
				}
			} else {
				switch(prev1.token.tok._hx_index) {
				case 11:case 20:
					this.whitespace(token,"noneBefore");
					break;
				default:
					this.noLineEndBefore(token);
				}
			}
			let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			if(lastToken == null) {
				return;
			}
			let next = this.getNextToken(lastToken);
			if(next == null) {
				return;
			}
			let _g = next.token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 4) {
					this.noLineEndAfter(lastToken);
				}
			}
			return;
		}
	}
	markDollarSameLine() {
		let tokens = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 4) {
				switch(_g.s) {
				case "":case "a":case "b":case "e":case "i":case "p":case "v":
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < tokens.length) {
			let this1 = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(tokens[_g++]),tokentree_TokenTreeDef.BrOpen);
			if(this1 == null) {
				continue;
			}
			let brClose = this.getCloseToken(this1);
			if(!this.parsedCode.isOriginalSameLine(this1,brClose)) {
				continue;
			}
			this.whitespace(this1,"none");
			let next = this.getNextToken(brClose);
			if(next != null) {
				switch(next.token.tok._hx_index) {
				case 10:case 11:case 15:
					this.whitespace(brClose,"none");
					break;
				case 12:case 16:case 17:case 19:case 20:case 21:
					break;
				default:
					this.whitespace(brClose,"onlyAfter");
				}
			} else {
				this.noLineEndAfter(brClose);
			}
			this.wrapBefore(this1,false);
			this.wrapAfter(this1,false);
			this.wrapBefore(brClose,false);
			this.wrapAfter(brClose,false);
		}
	}
	markFunction(token) {
		let this1 = tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(token));
		let body = this1;
		if(this1 == null) {
			body = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdNew));
		}
		let policy = this.config.sameLine.functionBody;
		if(body == null) {
			body = token;
			policy = this.config.sameLine.anonFunctionBody;
		}
		if(body == null || body.children == null) {
			return;
		}
		let this2 = tokentree_TokenTreeAccessHelper.firstOf(body,tokentree_TokenTreeDef.POpen);
		body = this2;
		if(this2 == null) {
			return;
		}
		if(this2.nextSibling == null) {
			return;
		}
		body = this2.nextSibling;
		if(body.tok._hx_index == 12) {
			body = body.nextSibling;
		}
		if(body == null) {
			return;
		}
		let _g = body.tok;
		switch(_g._hx_index) {
		case 3:
			if(_g.s == "if") {
				return;
			}
			break;
		case 8:
			return;
		case 10:
			return;
		case 18:
			return;
		default:
		}
		this.applySameLinePolicy(body,policy);
	}
	markDoWhile(token) {
		this.markBody(token,this.config.sameLine.doWhileBody,false);
		let this1 = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdWhile));
		if(this1 == null) {
			return;
		}
		this.applySameLinePolicy(this1,this.config.sameLine.doWhile);
	}
	markMacro(token) {
		let brOpen = this.getNextToken(token);
		if(brOpen == null || brOpen.token.tok._hx_index != 18) {
			return;
		}
		let brClose = this.getCloseToken(brOpen.token);
		if(this.parsedCode.isOriginalSameLine(brOpen.token,brClose)) {
			this.noLineEndAfter(brOpen.token);
			this.noLineEndBefore(brClose);
			this.noWrappingBetween(brOpen.token,brClose);
		}
	}
	markReturn(token) {
		if(this.shouldReturnBeSameLine(token)) {
			this.markBody(token,this.config.sameLine.returnBodySingleLine,false);
		} else {
			this.markBody(token,this.config.sameLine.returnBody,false);
		}
	}
	markUntyped(token) {
		if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.BrOpen) == null) {
			return;
		}
		let parent = token.parent;
		if(parent == null || token.tok == tokentree_TokenTreeDef.Root) {
			return;
		}
		if(parent.tok._hx_index == 18) {
			switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent)._hx_index) {
			case 0:
				return;
			case 1:
				return;
			case 2:
				break;
			case 3:
				break;
			case 4:
				break;
			}
		}
		this.applySameLinePolicy(token,this.config.sameLine.untypedBody);
	}
	shouldReturnBeSameLine(token) {
		let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
		if(lastToken == null) {
			return true;
		}
		if(this.isSameLineBetween(token,lastToken,false)) {
			return true;
		}
		return this.shouldReturnChildsBeSameLine(token);
	}
	shouldReturnChildsBeSameLine(token) {
		if(token.children == null) {
			return true;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			if(_g2._hx_index == 1) {
				switch(_g2.k._hx_index) {
				case 3:case 5:case 7:case 14:case 20:
					return false;
				default:
					if(!this.shouldReturnChildsBeSameLine(child)) {
						return false;
					}
				}
			} else if(!this.shouldReturnChildsBeSameLine(child)) {
				return false;
			}
		}
		return true;
	}
}
formatter_marker_MarkSameLine.__name__ = "formatter.marker.MarkSameLine";
formatter_marker_MarkSameLine.__super__ = formatter_marker_MarkerBase;
Object.assign(formatter_marker_MarkSameLine.prototype, {
	__class__: formatter_marker_MarkSameLine
});
class formatter_marker_MarkTokenText extends formatter_marker_MarkerBase {
	constructor(config,parsedCode,indenter) {
		super(config,parsedCode,indenter);
	}
	run() {
		let _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 2:
				switch(_g.c._hx_index) {
				case 2:
					_gthis.tokenText(token,_gthis.printStringToken(token));
					break;
				case 4:
					_gthis.tokenText(token,_gthis.printEregToken(token));
					break;
				default:
					_gthis.tokenText(token,token.toString());
				}
				break;
			case 8:
				_gthis.tokenText(token,_gthis.printCommentLine(_g.s));
				break;
			default:
				_gthis.tokenText(token,token.toString());
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	finalRun() {
		let _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 7) {
				_gthis.tokenText(token,_gthis.printComment(_g.s,token));
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	printStringToken(token) {
		let text = this.parsedCode.getString(token.pos.min,token.pos.max);
		if(!this.config.whitespace.formatStringInterpolation) {
			return text;
		}
		if(text.startsWith("'")) {
			let start = 0;
			let index;
			while(true) {
				index = text.indexOf("${",start);
				if(!(index >= 0)) {
					break;
				}
				if(this.isDollarEscaped(text,index)) {
					return text;
				}
				start = index + 1;
				let indexEnd = text.indexOf("}",index + 2);
				let fragment = text.substring(index + 2,indexEnd);
				if(fragment.indexOf("{") >= 0) {
					continue;
				}
				let formatted = this.formatFragment(fragment);
				start += formatted.length;
				text = HxOverrides.substr(text,0,index + 2) + formatted + HxOverrides.substr(text,indexEnd,null);
			}
		}
		return text;
	}
	isDollarEscaped(text,index) {
		let escaped = false;
		while(--index >= 0) {
			if(text.charCodeAt(index) != 36) {
				return escaped;
			}
			escaped = !escaped;
		}
		return escaped;
	}
	formatFragment(fragment) {
		try {
			let tokens = this.makeTokens(haxe_io_Bytes.ofString(fragment),"string interpolation");
			let stream = new tokentree_TokenStream(tokens,haxe_io_Bytes.ofString(fragment));
			let root = new tokentree_TokenTree(tokentree_TokenTreeDef.Root,"",null,-1);
			let progress = new tokentree_TokenStreamProgress(stream);
			while(progress.streamHasChanged()) if(stream.hasMore()) {
				tokentree_walk_WalkStatement.walkStatement(stream,root);
			}
			let interpolParsedCode = new formatter_codedata_ParsedCode({ fileName : "string interpolation", content : haxe_io_Bytes.ofString(fragment), tokenList : tokens, tokenTree : root, config : this.config, entryPoint : tokentree_TokenTreeEntryPoint.ExpressionLevel});
			let interpolIndenter = new formatter_marker_Indenter(this.config.indentation);
			interpolIndenter.setParsedCode(interpolParsedCode);
			let markWhitespace = new formatter_marker_MarkWhitespace(this.config,interpolParsedCode,interpolIndenter);
			new formatter_marker_MarkTokenText(this.config,interpolParsedCode,interpolIndenter).run();
			markWhitespace.run();
			let outputLineEnds = formatter_marker_MarkLineEnds.outputLineSeparator(this.config.lineEnds,interpolParsedCode);
			return StringTools.trim(new formatter_codedata_CodeLines(interpolParsedCode,interpolIndenter).print(outputLineEnds));
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
		}
		return fragment;
	}
	makeTokens(fragment,name) {
		let tokens = [];
		try {
			let lexer = new haxeparser_HaxeLexer(fragment,name);
			let t = lexer.token(haxeparser_HaxeLexer.tok);
			while(t.tok != haxeparser_TokenDef.Eof) {
				tokens.push(t);
				t = lexer.token(haxeparser_HaxeLexer.tok);
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			throw haxe_Exception.thrown("failed to make tokens " + (_g1 == null ? "null" : Std.string(_g1)));
		}
		return tokens;
	}
	printEregToken(token) {
		return this.parsedCode.getString(token.pos.min,token.pos.max);
	}
	printComment(text,token) {
		let lines = text.split(this.parsedCode.lineSeparator);
		let indent = this.indenter.calcIndent(token);
		let startsWithStar = lines.length >= 3;
		let _g = 1;
		let _g1 = lines.length - 1;
		while(_g < _g1) if(!new EReg("^\\s*\\*(\\s|$)","").match(lines[_g++])) {
			startsWithStar = false;
			break;
		}
		let linesNew = [];
		let _g2 = 0;
		while(_g2 < lines.length) linesNew.push(this.convertLeadingIndent(lines[_g2++]));
		lines = this.removeCommentPrefix(linesNew);
		let outputLineEnds = formatter_marker_MarkLineEnds.outputLineSeparator(this.config.lineEnds,this.parsedCode);
		text = "/*" + lines[0];
		let _g3 = 1;
		let _g4 = lines.length;
		while(_g3 < _g4) {
			let index = _g3++;
			text += outputLineEnds;
			let line = lines[index];
			let lineIndent = indent;
			let lastLine = index == lines.length - 1;
			if(!lastLine) {
				lineIndent = indent + 1;
			}
			if(startsWithStar) {
				lineIndent = indent;
			}
			if(!lastLine && line.length <= 0) {
				lineIndent = 0;
			}
			if(!lastLine && startsWithStar) {
				line = " " + line;
			}
			if(lastLine) {
				if(new EReg("^\\s*\\*\\s*[^\\s\\*]","").match(line)) {
					line = " " + line;
				}
				if(new EReg("^\\s*}","").match(line)) {
					line = StringTools.trim(line);
				} else {
					if(new EReg("^\\s*[^*\\s]","").match(line)) {
						lineIndent = indent + 1;
					}
					line = StringTools.rtrim(line);
					if(!line.endsWith("*")) {
						line += " ";
					}
				}
				if(new EReg("^\\s*$","").match(line)) {
					line = " ";
				}
			}
			text += this.indenter.makeIndentString(lineIndent) + line;
		}
		return text + "*/";
	}
	removeCommentPrefix(lines) {
		let prefixReg = new EReg("^(\\s*)","");
		let prefix = null;
		let linesNew = [];
		let endIndex = lines.length - 1;
		let lastLine = lines[lines.length - 1];
		if(!new EReg("^\\s*(\\**$|\\})","").match(lastLine)) {
			endIndex = lines.length;
		}
		let _g = 1;
		let _g1 = endIndex;
		while(_g < _g1) {
			prefixReg.match(lines[_g++]);
			let linePrefix = prefixReg.matched(1);
			if(linePrefix.length <= 0) {
				continue;
			}
			if(prefix == null || prefix.length > linePrefix.length) {
				prefix = linePrefix;
			}
		}
		if(prefix != null) {
			linesNew = [];
			let startPrefix = prefix + " *";
			let _g = 0;
			while(_g < lines.length) {
				let line = lines[_g];
				++_g;
				if(line.startsWith(startPrefix)) {
					line = HxOverrides.substr(line,startPrefix.length - 1,null);
				}
				if(line.startsWith(prefix)) {
					line = HxOverrides.substr(line,prefix.length,null);
				}
				linesNew.push(line);
			}
			lines = linesNew;
		}
		let lastLine1 = lines[lines.length - 1];
		if(new EReg("^\\s*\\*\\**$","").match(lastLine1)) {
			lines[lines.length - 1] = StringTools.ltrim(lastLine1);
		}
		return lines;
	}
	convertLeadingIndent(line) {
		let spaceIndent = StringTools.lpad(""," ",this.config.indentation.tabWidth);
		let oneIndent = this.config.indentation.character;
		let whitespaceReg = new EReg("^\\s+","");
		if(!whitespaceReg.match(line)) {
			return line;
		}
		let match = whitespaceReg.matched(0);
		if(this.config.indentation.character == "\t") {
			line = StringTools.replace(match,spaceIndent,oneIndent) + HxOverrides.substr(line,match.length,null);
		} else {
			line = StringTools.replace(match,"\t",oneIndent) + HxOverrides.substr(line,match.length,null);
		}
		return line;
	}
	printCommentLine(text) {
		if(new EReg("^[/\\*\\-\\s]+","").match(text)) {
			return "//" + StringTools.rtrim(text);
		}
		if(this.config.whitespace.addLineCommentSpace) {
			return "// " + StringTools.trim(text);
		}
		return "//" + StringTools.trim(text);
	}
}
formatter_marker_MarkTokenText.__name__ = "formatter.marker.MarkTokenText";
formatter_marker_MarkTokenText.__super__ = formatter_marker_MarkerBase;
Object.assign(formatter_marker_MarkTokenText.prototype, {
	__class__: formatter_marker_MarkTokenText
});
class formatter_marker_MarkWhitespace extends formatter_marker_MarkerBase {
	constructor(config,parsedCode,indenter) {
		super(config,parsedCode,indenter);
	}
	run() {
		let _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				if(_g.k._hx_index == 27) {
					_gthis.markIn(token);
				} else {
					_gthis.markKeyword(token);
				}
				break;
			case 2:
				let _gc = _g.c;
				if(_gc._hx_index == 3) {
					switch(_gc.s) {
					case "is":
						_gthis.markIs(token);
						break;
					case "from":case "to":
						if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(token)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdAbstract)) != null) {
							_gthis.whitespace(token,"around");
							_gthis.wrapBefore(token,true);
						}
						_gthis.fixConstAfterConst(token);
						break;
					default:
						_gthis.fixConstAfterConst(token);
					}
				} else {
					_gthis.fixConstAfterConst(token);
				}
				break;
			case 3:
				_gthis.markSharp(token);
				break;
			case 4:
				_gthis.markDollar(token);
				break;
			case 5:
				_gthis.markUnop(token);
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 1:
					if(tokentree_utils_TokenTreeCheckUtils.isImport(token.parent)) {
						_gthis.whitespace(token,"none");
					} else {
						_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
					}
					break;
				case 3:
					if(tokentree_utils_TokenTreeCheckUtils.filterOpSub(token)) {
						let policy = formatter_config_WhitespacePolicy.remove(_gthis.config.whitespace.binopPolicy,"after");
						switch(_gthis.getPreviousToken(token).token.tok._hx_index) {
						case 16:case 20:
							policy = formatter_config_WhitespacePolicy.remove(policy,"before");
							break;
						default:
						}
						_gthis.whitespace(token,policy);
					} else {
						_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
					}
					break;
				case 4:
					_gthis.markOpAssign(token);
					break;
				case 7:
					_gthis.markGt(token);
					break;
				case 9:
					if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token)) {
						_gthis.whitespace(token,_gthis.config.whitespace.typeParamOpenPolicy);
					} else {
						_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
					}
					break;
				case 21:
					_gthis.markOpSpread(token);
					break;
				case 23:
					_gthis.markIn(token);
					break;
				default:
					_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
				}
				break;
			case 7:
				_gthis.markComment(token);
				break;
			case 8:
				_gthis.whitespace(token,"before");
				break;
			case 10:
				_gthis.markSemicolon(token);
				break;
			case 12:
				_gthis.markDblDot(token);
				break;
			case 14:
				_gthis.markArrow(token);
				break;
			case 15:
				_gthis.whitespace(token,_gthis.config.whitespace.commaPolicy);
				break;
			case 16:
				_gthis.successiveParenthesis(token,false,_gthis.config.whitespace.openingBracketPolicy,_gthis.config.whitespace.compressSuccessiveParenthesis);
				break;
			case 17:
				_gthis.successiveParenthesis(token,true,_gthis.config.whitespace.closingBracketPolicy,_gthis.config.whitespace.compressSuccessiveParenthesis);
				break;
			case 18:
				_gthis.markBrOpen(token);
				break;
			case 19:
				_gthis.markBrClose(token);
				break;
			case 20:
				_gthis.markPOpen(token);
				break;
			case 21:
				_gthis.markPClose(token);
				break;
			case 22:
				if(tokentree_utils_TokenTreeCheckUtils.isTernary(token)) {
					_gthis.whitespace(token,_gthis.config.whitespace.ternaryPolicy);
				} else {
					_gthis.whitespace(token,"noneAfter");
				}
				break;
			case 23:
				_gthis.markAt(token);
				break;
			case 25:
				_gthis.markOpSpread(token);
				break;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	markOpSpread(token) {
		let prev = this.getPreviousToken(token);
		let policy = this.config.whitespace.intervalPolicy;
		if(prev != null) {
			policy = prev.token.tok._hx_index == 15 ? formatter_config_WhitespacePolicy.add(this.config.whitespace.intervalPolicy,"before") : this.config.whitespace.intervalPolicy;
		}
		this.whitespace(token,policy);
	}
	markGt(token) {
		if(tokentree_utils_TokenTreeCheckUtils.isOpGtTypedefExtension(token)) {
			this.whitespace(token,this.config.whitespace.typeExtensionPolicy);
			return;
		}
		if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token)) {
			let policy = this.config.whitespace.typeParamClosePolicy;
			let next = this.getNextToken(token);
			if(next != null) {
				let _g = next.token.tok;
				switch(_g._hx_index) {
				case 1:
					policy = formatter_config_WhitespacePolicy.add(policy,"after");
					break;
				case 6:
					if(_g.op._hx_index == 7) {
						policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					}
					break;
				case 10:case 15:
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					break;
				case 19:case 21:
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					break;
				default:
				}
			}
			this.whitespace(token,policy);
		} else {
			this.whitespace(token,this.config.whitespace.binopPolicy);
		}
	}
	fixConstAfterConst(token) {
		let next = this.getNextToken(token);
		if(next != null) {
			switch(next.token.tok._hx_index) {
			case 1:
				this.whitespace(token,"after");
				break;
			case 2:
				this.whitespace(token,"after");
				break;
			default:
			}
		}
	}
	successiveParenthesis(token,closing,policy,compress) {
		let next = this.getNextToken(token);
		if(next != null) {
			let _g = next.token.tok;
			switch(_g._hx_index) {
			case 1:
				if(closing) {
					policy = formatter_config_WhitespacePolicy.add(policy,"after");
				}
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 7:
					if(token.tok._hx_index == 19) {
						policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					}
					break;
				case 22:
					policy = formatter_config_WhitespacePolicy.add(policy,"after");
					break;
				default:
				}
				break;
			case 10:case 11:case 12:case 15:
				policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				break;
			default:
			}
		}
		if(!compress) {
			this.whitespace(token,policy);
			return;
		}
		if(closing) {
			if(next != null) {
				let _g = next.token.tok;
				switch(_g._hx_index) {
				case 6:
					if(_g.op._hx_index == 7) {
						if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(next.token)) {
							policy = formatter_config_WhitespacePolicy.remove(policy,"after");
						}
					}
					break;
				case 16:case 17:case 18:case 20:case 21:
					if(token.tok._hx_index == 21) {
						switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(token.parent)._hx_index) {
						case 1:
							policy = formatter_config_WhitespacePolicy.add(policy,"after");
							break;
						case 3:case 4:case 5:case 6:case 7:
							policy = formatter_config_WhitespacePolicy.add(policy,"after");
							break;
						case 8:
							policy = formatter_config_WhitespacePolicy.add(policy,"after");
							break;
						case 0:case 2:case 9:
							policy = formatter_config_WhitespacePolicy.remove(policy,"after");
							break;
						}
					} else {
						policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					}
					break;
				case 19:
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					break;
				default:
				}
			}
		} else {
			let prev = this.getPreviousToken(token);
			if(prev != null) {
				let _g = prev.token.tok;
				switch(_g._hx_index) {
				case 2:
					let _gc = _g.c;
					if(_gc._hx_index == 3) {
						switch(_gc.s) {
						case "from":case "to":
							let parent = prev.token.parent;
							if(parent != null) {
								if(parent.tok._hx_index == 2) {
									policy = formatter_config_WhitespacePolicy.add(policy,"before");
								}
							}
							break;
						default:
						}
					}
					break;
				case 6:
					switch(_g.op._hx_index) {
					case 9:
						if(token.tok._hx_index == 18) {
							return;
						}
						break;
					case 21:
						policy = formatter_config_WhitespacePolicy.remove(policy,"before");
						break;
					default:
					}
					break;
				case 9:
					policy = formatter_config_WhitespacePolicy.remove(policy,"before");
					break;
				case 12:
					switch(prev.whitespaceAfter._hx_index) {
					case 0:
						policy = formatter_config_WhitespacePolicy.remove(policy,"before");
						break;
					case 1:
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
						break;
					case 2:
						break;
					}
					break;
				case 14:
					return;
				case 15:
					let _g1 = this.config.whitespace.commaPolicy;
					if(_g1 != null) {
						switch(_g1) {
						case "after":case "around":case "onlyAfter":
							policy = formatter_config_WhitespacePolicy.add(policy,"before");
							break;
						default:
						}
					}
					break;
				case 21:
					switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(prev.token)._hx_index) {
					case 3:case 4:case 5:case 6:case 7:
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
						break;
					default:
					}
					break;
				case 16:case 18:case 20:case 25:
					policy = formatter_config_WhitespacePolicy.remove(policy,"before");
					break;
				default:
				}
			}
		}
		this.whitespace(token,policy);
	}
	markKeyword(token) {
		let prev = this.getPreviousToken(token);
		if(prev != null) {
			switch(prev.token.tok._hx_index) {
			case 2:
				prev.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				break;
			case 21:
				prev.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				break;
			case 23:
				return;
			default:
			}
		}
		let _g = token.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 3:
				this.whitespace(token,this.config.whitespace.ifPolicy);
				break;
			case 4:
				this.whitespace(token,formatter_config_WhitespacePolicy.add(this.config.whitespace.ifPolicy,"after"));
				break;
			case 5:
				this.whitespace(token,this.config.whitespace.whilePolicy);
				break;
			case 6:
				this.whitespace(token,this.config.whitespace.doPolicy);
				break;
			case 7:
				this.whitespace(token,this.config.whitespace.forPolicy);
				break;
			case 9:case 16:case 23:case 37:case 38:case 39:
				let next = this.getNextToken(token);
				if(next != null) {
					let _g = next.token.tok;
					switch(_g._hx_index) {
					case 1:
						this.whitespace(token,"after");
						return;
					case 2:
						if(_g.c._hx_index == 3) {
							this.whitespace(token,"after");
							return;
						}
						break;
					case 22:
						this.whitespace(token,"after");
						return;
					default:
					}
				}
				this.whitespace(token,"noneAfter");
				break;
			case 10:
				this.whitespace(token,"after");
				break;
			case 11:case 12:
				this.whitespace(token,"around");
				break;
			case 14:
				this.whitespace(token,this.config.whitespace.switchPolicy);
				break;
			case 20:
				this.whitespace(token,this.config.whitespace.tryPolicy);
				break;
			case 21:
				this.whitespace(token,this.config.whitespace.catchPolicy);
				break;
			case 29:
				this.whitespace(token,"after");
				break;
			default:
				let next1 = this.getNextToken(token);
				if(next1 != null) {
					switch(next1.token.tok._hx_index) {
					case 11:
						return;
					case 20:
						return;
					default:
					}
				}
				this.whitespace(token,"after");
			}
		}
	}
	markIs(token) {
		let prev = this.getPreviousToken(token);
		let policy = "around";
		if(prev != null) {
			switch(prev.token.tok._hx_index) {
			case 11:case 20:
				policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				break;
			default:
			}
		}
		this.whitespace(token,policy);
	}
	markIn(token) {
		if(!tokentree_utils_TokenTreeCheckUtils.hasAtParent(token)) {
			this.whitespace(token,"around");
			return;
		}
		let policy = "after";
		if(token.hasChildren()) {
			policy = "none";
		}
		this.whitespace(token,policy);
	}
	markOpAssign(token) {
		let prev = this.getPreviousToken(token);
		if(prev == null) {
			this.whitespace(token,this.config.whitespace.binopPolicy);
			return;
		}
		let policy = this.config.whitespace.binopPolicy;
		let _g = prev.token.tok;
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 14:case 15:
				prev.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
				policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				break;
			default:
			}
		}
		this.whitespace(token,policy);
	}
	markUnop(token) {
		let next = this.getNextToken(token);
		if(next != null) {
			switch(next.token.tok._hx_index) {
			case 10:case 15:
				return;
			case 11:
				let _g = token.tok;
				if(_g._hx_index == 5) {
					if(_g.op._hx_index == 2) {
						this.whitespace(token,"none");
						return;
					}
				}
				break;
			case 17:case 19:case 21:
				return;
			default:
			}
		}
		let prev = this.getPreviousToken(token);
		if(prev == null) {
			return;
		}
		let _g1 = prev.token.tok;
		if(_g1._hx_index == 2) {
			if(_g1.c._hx_index == 3) {
				let _g = token.tok;
				if(_g._hx_index == 5) {
					switch(_g.op._hx_index) {
					case 2:case 3:case 4:
						return;
					default:
					}
				}
				this.whitespace(token,"after");
			}
		}
	}
	markDollar(token) {
		let next = this.getNextToken(token);
		if(next == null) {
			return;
		}
		switch(next.token.tok._hx_index) {
		case 1:
			this.whitespace(token,"after");
			break;
		case 2:
			this.whitespace(token,"after");
			break;
		default:
		}
	}
	markDblDot(token) {
		let type = tokentree_utils_TokenTreeCheckUtils.getColonType(token);
		if(type == null) {
			type = tokentree_utils_ColonType.Unknown;
		}
		let policy = this.config.whitespace.colonPolicy;
		switch(type._hx_index) {
		case 0:
			policy = this.config.whitespace.caseColonPolicy;
			break;
		case 1:
			policy = this.config.whitespace.typeHintColonPolicy;
			let parent = token.parent;
			if(parent != null) {
				let _g = parent.tok;
				if(_g._hx_index == 1) {
					if(_g.k._hx_index == 41) {
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
					}
				}
			}
			break;
		case 2:
			policy = this.config.whitespace.typeCheckColonPolicy;
			break;
		case 3:
			policy = this.config.whitespace.ternaryPolicy;
			break;
		case 4:
			policy = this.config.whitespace.objectFieldColonPolicy;
			break;
		case 5:
			this.whitespace(token,"none");
			return;
		case 6:
			policy = this.config.whitespace.colonPolicy;
			break;
		}
		policy = this.correctDblDotSharp(token,policy);
		this.whitespace(token,policy);
	}
	correctDblDotSharp(token,policy) {
		let prev = this.getPreviousToken(token);
		if(prev == null) {
			return policy;
		}
		let _g = prev.token.tok;
		switch(_g._hx_index) {
		case 2:
			if(prev.token.parent == null) {
				return policy;
			}
			let _g1 = prev.token.parent.tok;
			if(_g1._hx_index == 3) {
				if(_g1.s == "if") {
					if(prev.token.parent.getFirstChild().index == prev.token.index) {
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
					}
				}
			}
			break;
		case 3:
			if(_g.s != "end") {
				policy = formatter_config_WhitespacePolicy.add(policy,"before");
			}
			break;
		case 21:
			if(prev.token.parent == null) {
				return policy;
			}
			let _g2 = prev.token.parent.tok;
			if(_g2._hx_index == 3) {
				if(_g2.s == "if") {
					if(prev.token.parent.getFirstChild().index == prev.token.index) {
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
					}
				}
			}
			break;
		default:
		}
		return policy;
	}
	markSemicolon(token) {
		let next = this.getNextToken(token);
		let policy = this.config.whitespace.semicolonPolicy;
		if(next != null) {
			if(next.token.tok._hx_index == 19) {
				policy = formatter_config_WhitespacePolicy.remove(policy,"after");
			}
		}
		this.whitespace(token,policy);
	}
	markSharp(token) {
		let _g = token.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "else":
				this.whitespace(token,"around");
				break;
			case "elseif":
				this.whitespace(token,"around");
				break;
			case "end":
				let prev = this.getPreviousToken(token);
				if(prev != null) {
					switch(prev.token.tok._hx_index) {
					case 16:case 18:case 20:
						break;
					default:
						this.whitespace(token,"before");
					}
				}
				let next = this.getNextToken(token);
				if(next != null) {
					switch(next.token.tok._hx_index) {
					case 1:
						this.whitespace(token,"after");
						break;
					case 2:
						this.whitespace(token,"after");
						break;
					case 10:case 15:
						break;
					case 16:case 18:case 20:case 22:
						this.whitespace(token,"after");
						break;
					default:
					}
				}
				break;
			case "error":
				this.whitespace(token,"around");
				break;
			case "if":
				this.whitespace(token,"after");
				let prev1 = this.getPreviousToken(token);
				if(prev1 != null) {
					switch(prev1.token.tok._hx_index) {
					case 1:
						this.whitespace(token,"before");
						break;
					case 2:
						this.whitespace(token,"before");
						break;
					case 6:
						this.whitespace(token,"before");
						break;
					default:
					}
				}
				if(this.getNextToken(token) != null) {
					let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.getFirstChild());
					if(lastChild != null) {
						this.whitespace(lastChild,"after");
					}
				}
				break;
			default:
			}
		}
	}
	markArrow(token) {
		let arrowType = tokentree_utils_TokenTreeCheckUtils.getArrowType(token);
		if(arrowType == null) {
			arrowType = tokentree_utils_ArrowType.ArrowFunction;
		}
		switch(arrowType._hx_index) {
		case 0:
			this.whitespace(token,this.config.whitespace.arrowFunctionsPolicy);
			break;
		case 1:
			this.whitespace(token,this.config.whitespace.functionTypeHaxe3Policy);
			break;
		case 2:
			this.whitespace(token,this.config.whitespace.functionTypeHaxe4Policy);
			break;
		}
	}
	determinePOpenPolicy(token) {
		let type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(token);
		if(type == null) {
			type = tokentree_utils_POpenType.Expression;
		}
		switch(type._hx_index) {
		case 0:
			this.config.whitespace.parenConfig.metadataParens.openingPolicy = formatter_config_WhitespacePolicy.remove(this.config.whitespace.parenConfig.metadataParens.openingPolicy,"before");
			return this.config.whitespace.parenConfig.metadataParens;
		case 1:
			let _g = token.parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 10:
					let policy = { openingPolicy : this.config.whitespace.parenConfig.anonFuncParamParens.openingPolicy, closingPolicy : this.config.whitespace.parenConfig.anonFuncParamParens.closingPolicy, removeInnerWhenEmpty : this.config.whitespace.parenConfig.anonFuncParamParens.removeInnerWhenEmpty};
					switch(policy.openingPolicy) {
					case "after":
						policy.openingPolicy = "around";
						break;
					case "around":
						break;
					case "before":
						break;
					case "none":
						policy.openingPolicy = "before";
						break;
					case "noneAfter":
						policy.openingPolicy = "onlyBefore";
						break;
					case "noneBefore":
						policy.openingPolicy = "before";
						break;
					case "onlyAfter":
						policy.openingPolicy = "around";
						break;
					case "onlyBefore":
						break;
					}
					return policy;
				case 22:
					return this.config.whitespace.parenConfig.funcParamParens;
				default:
					return this.config.whitespace.parenConfig.anonFuncParamParens;
				}
				break;
			case 2:
				if(_g.c._hx_index == 3) {
					return this.config.whitespace.parenConfig.funcParamParens;
				} else {
					return this.config.whitespace.parenConfig.anonFuncParamParens;
				}
				break;
			default:
				return this.config.whitespace.parenConfig.anonFuncParamParens;
			}
			break;
		case 2:
			return this.config.whitespace.parenConfig.callParens;
		case 3:
			if(this.config.whitespace.parenConfig.switchConditionParens != null) {
				return this.config.whitespace.parenConfig.switchConditionParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 4:
			if(this.config.whitespace.parenConfig.whileConditionParens != null) {
				return this.config.whitespace.parenConfig.whileConditionParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 5:
			if(this.config.whitespace.parenConfig.ifConditionParens != null) {
				return this.config.whitespace.parenConfig.ifConditionParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 6:
			if(this.config.whitespace.parenConfig.sharpConditionParens != null) {
				return this.config.whitespace.parenConfig.sharpConditionParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 7:
			if(this.config.whitespace.parenConfig.catchParens != null) {
				return this.config.whitespace.parenConfig.catchParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 8:
			return this.config.whitespace.parenConfig.forLoopParens;
		case 9:
			return this.config.whitespace.parenConfig.expressionParens;
		}
	}
	markPOpen(token) {
		let openClosePolicy = this.determinePOpenPolicy(token);
		let policy = openClosePolicy.openingPolicy;
		let prev = this.getPreviousToken(token);
		if(prev != null) {
			switch(prev.token.tok._hx_index) {
			case 5:
				policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				break;
			case 6:
				if(prev.spacesAfter > 0) {
					policy = formatter_config_WhitespacePolicy.add(policy,"before");
				}
				break;
			case 7:
				if(prev.spacesAfter > 0) {
					policy = formatter_config_WhitespacePolicy.add(policy,"before");
				}
				break;
			default:
			}
		}
		if(openClosePolicy.removeInnerWhenEmpty) {
			let next = this.getNextToken(token);
			if(next != null) {
				if(next.token.tok._hx_index == 21) {
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				}
			}
		}
		this.successiveParenthesis(token,false,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	markPClose(token) {
		let openClosePolicy = this.determinePOpenPolicy(token.parent);
		let policy = openClosePolicy.closingPolicy;
		if(openClosePolicy.removeInnerWhenEmpty) {
			let prev = this.getPreviousToken(token);
			if(prev != null) {
				if(prev.token.tok._hx_index == 20) {
					policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				}
			}
		}
		this.successiveParenthesis(token,true,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	determineBrOpenPolicy(token) {
		let type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token);
		if(type == null) {
			type = tokentree_utils_BrOpenType.Unknown;
		}
		switch(type._hx_index) {
		case 0:
			return this.config.whitespace.bracesConfig.blockBraces;
		case 1:
			return this.config.whitespace.bracesConfig.typedefBraces;
		case 2:
			return this.config.whitespace.bracesConfig.objectLiteralBraces;
		case 3:
			return this.config.whitespace.bracesConfig.anonTypeBraces;
		case 4:
			return this.config.whitespace.bracesConfig.unknownBraces;
		}
	}
	markBrOpen(token) {
		let openClosePolicy = this.determineBrOpenPolicy(token);
		let policy = openClosePolicy.openingPolicy;
		if(openClosePolicy.removeInnerWhenEmpty) {
			let next = this.getNextToken(token);
			if(next != null) {
				if(next.token.tok._hx_index == 19) {
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				}
			}
		}
		this.successiveParenthesis(token,false,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	markBrClose(token) {
		let openClosePolicy = this.determineBrOpenPolicy(token.parent);
		let policy = openClosePolicy.closingPolicy;
		if(openClosePolicy.removeInnerWhenEmpty) {
			let prev = this.getPreviousToken(token);
			if(prev != null) {
				if(prev.token.tok._hx_index == 18) {
					policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				}
			}
		}
		this.successiveParenthesis(token,true,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	markComment(token) {
		let policy = "around";
		let prev = this.getPreviousToken(token);
		if(prev != null) {
			let _g = prev.token.tok;
			switch(_g._hx_index) {
			case 6:
				if(_g.op._hx_index == 9) {
					if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(prev.token)) {
						policy = formatter_config_WhitespacePolicy.remove(policy,"before");
					}
				}
				break;
			case 16:case 18:case 20:
				policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				break;
			default:
			}
		}
		let next = this.getNextToken(token);
		if(next != null) {
			switch(next.token.tok._hx_index) {
			case 15:
				policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				break;
			case 17:case 19:case 21:
				policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				break;
			default:
			}
		}
		this.whitespace(token,policy);
	}
	markAt(token) {
		let prev = this.getPreviousToken(token);
		if(prev == null) {
			return;
		}
		switch(prev.whitespaceAfter._hx_index) {
		case 0:
			break;
		case 1:case 2:
			return;
		}
		let _g = prev.token.tok;
		switch(_g._hx_index) {
		case 0:
			return;
		case 1:
			break;
		case 2:
			break;
		case 3:
			break;
		case 4:
			break;
		case 5:
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(prev.token)) {
					return;
				}
			}
			break;
		case 7:
			return;
		case 8:
			return;
		case 9:
			break;
		case 10:
			return;
		case 11:
			break;
		case 12:
			break;
		case 13:
			break;
		case 14:
			break;
		case 15:
			break;
		case 17:
			break;
		case 19:
			break;
		case 16:case 18:case 20:
			return;
		case 21:
			break;
		case 22:
			break;
		case 23:
			break;
		case 24:
			return;
		case 25:
			break;
		}
		this.whitespace(token,"before");
	}
}
formatter_marker_MarkWhitespace.__name__ = "formatter.marker.MarkWhitespace";
formatter_marker_MarkWhitespace.__super__ = formatter_marker_MarkerBase;
Object.assign(formatter_marker_MarkWhitespace.prototype, {
	__class__: formatter_marker_MarkWhitespace
});
class formatter_marker_wrapping_MarkWrappingBase extends formatter_marker_MarkerBase {
	constructor(config,parsedCode,indenter) {
		super(config,parsedCode,indenter);
		this.wrappingQueue = [];
	}
	noWrap(open,close) {
		let this1 = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(open,tokentree_TokenTreeDef.BrOpen)),tokentree_TokenTreeDef.DblDot);
		if(this1 != null) {
			switch(tokentree_utils_TokenTreeCheckUtils.getColonType(this1)._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				break;
			case 3:
				break;
			case 4:
				this.noLineEndBefore(open);
				break;
			case 5:
				break;
			case 6:
				break;
			}
		}
		this.noWrappingBetween(open,close);
		if(open.children != null) {
			let _g = 0;
			let _g1 = open.children;
			_hx_loop1: while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				let _g2 = child.tok;
				switch(_g2._hx_index) {
				case 6:
					if(_g2.op._hx_index == 7) {
						continue;
					}
					break;
				case 10:case 15:
					continue;
				case 17:case 19:case 21:
					break _hx_loop1;
				default:
				}
				let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
				if(lastChild == null) {
					continue;
				} else {
					switch(lastChild.tok._hx_index) {
					case 10:case 15:
						this.noLineEndAfter(lastChild);
						break;
					default:
					}
				}
			}
		}
		this.noLineEndBefore(close);
	}
	keep2(open,close,items,addIndent,location) {
		let tokens = [];
		let _g = [];
		let _g1 = 0;
		while(_g1 < items.length) _g.push(items[_g1++].last);
		tokens = _g;
		if(items.length > 0) {
			_g.unshift(items[0].first);
		}
		let _g2 = [];
		let _g3 = 0;
		while(_g3 < items.length) _g2.push(items[_g3++].first);
		tokens = _g.concat(_g2);
		if(close != null) {
			tokens.push(close);
		}
		tokens.push(close);
		let _g4 = 0;
		while(_g4 < tokens.length) {
			let token = tokens[_g4];
			++_g4;
			if(this.parsedCode.isOriginalNewlineBefore(token)) {
				this.lineEndBefore(token);
				this.additionalIndent(token,addIndent);
			} else {
				this.noLineEndBefore(token);
				this.wrapBefore(token,false);
			}
		}
	}
	keep(open,close,addIndent) {
		this.noWrappingBetween(open,close);
		if(open.children != null) {
			let _g = 0;
			let _g1 = open.children;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				let last = false;
				let _g2 = child.tok;
				switch(_g2._hx_index) {
				case 6:
					if(_g2.op._hx_index == 7) {
						continue;
					}
					break;
				case 10:case 15:
					continue;
				case 17:case 19:case 21:
					last = true;
					break;
				default:
				}
				if(this.parsedCode.isOriginalNewlineBefore(child)) {
					this.lineEndBefore(child);
					this.additionalIndent(child,addIndent);
				} else {
					this.noLineEndBefore(child);
					this.wrapBefore(child,false);
				}
				if(last) {
					break;
				}
			}
		}
		if(!this.parsedCode.isOriginalNewlineBefore(open)) {
			this.noLineEndBefore(open);
		}
	}
	wrapChildOneLineEach2(open,close,items,addIndent,location,keepFirst) {
		if(keepFirst == null) {
			keepFirst = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		switch(location) {
		case "afterLast":
			let _g = 0;
			while(_g < items.length) {
				let item = items[_g];
				++_g;
				this.additionalIndent(item.first,addIndent);
				this.lineEndBefore(item.first);
			}
			break;
		case "beforeLast":
			let item = items[0];
			this.additionalIndent(item.first,addIndent);
			this.lineEndBefore(item.first);
			item = items.pop();
			let _g1 = 0;
			while(_g1 < items.length) {
				let it = items[_g1];
				++_g1;
				this.additionalIndent(it.last,addIndent);
				this.lineEndBefore(it.last);
			}
			items.push(item);
			break;
		}
		if(keepFirst) {
			if(open != null) {
				this.noLineEndAfter(open);
			}
			let lastToken = items[items.length - 1].last;
			if(lastToken.tok._hx_index != 10) {
				let next = this.getNextToken(lastToken);
				if(next == null) {
					this.noLineEndAfter(lastToken);
					return;
				}
				let _g = next.token.tok;
				switch(_g._hx_index) {
				case 1:
					switch(_g.k._hx_index) {
					case 22:case 23:case 37:
						this.noLineEndAfter(lastToken);
						break;
					default:
					}
					break;
				case 10:
					break;
				default:
					this.noLineEndAfter(lastToken);
				}
			}
		} else {
			let lastToken = items[items.length - 1].last;
			let next = this.getNextToken(lastToken);
			if(next == null) {
				this.lineEndAfter(lastToken);
				return;
			}
			let _g = next.token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 22:case 23:case 37:
					this.lineEndAfter(lastToken);
					break;
				default:
				}
				break;
			case 10:
				break;
			case 15:
				break;
			case 16:case 18:case 20:
				break;
			default:
				this.lineEndAfter(lastToken);
			}
		}
	}
	wrapChildOneLineEach(open,close,addIndent,keepFirst) {
		if(keepFirst == null) {
			keepFirst = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(!keepFirst) {
			this.lineEndAfter(open);
		}
		if(open.children == null) {
			return;
		}
		let _g = 0;
		let _g1 = open.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 3:
				this.wrapChildOneLineEachSharp(child,addIndent,keepFirst);
				break;
			case 6:
				if(_g2.op._hx_index == 7) {
					if(keepFirst) {
						this.noLineEndBefore(child);
					}
					return;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 8:
				let prev = this.getPreviousToken(child);
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(child,prev.token)) {
						this.noLineEndBefore(child);
					}
				}
				this.lineEndAfter(child);
				this.additionalIndent(child,addIndent);
				continue;
			case 17:case 19:case 21:
				if(keepFirst) {
					this.noLineEndBefore(child);
				}
				return;
			default:
				this.additionalIndent(child,addIndent);
			}
			let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
			if(lastChild == null) {
				this.lineEndAfter(child);
			} else {
				this.lineEndAfter(lastChild);
			}
		}
		if(close == null) {
			return;
		}
		switch(close.tok._hx_index) {
		case 17:case 19:case 21:
			this.lineEndBefore(close);
			break;
		default:
		}
	}
	wrapChildOneLineEachSharp(sharp,addIndent,keepFirst) {
		if(keepFirst == null) {
			keepFirst = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		let children = sharp.children;
		let skipFirst = false;
		this.lineEndBefore(sharp);
		let _g = sharp.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "else":
				this.lineEndAfter(sharp);
				break;
			case "elseif":
				this.lineEndAfter(tokentree_utils_TokenTreeCheckUtils.getLastToken(sharp.getFirstChild()));
				skipFirst = true;
				break;
			case "end":
				this.lineEndAfter(sharp);
				return;
			case "if":
				this.lineEndAfter(tokentree_utils_TokenTreeCheckUtils.getLastToken(sharp.getFirstChild()));
				skipFirst = true;
				break;
			default:
			}
		}
		let _g1 = 0;
		while(_g1 < children.length) {
			let child = children[_g1];
			++_g1;
			if(skipFirst) {
				skipFirst = false;
				continue;
			}
			let _g = child.tok;
			switch(_g._hx_index) {
			case 3:
				this.wrapChildOneLineEachSharp(child,addIndent,keepFirst);
				break;
			case 6:
				if(_g.op._hx_index == 7) {
					if(keepFirst) {
						this.whitespace(child,"noneBefore");
					}
					return;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 8:
				let prev = this.getPreviousToken(child);
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(child,prev.token)) {
						this.noLineEndBefore(child);
					}
				}
				this.lineEndAfter(child);
				this.additionalIndent(child,addIndent);
				continue;
			case 17:case 19:case 21:
				if(keepFirst) {
					this.whitespace(child,"noneBefore");
				}
				return;
			default:
				this.additionalIndent(child,addIndent);
			}
		}
	}
	wrapFillLine2AfterLast(open,close,items,maxLineLength,addIndent,useTrailing) {
		if(useTrailing == null) {
			useTrailing = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		let lineStart = open;
		if(open == null) {
			lineStart = items[0].first;
		}
		lineStart = this.findLineStartToken(lineStart);
		if(lineStart == null) {
			return;
		}
		let indent = this.indenter.calcIndent(lineStart);
		let lineLength = this.calcLineLengthBefore(open) + this.indenter.calcAbsoluteIndent(indent) + this.calcTokenLength(open);
		let _g = 0;
		while(_g < items.length) {
			let item = items[_g];
			++_g;
			let tokenLength = item.firstLineLength;
			if(lineLength + tokenLength >= maxLineLength) {
				this.lineEndBefore(item.first);
				this.additionalIndent(item.first,addIndent);
				lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
				if(item.multiline) {
					lineLength = item.lastLineLength;
				} else {
					lineLength += item.firstLineLength;
				}
				continue;
			} else {
				this.noLineEndBefore(item.first);
				lineLength += tokenLength;
				if(item.multiline) {
					lineLength = item.lastLineLength;
				}
			}
		}
		if(useTrailing) {
			let lastItem = items[items.length - 1];
			if(lineLength + this.calcLineLengthAfter(lastItem.last) >= maxLineLength) {
				this.lineEndBefore(lastItem.first);
				this.additionalIndent(lastItem.first,addIndent);
			}
		}
		this.noLineEndAfter(open);
		this.wrapAfter(open,false);
	}
	wrapFillLineWithLeading2AfterLast(open,close,items,maxLineLength,addIndent) {
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		let lineStart = open;
		if(open == null) {
			lineStart = items[0].first;
		}
		lineStart = this.findLineStartToken(lineStart);
		if(lineStart == null) {
			return;
		}
		let indent = this.indenter.calcIndent(lineStart);
		let lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
		let first = true;
		let _g = 0;
		while(_g < items.length) {
			let item = items[_g];
			++_g;
			let tokenLength = item.firstLineLength;
			if(lineLength + tokenLength >= maxLineLength) {
				this.lineEndBefore(item.first);
				this.additionalIndent(item.first,addIndent);
				lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
				if(item.multiline) {
					lineLength = item.lastLineLength;
				} else {
					lineLength += item.firstLineLength;
				}
				continue;
			} else {
				if(!first) {
					this.noLineEndBefore(item.first);
				} else {
					this.lineEndBefore(item.first);
				}
				lineLength += tokenLength;
				first = false;
				if(item.multiline) {
					lineLength = item.lastLineLength;
				}
			}
		}
		let lastItem = items[items.length - 1];
		switch(lastItem.last.tok._hx_index) {
		case 10:
			break;
		case 12:
			break;
		case 17:case 19:case 21:
			if(this.isNewLineAfter(lastItem.last)) {
				this.lineEndAfter(lastItem.last);
			}
			break;
		default:
			this.lineEndAfter(lastItem.last);
		}
	}
	wrapFillLine2BeforeLast(open,close,items,maxLineLength,addIndent,useTrailing) {
		if(useTrailing == null) {
			useTrailing = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		let lineStart = open;
		if(open == null) {
			lineStart = items[0].first;
		}
		lineStart = this.findLineStartToken(lineStart);
		if(lineStart == null) {
			return;
		}
		let indent = this.indenter.calcIndent(lineStart);
		let lineLength = this.calcLineLengthBefore(open) + this.indenter.calcAbsoluteIndent(indent) + this.calcTokenLength(open);
		let first = true;
		let _g = 0;
		while(_g < items.length) {
			let item = items[_g];
			++_g;
			let tokenLength = item.firstLineLength;
			if(!first && lineLength + tokenLength >= maxLineLength) {
				lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
				let prev = this.getPreviousToken(item.first);
				if(prev != null) {
					this.lineEndBefore(prev.token);
					this.additionalIndent(prev.token,addIndent);
					lineLength += prev.text.length;
				}
				if(item.multiline) {
					lineLength += item.lastLineLength;
				} else {
					lineLength += item.firstLineLength;
				}
				continue;
			} else {
				if(first) {
					this.noLineEndBefore(item.first);
				} else {
					let prev = this.getPreviousToken(item.first);
					if(prev != null) {
						this.noLineEndBefore(prev.token);
					}
				}
				lineLength += tokenLength;
				first = false;
				if(item.multiline) {
					lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent) + item.lastLineLength;
				}
			}
		}
		if(useTrailing) {
			let lastItem = items[items.length - 1];
			let lengthAfter = this.calcLineLengthAfter(lastItem.last);
			let prev = this.getPreviousToken(lastItem.first);
			if(prev != null && lineLength + lengthAfter >= maxLineLength) {
				this.lineEndBefore(prev.token);
				this.additionalIndent(prev.token,addIndent);
			}
		}
		this.noLineEndAfter(open);
		this.wrapAfter(open,false);
	}
	wrapFillLine(open,close,maxLineLength,addIndent,useTrailing) {
		if(useTrailing == null) {
			useTrailing = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		let lineStart = this.findLineStartToken(open);
		if(lineStart == null) {
			return;
		}
		let indent = this.indenter.calcIndent(lineStart);
		let lineLength = this.calcLineLengthBefore(open) + this.indenter.calcAbsoluteIndent(indent + addIndent);
		let first = true;
		if(open.children == null) {
			return;
		}
		let _g = 0;
		let _g1 = open.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 1:
				if(_g2.k._hx_index == 0) {
					continue;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 6:
				if(_g2.op._hx_index == 7) {
					this.whitespace(child,"noneBefore");
					return;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 8:
				let prev = this.getPreviousToken(child);
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(child,prev.token)) {
						this.noLineEndBefore(child);
					}
				}
				this.lineEndAfter(child);
				this.additionalIndent(child,addIndent);
				continue;
			case 17:case 19:case 21:
				this.whitespace(child,"noneBefore");
				if(useTrailing) {
					if(this.calcLineLengthAfter(child) + lineLength > maxLineLength) {
						let prev = child.previousSibling;
						if(prev == null) {
							return;
						}
						this.lineEndBefore(prev);
						this.additionalIndent(prev,addIndent);
					}
				}
				return;
			case 18:
				continue;
			default:
				this.additionalIndent(child,addIndent);
			}
			let tokenLength = this.calcLength(child);
			let lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
			if(lastChild == null) {
				lastChild = child;
			}
			lineLength += tokenLength;
			if(lineLength > maxLineLength) {
				this.lineEndBefore(child);
				this.noLineEndAfter(lastChild);
				indent = this.indenter.calcIndent(child);
				lineLength = tokenLength + this.indenter.calcAbsoluteIndent(indent);
			} else {
				this.noLineEndAfter(lastChild);
			}
			if(first) {
				first = false;
				this.noLineEndBefore(child);
			}
		}
	}
	calcLineLength(token) {
		let indent = this.indenter.calcIndent(token);
		return super.calcLineLength(token) + this.indenter.calcAbsoluteIndent(indent);
	}
	hasEmptyFunctionBody(token) {
		if(token.getLastChild().tok._hx_index == 10) {
			return true;
		}
		let body = token.nextSibling;
		if(body == null) {
			return true;
		}
		if(body.tok._hx_index == 12) {
			body = body.nextSibling;
		}
		while(body != null && body.tok._hx_index == 23) body = body.nextSibling;
		if(body == null) {
			return true;
		}
		switch(body.tok._hx_index) {
		case 10:
			return true;
		case 18:
			let brClose = body.getFirstChild();
			if(brClose == null) {
				return false;
			}
			if(brClose.tok._hx_index == 19) {
				return true;
			} else {
				return false;
			}
			break;
		default:
			return false;
		}
	}
	makeWrappableItems(token) {
		let items = [];
		let lastIndex = -1;
		if(token.children == null) {
			return items;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 6:
				if(_g2.op._hx_index == 7) {
					return items;
				}
				break;
			case 17:case 19:case 21:
				return items;
			default:
			}
			if(child.index <= lastIndex) {
				continue;
			}
			let endToken = this.findItemEnd(child);
			if(endToken == null) {
				continue;
			}
			lastIndex = endToken.index;
			let sameLine = this.isSameLineBetween(child,endToken,false);
			let firstLineLength = this.calcLengthUntilNewline(child,endToken);
			if(this.isMultilineToken(endToken)) {
				sameLine = false;
			}
			let lastLineLength = 0;
			if(!sameLine) {
				lastLineLength = this.calcLineLengthAfter(endToken);
			}
			items.push({ first : child, last : endToken, multiline : !sameLine, firstLineLength : firstLineLength, lastLineLength : lastLineLength});
		}
		return items;
	}
	findItemEnd(child) {
		let endToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
		if(endToken == null) {
			return null;
		}
		if(endToken.index == child.index) {
			switch(child.tok._hx_index) {
			case 7:
				let next = child.nextSibling;
				if(next != null) {
					return this.findItemEnd(next);
				}
				break;
			case 8:
				let next1 = child.nextSibling;
				if(next1 != null) {
					return this.findItemEnd(next1);
				}
				break;
			default:
			}
		}
		if(endToken.tok._hx_index == 15) {
			let next = this.getNextToken(endToken);
			if(next == null) {
				return endToken;
			}
			switch(next.token.tok._hx_index) {
			case 7:
				if(this.parsedCode.isOriginalSameLine(endToken,next.token)) {
					return next.token;
				}
				break;
			case 8:
				if(this.parsedCode.isOriginalSameLine(endToken,next.token)) {
					return next.token;
				}
				break;
			default:
			}
			return endToken;
		}
		let next2 = this.getNextToken(endToken);
		if(next2 == null) {
			return endToken;
		}
		let _g = next2.token.tok;
		switch(_g._hx_index) {
		case 6:
			if(_g.op._hx_index == 7) {
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(next2.token),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt)) != null) {
					return endToken;
				}
				return this.findItemEnd(next2.token);
			} else {
				return this.findItemEnd(next2.token);
			}
			break;
		case 7:
			return this.findItemEnd(next2.token);
		case 8:
			return this.findItemEnd(next2.token);
		default:
		}
		return endToken;
	}
	determineWrapType2(rules,token,items) {
		let itemCount = items.length;
		if(items.length <= 0) {
			return { conditions : [], type : rules.defaultWrap, location : rules.defaultLocation, additionalIndent : rules.defaultAdditionalIndent};
		}
		let maxItemLength = 0;
		let totalItemLength = 0;
		let lineLength = this.calcLineLength(token);
		let hasMultiLineItem = false;
		let _g = 0;
		while(_g < items.length) {
			let item = items[_g];
			++_g;
			totalItemLength += item.firstLineLength + item.lastLineLength;
			if(item.multiline) {
				hasMultiLineItem = true;
			}
			let length = Math.floor(Math.max(item.firstLineLength,item.lastLineLength));
			if(length > maxItemLength) {
				maxItemLength = length;
			}
		}
		let _g1 = 0;
		let _g2 = rules.rules;
		while(_g1 < _g2.length) {
			let rule = _g2[_g1];
			++_g1;
			if(this.matchesRule(rule,itemCount,maxItemLength,totalItemLength,lineLength,hasMultiLineItem)) {
				return rule;
			}
		}
		return { conditions : [], type : rules.defaultWrap, location : rules.defaultLocation, additionalIndent : rules.defaultAdditionalIndent};
	}
	determineWrapType(rules,itemCount,maxItemLength,totalItemLength,lineLength) {
		let _g = 0;
		let _g1 = rules.rules;
		while(_g < _g1.length) {
			let rule = _g1[_g];
			++_g;
			if(this.matchesRule(rule,itemCount,maxItemLength,totalItemLength,lineLength,false)) {
				return rule;
			}
		}
		return { conditions : [], type : rules.defaultWrap, location : rules.defaultLocation, additionalIndent : rules.defaultAdditionalIndent};
	}
	matchesRule(rule,itemCount,maxItemLength,totalItemLength,lineLength,hasMultiLineItem) {
		let _g = 0;
		let _g1 = rule.conditions;
		while(_g < _g1.length) {
			let cond = _g1[_g];
			++_g;
			switch(cond.cond) {
			case "anyItemLength <= n":
				if(maxItemLength > cond.value) {
					return false;
				}
				break;
			case "anyItemLength >= n":
				if(maxItemLength < cond.value) {
					return false;
				}
				break;
			case "exceedsMaxLineLength":
				if(cond.value == 1) {
					if(lineLength <= this.config.wrapping.maxLineLength) {
						return false;
					}
				} else if(lineLength > this.config.wrapping.maxLineLength) {
					return false;
				}
				break;
			case "hasMultilineItems":
				if(cond.value == 1) {
					if(!hasMultiLineItem) {
						return false;
					}
				} else if(hasMultiLineItem) {
					return false;
				}
				break;
			case "itemCount <= n":
				if(itemCount > cond.value) {
					return false;
				}
				break;
			case "itemCount >= n":
				if(itemCount < cond.value) {
					return false;
				}
				break;
			case "lineLength <= n":
				if(lineLength > cond.value) {
					return false;
				}
				break;
			case "lineLength >= n":
				if(lineLength < cond.value) {
					return false;
				}
				break;
			case "totalItemLength <= n":
				if(totalItemLength > cond.value) {
					return false;
				}
				break;
			case "totalItemLength >= n":
				if(totalItemLength < cond.value) {
					return false;
				}
				break;
			}
		}
		return true;
	}
	applyRule(origin,rule,open,close,items,addIndent,useTrailing) {
		let location = "afterLast";
		if(rule.location != null) {
			location = rule.location;
		}
		switch(rule.type) {
		case "equalNumber":
			break;
		case "fillLine":
			switch(location) {
			case "afterLast":
				this.wrapFillLine2AfterLast(open,close,items,this.config.wrapping.maxLineLength,addIndent,useTrailing);
				break;
			case "beforeLast":
				this.wrapFillLine2BeforeLast(open,close,items,this.config.wrapping.maxLineLength,addIndent,useTrailing);
				break;
			}
			break;
		case "fillLineWithLeadingBreak":
			switch(location) {
			case "afterLast":
				this.wrapFillLineWithLeading2AfterLast(open,close,items,this.config.wrapping.maxLineLength,addIndent);
				break;
			case "beforeLast":
				this.wrapFillLine2BeforeLast(open,close,items,this.config.wrapping.maxLineLength,addIndent,useTrailing);
				break;
			}
			break;
		case "keep":
			this.keep2(open,close,items,addIndent,location);
			break;
		case "noWrap":
			this.noWrappingBetween(open,close,false);
			break;
		case "onePerLine":
			this.wrapChildOneLineEach2(open,close,items,addIndent,location);
			break;
		case "onePerLineAfterFirst":
			this.wrapChildOneLineEach2(open,close,items,addIndent,location,true);
			break;
		}
	}
	applyWrappingQueue() {
		let _g = 0;
		let _g1 = this.wrappingQueue;
		while(_g < _g1.length) this.applyWrappingPlace(_g1[_g++]);
	}
	applyWrappingPlace(place) {
		let rule = this.determineWrapType2(place.rules,place.start,place.items);
		let additionalIndent = rule.additionalIndent;
		if(place.overrideAdditionalIndent != null) {
			additionalIndent = place.overrideAdditionalIndent;
		}
		this.applyRule(place.origin,rule,place.start,place.end,place.items,additionalIndent,place.useTrailing);
	}
	queueWrapping(place,name) {
		if(place.items == null || place.items.length <= 0) {
			return;
		}
		let startIndex = this.getPlaceStartIndex(place);
		let endIndex = this.getPlaceEndIndex(place);
		if(startIndex < 0 || endIndex < 0) {
			return;
		}
		let _g = 0;
		let _g1 = this.wrappingQueue.length;
		while(_g < _g1) {
			let index = _g++;
			let p = this.wrappingQueue[index];
			let itemStart = this.getPlaceStartIndex(p);
			if(startIndex > itemStart) {
				continue;
			}
			if(startIndex == itemStart) {
				if(endIndex > this.getPlaceEndIndex(p)) {
					this.wrappingQueue.splice(index,0,place);
					return;
				}
				continue;
			}
			this.wrappingQueue.splice(index,0,place);
			return;
		}
		this.wrappingQueue.push(place);
	}
	getPlaceStartIndex(place) {
		if(place.items == null || place.items.length <= 0) {
			return -1;
		}
		if(place.start != null) {
			return place.start.index;
		} else {
			return place.items[0].first.index;
		}
	}
	getPlaceEndIndex(place) {
		if(place.items == null || place.items.length <= 0) {
			return -1;
		}
		if(place.end != null) {
			return place.end.index;
		} else {
			return place.items[place.items.length - 1].last.index;
		}
	}
}
formatter_marker_wrapping_MarkWrappingBase.__name__ = "formatter.marker.wrapping.MarkWrappingBase";
formatter_marker_wrapping_MarkWrappingBase.__super__ = formatter_marker_MarkerBase;
Object.assign(formatter_marker_wrapping_MarkWrappingBase.prototype, {
	__class__: formatter_marker_wrapping_MarkWrappingBase
});
class formatter_marker_wrapping_MarkWrapping extends formatter_marker_wrapping_MarkWrappingBase {
	constructor(config,parsedCode,indenter) {
		super(config,parsedCode,indenter);
	}
	run() {
		let _gthis = this;
		let wrappableTokens = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 6:
				switch(_g.op._hx_index) {
				case 0:
					return tokentree_FilterResult.FoundGoDeeper;
				case 9:
					return tokentree_FilterResult.FoundGoDeeper;
				case 22:
					return tokentree_FilterResult.FoundGoDeeper;
				default:
				}
				break;
			case 8:
				return tokentree_FilterResult.FoundGoDeeper;
			case 11:
				return tokentree_FilterResult.FoundGoDeeper;
			case 14:
				return tokentree_FilterResult.FoundGoDeeper;
			case 15:
				_gthis.wrapAfter(token,true);
				return tokentree_FilterResult.GoDeeper;
			case 16:
				return tokentree_FilterResult.FoundGoDeeper;
			case 18:
				return tokentree_FilterResult.FoundGoDeeper;
			case 20:
				return tokentree_FilterResult.FoundGoDeeper;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
		wrappableTokens.reverse();
		let _g = 0;
		while(_g < wrappableTokens.length) {
			let token = wrappableTokens[_g];
			++_g;
			let _g1 = token.tok;
			switch(_g1._hx_index) {
			case 6:
				switch(_g1.op._hx_index) {
				case 0:
					this.wrapAfter(token,true);
					break;
				case 9:
					if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token)) {
						this.wrapTypeParameter(token);
					}
					break;
				case 22:
					this.wrapAfter(token,true);
					break;
				default:
				}
				break;
			case 8:
				this.wrapBefore(token,false);
				break;
			case 11:
				break;
			case 14:
				this.wrapAfter(token,true);
				break;
			case 16:
				this.arrayWrapping(token);
				break;
			case 18:
				this.markBrWrapping(token);
				break;
			case 20:
				this.markPWrapping(token);
				break;
			default:
			}
		}
		this.markMethodChaining(this.parsedCode.root);
		this.markMultiVarChaining();
		this.markImplementsExtendsChaining();
		this.markOpBoolChaining();
		this.markOpAddChaining();
		this.markCasePatternChaining();
		this.applyWrappingQueue();
	}
	wrapTypeParameter(token) {
		tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.TypeParameterWrapping, start : token, end : null, items : this.makeWrappableItems(token), rules : this.config.wrapping.typeParameter, useTrailing : true, overrideAdditionalIndent : null},"wrapTypeParameter");
	}
	markBrWrapping(token) {
		switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token)._hx_index) {
		case 0:
			break;
		case 1:
			this.typedefWrapping(token);
			break;
		case 2:
			this.objectLiteralWrapping(token);
			break;
		case 3:
			this.anonTypeWrapping(token);
			break;
		case 4:
			break;
		}
	}
	typedefWrapping(token) {
		let brClose = this.getCloseToken(token);
		if(this.isNewLineBefore(token)) {
			return;
		}
		if(this.parsedCode.isOriginalSameLine(token,brClose)) {
			this.noWrap(token,brClose);
			return;
		}
	}
	anonTypeWrapping(token) {
		let brClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		if(token.index + 1 == brClose.index) {
			this.whitespace(token,"noneAfter");
			this.whitespace(brClose,"noneBefore");
			return;
		}
		let next = this.getNextToken(brClose);
		if(next != null) {
			let _g = next.token.tok;
			switch(_g._hx_index) {
			case 1:
				this.lineEndAfter(brClose);
				break;
			case 2:
				let _gc = _g.c;
				if(_gc._hx_index == 3) {
					switch(_gc.s) {
					case "from":case "to":
						this.noLineEndAfter(brClose);
						break;
					default:
						this.lineEndAfter(brClose);
					}
				} else {
					this.lineEndAfter(brClose);
				}
				break;
			case 6:
				if(_g.op._hx_index == 7) {
					this.noLineEndAfter(brClose);
				}
				break;
			case 18:
				switch(this.config.lineEnds.leftCurly) {
				case "after":case "none":
					this.noLineEndAfter(brClose);
					break;
				case "before":case "both":
					break;
				}
				break;
			default:
			}
		}
		if(!this.parsedCode.isOriginalSameLine(token,brClose)) {
			this.wrapChildOneLineEach(token,brClose,0);
			return;
		}
		this.applyWrappingPlace({ origin : formatter_marker_wrapping_WrappingOrigin.AnonTypeWrapping, start : token, end : brClose, items : this.makeWrappableItems(token), rules : this.config.wrapping.anonType, useTrailing : true, overrideAdditionalIndent : null});
	}
	objectLiteralWrapping(token) {
		let brClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 1) {
			return;
		}
		if(token.index + 1 == brClose.index) {
			this.whitespace(token,"noneAfter");
			this.whitespace(brClose,"noneBefore");
			return;
		}
		if(!this.parsedCode.isOriginalSameLine(token,brClose)) {
			this.wrapChildOneLineEach(token,brClose,0);
			return;
		}
		let maxLength = 0;
		let totalLength = 0;
		let itemCount = 0;
		let _g = 0;
		let _g1 = token.children;
		_hx_loop1: while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			switch(child.tok._hx_index) {
			case 8:
				this.wrapChildOneLineEach(token,brClose,0);
				return;
			case 19:
				break _hx_loop1;
			default:
			}
			let length = this.calcLength(child);
			totalLength += length;
			if(length > maxLength) {
				maxLength = length;
			}
			++itemCount;
		}
		let lineLength = this.calcLineLength(token);
		let rule = this.determineWrapType(this.config.wrapping.objectLiteral,itemCount,maxLength,totalLength,lineLength);
		switch(rule.type) {
		case "equalNumber":
			break;
		case "fillLine":
			this.wrapFillLine(token,brClose,this.config.wrapping.maxLineLength,rule.additionalIndent);
			break;
		case "fillLineWithLeadingBreak":
			this.wrapFillLine(token,brClose,this.config.wrapping.maxLineLength,rule.additionalIndent);
			break;
		case "keep":
			this.keep(token,brClose,rule.additionalIndent);
			break;
		case "noWrap":
			this.noWrap(token,brClose);
			let next = this.getNextToken(brClose);
			if(next != null) {
				switch(next.token.tok._hx_index) {
				case 12:
					this.noLineEndAfter(brClose);
					break;
				case 11:case 15:
					this.whitespace(brClose,"noneAfter");
					break;
				default:
				}
			}
			let prev = this.getPreviousToken(token);
			if(prev != null) {
				switch(prev.token.tok._hx_index) {
				case 1:
					this.noLineEndBefore(token);
					this.whitespace(token,"before");
					break;
				case 6:
					this.noLineEndBefore(token);
					break;
				case 15:case 20:
					this.noLineEndBefore(token);
					break;
				default:
				}
			}
			break;
		case "onePerLine":
			this.wrapChildOneLineEach(token,brClose,rule.additionalIndent);
			break;
		case "onePerLineAfterFirst":
			this.wrapChildOneLineEach(token,brClose,rule.additionalIndent,true);
			break;
		}
	}
	markPWrapping(token) {
		this.getCloseToken(token);
		switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(token)._hx_index) {
		case 0:
			this.wrapMetadataCallParameter(token);
			break;
		case 1:
			this.wrapFunctionSignature(token);
			break;
		case 2:
			this.wrapCallParameter(token);
			break;
		case 3:
			break;
		case 4:
			break;
		case 5:
			break;
		case 6:
			break;
		case 7:
			break;
		case 8:
			break;
		case 9:
			break;
		}
	}
	arrayWrapping(token) {
		let bkClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		let items = this.makeWrappableItems(token);
		let itemsWithoutMetadata = [];
		let _g = 0;
		while(_g < items.length) {
			let item = items[_g];
			++_g;
			let _g1 = item.first.tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 5:case 7:
					if(this.config.sameLine.comprehensionFor == "keep") {
						return;
					}
					itemsWithoutMetadata.push(item);
					break;
				default:
					itemsWithoutMetadata.push(item);
				}
				break;
			case 23:
				if(item.firstLineLength > 30) {
					this.lineEndBefore(token);
					this.lineEndBefore(item.first);
				}
				break;
			default:
				itemsWithoutMetadata.push(item);
			}
		}
		if(this.config.wrapping.arrayMatrixWrap != "noMatrixWrap") {
			if(this.tryMatrixWrap(token,bkClose,itemsWithoutMetadata)) {
				return;
			}
		}
		this.applyWrappingPlace({ origin : formatter_marker_wrapping_WrappingOrigin.ArrayWrapping, start : token, end : bkClose, items : itemsWithoutMetadata, rules : this.config.wrapping.arrayWrap, useTrailing : true, overrideAdditionalIndent : null});
	}
	tryMatrixWrap(open,close,items) {
		let prev = null;
		let run = 1;
		let lineRun = 0;
		let _g = 0;
		let _g1 = items.length;
		while(_g < _g1) {
			let item = items[_g++];
			if(prev == null) {
				prev = item;
				continue;
			}
			if(item.multiline) {
				return false;
			}
			if(this.parsedCode.isOriginalSameLine(prev.first,item.first)) {
				++run;
				prev = item;
				continue;
			}
			if(lineRun != 0) {
				if(lineRun != run) {
					return false;
				}
			}
			lineRun = run;
			run = 1;
			prev = item;
		}
		if(lineRun <= 1) {
			return false;
		}
		if(lineRun != run) {
			return false;
		}
		this.lineEndAfter(open);
		if(this.config.wrapping.arrayMatrixWrap == "matrixWrapWithAlign") {
			let _g = [];
			let _g1 = 0;
			let _g2 = lineRun;
			while(_g1 < _g2) {
				++_g1;
				_g.push(0);
			}
			let _g3 = 0;
			let _g4 = items.length;
			while(_g3 < _g4) {
				let index = _g3++;
				let item = items[index];
				let col = index % lineRun;
				if(item.firstLineLength > _g[col]) {
					_g[col] = item.firstLineLength;
				}
			}
			let _g5 = 0;
			let _g6 = items.length;
			while(_g5 < _g6) {
				let index = _g5++;
				let item = items[index];
				let expectedLength = _g[index % lineRun];
				if(index == items.length - 1) {
					if(item.last.tok._hx_index == 15) {
						--expectedLength;
					} else {
						expectedLength -= 2;
					}
				}
				if(item.firstLineLength < expectedLength) {
					this.spacesBefore(item.first,expectedLength - item.firstLineLength);
				}
			}
		}
		let index = lineRun - 1;
		while(index < items.length) {
			this.lineEndAfter(items[index].last);
			index += lineRun;
		}
		return true;
	}
	calcLineLength(token) {
		if(token == null) {
			return 0;
		}
		return super.calcLineLength(token);
	}
	wrapFunctionSignature(token) {
		let pClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		let rules = this.config.wrapping.functionSignature;
		let _g = token.parent.tok;
		if(_g._hx_index == 1) {
			if(_g.k._hx_index == 0) {
				rules = this.config.wrapping.anonFunctionSignature;
			}
		}
		let emptyBody = this.hasEmptyFunctionBody(token);
		let items = this.makeWrappableItems(token);
		let addIndent = null;
		if(emptyBody) {
			addIndent = 0;
		}
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.FunctionSignatureWrapping, start : token, end : pClose, items : items, rules : rules, useTrailing : true, overrideAdditionalIndent : addIndent},"wrapFunctionSignature");
	}
	wrapCallParameter(token) {
		let pClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.CallParameterWrapping, start : token, end : pClose, items : this.makeWrappableItems(token), rules : this.config.wrapping.callParameter, useTrailing : true, overrideAdditionalIndent : null},"wrapCallParameter");
	}
	wrapMetadataCallParameter(token) {
		let pClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.MetadataCallParameterWrapping, start : token, end : pClose, items : this.makeWrappableItems(token), rules : this.config.wrapping.metadataCallParameter, useTrailing : false, overrideAdditionalIndent : null},"wrapMetadataCallParameter");
	}
	markMethodChaining(startToken) {
		if(startToken == null) {
			return;
		}
		let _gthis = this;
		let chainStarts = startToken.filterCallback(function(token,index) {
			if(token.tok._hx_index == 11) {
				let prev = _gthis.getPreviousToken(token);
				_hx_loop1: while(prev != null) {
					switch(prev.token.tok._hx_index) {
					case 7:
						break;
					case 8:
						break;
					case 21:
						_gthis.wrapBefore(token,true);
						return tokentree_FilterResult.FoundSkipSubtree;
					default:
						break _hx_loop1;
					}
					prev = _gthis.getPreviousToken(prev.token);
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
		let _g = 0;
		while(_g < chainStarts.length) {
			let chainStart = chainStarts[_g];
			++_g;
			this.markInternalMethodChaining(chainStart);
			this.markSingleMethodChain(chainStart);
		}
	}
	markInternalMethodChaining(startToken) {
		let _gthis = this;
		startToken.filterCallback(function(token,index) {
			switch(token.tok._hx_index) {
			case 16:case 18:case 20:
				_gthis.markMethodChaining(token);
				break;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	markSingleMethodChain(chainStart) {
		let _gthis = this;
		let chainedCalls = chainStart.filterCallback(function(token,index) {
			switch(token.tok._hx_index) {
			case 11:
				let prev = _gthis.getPreviousToken(token);
				_hx_loop1: while(prev != null) {
					switch(prev.token.tok._hx_index) {
					case 7:
						break;
					case 8:
						break;
					case 21:
						return tokentree_FilterResult.FoundGoDeeper;
					default:
						break _hx_loop1;
					}
					prev = _gthis.getPreviousToken(prev.token);
				}
				return tokentree_FilterResult.GoDeeper;
			case 16:case 18:case 20:
				return tokentree_FilterResult.SkipSubtree;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
		let this1 = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.parent(chainStart))),tokentree_TokenTreeDef.Dot);
		if(this1 != null) {
			chainedCalls.unshift(this1);
			chainStart = this1;
		}
		let items = [];
		let chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(chainStart);
		let info = this.getPreviousToken(chainStart);
		let chainOpen = chainStart.parent;
		if(info != null) {
			chainOpen = info.token;
		}
		let _g = 0;
		let _g1 = chainedCalls.length;
		while(_g < _g1) {
			let index = _g++;
			let child = chainedCalls[index];
			let endToken = chainEnd;
			if(index + 1 < chainedCalls.length) {
				info = this.getPreviousToken(chainedCalls[index + 1]);
				if(info != null) {
					endToken = info.token;
				}
			}
			items.push(this.makeWrappableItem(child,endToken));
		}
		chainEnd = null;
		if(chainOpen != null) {
			chainEnd = this.getCloseToken(chainOpen);
		}
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.MethodChainWrapping, start : chainOpen, end : chainEnd, items : items, rules : this.config.wrapping.methodChain, useTrailing : false, overrideAdditionalIndent : null},"markSingleMethodChain");
	}
	markOpBoolChaining() {
		let chainStarts = this.parsedCode.root.filterCallback(function(token,index) {
			if(!token.hasChildren()) {
				return tokentree_FilterResult.SkipSubtree;
			}
			let _g = 0;
			let _g1 = token.children;
			while(_g < _g1.length) {
				let _g2 = _g1[_g++].tok;
				if(_g2._hx_index == 6) {
					switch(_g2.op._hx_index) {
					case 14:case 15:
						return tokentree_FilterResult.FoundGoDeeper;
					default:
					}
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
		let _g = 0;
		while(_g < chainStarts.length) this.markSingleOpBoolChain(chainStarts[_g++]);
	}
	markSingleOpBoolChain(itemStart) {
		let items = [];
		let firstItemStart = itemStart;
		if(itemStart.tok._hx_index == 6) {
			if(itemStart.previousSibling != null) {
				firstItemStart = itemStart.previousSibling;
			}
		}
		let prev = this.getPreviousToken(firstItemStart);
		let chainStart = itemStart;
		if(prev != null) {
			chainStart = prev.token;
		}
		let chainEnd = itemStart.getLastChild();
		if(chainEnd != null) {
			chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(chainEnd);
			switch(chainEnd.tok._hx_index) {
			case 10:case 15:case 21:
				break;
			default:
				let next = this.getNextToken(chainEnd);
				if(next != null) {
					chainEnd = next.token;
				}
			}
		}
		let first = true;
		if(itemStart.children != null) {
			let _g = 0;
			let _g1 = itemStart.children;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				let _g2 = child.tok;
				if(_g2._hx_index == 6) {
					switch(_g2.op._hx_index) {
					case 14:case 15:
						if(first) {
							itemStart = firstItemStart;
							first = false;
						}
						items.push(this.makeWrappableItem(itemStart,child));
						let next = this.getNextToken(child);
						if(next == null) {
							return;
						}
						itemStart = next.token;
						break;
					default:
						continue;
					}
				} else {
					continue;
				}
			}
		}
		items.push(this.makeWrappableItem(itemStart,tokentree_utils_TokenTreeCheckUtils.getLastToken(itemStart)));
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.OpBoolChainWrapping, start : chainStart, end : chainEnd, items : items, rules : this.config.wrapping.opBoolChain, useTrailing : false, overrideAdditionalIndent : null},"markSingleOpBoolChain");
	}
	markCasePatternChaining() {
		let chainStarts = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 15) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < chainStarts.length) this.markSingleCasePatternChain(chainStarts[_g++]);
	}
	markSingleCasePatternChain(itemContainer) {
		let items = [];
		let this1 = tokentree_TokenTreeAccessHelper.firstOf(itemContainer,tokentree_TokenTreeDef.DblDot);
		if(this.getNextToken(itemContainer) == null) {
			return;
		}
		if(itemContainer.children != null) {
			let _g = 0;
			let _g1 = itemContainer.children;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				if(child.tok._hx_index == 12) {
					break;
				} else {
					items.push(this.makeWrappableItem(child,tokentree_utils_TokenTreeCheckUtils.getLastToken(child)));
				}
			}
		}
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.CasePatternWrapping, start : itemContainer, end : this1, items : items, rules : this.config.wrapping.casePattern, useTrailing : false, overrideAdditionalIndent : null},"markSingleCasePatternChain");
	}
	markOpAddChaining() {
		let chainStarts = this.parsedCode.root.filterCallback(function(token,index) {
			if(!token.hasChildren()) {
				return tokentree_FilterResult.SkipSubtree;
			}
			let _g = 0;
			let _g1 = token.children;
			while(_g < _g1.length) {
				let _g2 = _g1[_g++].tok;
				if(_g2._hx_index == 6) {
					switch(_g2.op._hx_index) {
					case 0:case 3:
						return tokentree_FilterResult.FoundGoDeeper;
					default:
					}
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
		let _g = 0;
		while(_g < chainStarts.length) this.markSingleOpAddChain(chainStarts[_g++]);
	}
	markSingleOpAddChain(itemContainer) {
		let items = [];
		this.getPreviousToken(this.findOpAddItemStart(itemContainer));
		let chainStart = this.findOpAddItemStart(itemContainer);
		let chainEnd = itemContainer.getLastChild();
		if(chainStart.tok._hx_index == 20) {
			switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(chainStart)._hx_index) {
			case 0:
				return;
			case 1:
				break;
			case 2:
				break;
			case 3:
				break;
			case 4:
				break;
			case 5:
				break;
			case 6:
				break;
			case 7:
				break;
			case 8:
				break;
			case 9:
				break;
			}
		}
		if(chainEnd != null) {
			chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(chainEnd);
			switch(chainEnd.tok._hx_index) {
			case 10:case 15:
				break;
			default:
				this.getNextToken(chainEnd);
			}
		}
		let next = this.getNextToken(chainStart);
		if(next == null) {
			return;
		}
		let itemStart = next.token;
		if(itemContainer.children != null) {
			let _g = 0;
			let _g1 = itemContainer.children;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				let _g2 = child.tok;
				if(_g2._hx_index == 6) {
					switch(_g2.op._hx_index) {
					case 0:case 3:
						items.push(this.makeWrappableItem(itemStart,child));
						let next = this.getNextToken(child);
						if(next == null) {
							continue;
						}
						itemStart = next.token;
						break;
					default:
						continue;
					}
				} else {
					continue;
				}
			}
		}
		items.push(this.makeWrappableItem(itemStart,tokentree_utils_TokenTreeCheckUtils.getLastToken(itemStart)));
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.OpAddChainWrapping, start : chainStart, end : null, items : items, rules : this.config.wrapping.opAddSubChain, useTrailing : false, overrideAdditionalIndent : null},"markSingleOpAddChain");
	}
	findOpAddItemStart(itemStart) {
		if(itemStart == null || itemStart.tok == tokentree_TokenTreeDef.Root) {
			return itemStart;
		}
		let parent = itemStart;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 23:case 29:case 37:
					break;
				default:
					return parent;
				}
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 4:
					return parent;
				case 20:
					return parent;
				default:
				}
				break;
			case 16:
				let this1 = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.BkClose);
				if(this1 == null || this1.index > itemStart.index) {
					return parent;
				}
				break;
			case 18:
				let this2 = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.BrClose);
				if(this2 == null || this2.index > itemStart.index) {
					return parent;
				}
				break;
			case 20:
				let this3 = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose);
				if(this3 == null || this3.index > itemStart.index) {
					return parent;
				}
				break;
			default:
			}
			itemStart = parent;
			parent = parent.parent;
		}
		return itemStart;
	}
	makeWrappableItem(start,end) {
		let sameLine = this.isSameLineBetween(start,end,false);
		let firstLineLength = 0;
		let lastLineLength = 0;
		if(sameLine) {
			firstLineLength = this.calcLengthBetween(start,end) + this.calcTokenLength(end);
		} else {
			firstLineLength = this.calcLengthUntilNewline(start,end);
			lastLineLength = this.calcLineLengthBefore(end) + this.calcTokenLength(end);
		}
		return { first : start, last : end, multiline : !sameLine, firstLineLength : firstLineLength, lastLineLength : lastLineLength};
	}
	markImplementsExtendsChaining() {
		let classesAndInterfaces = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 1:case 28:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 26:case 32:case 40:
					return tokentree_FilterResult.SkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < classesAndInterfaces.length) {
			let items = [];
			let impls = classesAndInterfaces[_g++].filterCallback(function(token,index) {
				let _g = token.tok;
				if(_g._hx_index == 1) {
					switch(_g.k._hx_index) {
					case 0:case 2:
						return tokentree_FilterResult.SkipSubtree;
					case 11:case 12:
						return tokentree_FilterResult.FoundSkipSubtree;
					default:
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			let _g1 = 0;
			while(_g1 < impls.length) {
				let impl = impls[_g1];
				++_g1;
				items.push(this.makeWrappableItem(impl,tokentree_utils_TokenTreeCheckUtils.getLastToken(impl)));
			}
			if(items.length <= 0) {
				continue;
			}
			let chainOpen = items[0].first;
			let prev = this.getPreviousToken(items[0].first);
			if(prev != null) {
				chainOpen = prev.token;
			}
			this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.ImplementsWrapping, start : chainOpen, end : items[items.length - 1].last, items : items, rules : this.config.wrapping.implementsExtends, useTrailing : false, overrideAdditionalIndent : null},"markImplementsExtendsChaining");
		}
	}
	markMultiVarChaining() {
		let allVars = this.parsedCode.root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 2) {
					if(token.hasChildren() && token.children.length > 1) {
						return tokentree_FilterResult.FoundSkipSubtree;
					}
					return tokentree_FilterResult.SkipSubtree;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < allVars.length) {
			let v = allVars[_g];
			++_g;
			let items = [];
			if(v.children == null) {
				continue;
			}
			let _g1 = 0;
			let _g2 = v.children;
			while(_g1 < _g2.length) {
				let child = _g2[_g1];
				++_g1;
				items.push(this.makeWrappableItem(child,tokentree_utils_TokenTreeCheckUtils.getLastToken(child)));
			}
			if(items.length <= 0) {
				continue;
			}
			this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.MultiVarWrapping, start : v, end : tokentree_utils_TokenTreeCheckUtils.getLastToken(v), items : items, rules : this.config.wrapping.multiVar, useTrailing : false, overrideAdditionalIndent : null},"markMultiVarChaining");
		}
	}
}
formatter_marker_wrapping_MarkWrapping.__name__ = "formatter.marker.wrapping.MarkWrapping";
formatter_marker_wrapping_MarkWrapping.__super__ = formatter_marker_wrapping_MarkWrappingBase;
Object.assign(formatter_marker_wrapping_MarkWrapping.prototype, {
	__class__: formatter_marker_wrapping_MarkWrapping
});
var formatter_marker_wrapping_WrappingOrigin = $hxEnums["formatter.marker.wrapping.WrappingOrigin"] = { __ename__:true,__constructs__:null
	,AnonTypeWrapping: {_hx_name:"AnonTypeWrapping",_hx_index:0,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,ArrayWrapping: {_hx_name:"ArrayWrapping",_hx_index:1,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,CallParameterWrapping: {_hx_name:"CallParameterWrapping",_hx_index:2,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,CasePatternWrapping: {_hx_name:"CasePatternWrapping",_hx_index:3,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,FunctionSignatureWrapping: {_hx_name:"FunctionSignatureWrapping",_hx_index:4,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,ImplementsWrapping: {_hx_name:"ImplementsWrapping",_hx_index:5,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,MetadataCallParameterWrapping: {_hx_name:"MetadataCallParameterWrapping",_hx_index:6,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,MethodChainWrapping: {_hx_name:"MethodChainWrapping",_hx_index:7,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,MultiVarWrapping: {_hx_name:"MultiVarWrapping",_hx_index:8,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,OpAddChainWrapping: {_hx_name:"OpAddChainWrapping",_hx_index:9,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,OpBoolChainWrapping: {_hx_name:"OpBoolChainWrapping",_hx_index:10,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,TypeParameterWrapping: {_hx_name:"TypeParameterWrapping",_hx_index:11,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
};
formatter_marker_wrapping_WrappingOrigin.__constructs__ = [formatter_marker_wrapping_WrappingOrigin.AnonTypeWrapping,formatter_marker_wrapping_WrappingOrigin.ArrayWrapping,formatter_marker_wrapping_WrappingOrigin.CallParameterWrapping,formatter_marker_wrapping_WrappingOrigin.CasePatternWrapping,formatter_marker_wrapping_WrappingOrigin.FunctionSignatureWrapping,formatter_marker_wrapping_WrappingOrigin.ImplementsWrapping,formatter_marker_wrapping_WrappingOrigin.MetadataCallParameterWrapping,formatter_marker_wrapping_WrappingOrigin.MethodChainWrapping,formatter_marker_wrapping_WrappingOrigin.MultiVarWrapping,formatter_marker_wrapping_WrappingOrigin.OpAddChainWrapping,formatter_marker_wrapping_WrappingOrigin.OpBoolChainWrapping,formatter_marker_wrapping_WrappingOrigin.TypeParameterWrapping];
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__:true,__constructs__:null
	,CFunction: {_hx_name:"CFunction",_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Module",$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="FilePos",$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="Method",$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_._hx_name="LocalFunction",$_.__params__ = ["v"],$_)
};
haxe_StackItem.__constructs__ = [haxe_StackItem.CFunction,haxe_StackItem.Module,haxe_StackItem.FilePos,haxe_StackItem.Method,haxe_StackItem.LocalFunction];
class haxe_CallStack {
	static callStack() {
		return haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.callStack());
	}
	static exceptionStack(fullStack) {
		if(fullStack == null) {
			fullStack = false;
		}
		let eStack = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.exceptionStack());
		return fullStack ? eStack : haxe_CallStack.subtract(eStack,haxe_CallStack.callStack());
	}
	static toString(stack) {
		let b = new StringBuf();
		let _g = 0;
		let _g1 = stack;
		while(_g < _g1.length) {
			let s = _g1[_g++];
			b.b += "\nCalled from ";
			haxe_CallStack.itemToString(b,s);
		}
		return b.b;
	}
	static subtract(this1,stack) {
		let startIndex = -1;
		let i = -1;
		while(++i < this1.length) {
			let _g = 0;
			let _g1 = stack.length;
			while(_g < _g1) if(haxe_CallStack.equalItems(this1[i],stack[_g++])) {
				if(startIndex < 0) {
					startIndex = i;
				}
				++i;
				if(i >= this1.length) {
					break;
				}
			} else {
				startIndex = -1;
			}
			if(startIndex >= 0) {
				break;
			}
		}
		if(startIndex >= 0) {
			return this1.slice(0,startIndex);
		} else {
			return this1;
		}
	}
	static equalItems(item1,item2) {
		if(item1 == null) {
			if(item2 == null) {
				return true;
			} else {
				return false;
			}
		} else {
			switch(item1._hx_index) {
			case 0:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 0) {
					return true;
				} else {
					return false;
				}
				break;
			case 1:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 1) {
					return item1.m == item2.m;
				} else {
					return false;
				}
				break;
			case 2:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 2) {
					if(item1.file == item2.file && item1.line == item2.line && item1.column == item2.column) {
						return haxe_CallStack.equalItems(item1.s,item2.s);
					} else {
						return false;
					}
				} else {
					return false;
				}
				break;
			case 3:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 3) {
					if(item1.classname == item2.classname) {
						return item1.method == item2.method;
					} else {
						return false;
					}
				} else {
					return false;
				}
				break;
			case 4:
				if(item2 == null) {
					return false;
				} else if(item2._hx_index == 4) {
					return item1.v == item2.v;
				} else {
					return false;
				}
				break;
			}
		}
	}
	static itemToString(b,s) {
		switch(s._hx_index) {
		case 0:
			b.b += "a C function";
			break;
		case 1:
			let _gm = s.m;
			b.b = (b.b += "module ") + (_gm == null ? "null" : "" + _gm);
			break;
		case 2:
			let _gs = s.s;
			let _gfile = s.file;
			let _gline = s.line;
			let _gcolumn = s.column;
			if(_gs != null) {
				haxe_CallStack.itemToString(b,_gs);
				b.b += " (";
			}
			b.b = (b.b += _gfile == null ? "null" : "" + _gfile) + " line ";
			b.b += _gline == null ? "null" : "" + _gline;
			if(_gcolumn != null) {
				b.b = (b.b += " column ") + (_gcolumn == null ? "null" : "" + _gcolumn);
			}
			if(_gs != null) {
				b.b += ")";
			}
			break;
		case 3:
			let _gclassname = s.classname;
			let _gmethod = s.method;
			b.b = (b.b += Std.string(_gclassname == null ? "<unknown>" : _gclassname)) + ".";
			b.b += _gmethod == null ? "null" : "" + _gmethod;
			break;
		case 4:
			let _gv = s.v;
			b.b = (b.b += "local function #") + (_gv == null ? "null" : "" + _gv);
			break;
		}
	}
}
class haxe_IMap {
}
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
		this.__skipStack = 0;
		let old = Error.prepareStackTrace;
		Error.prepareStackTrace = function(e) { return e.stack; }
		if(((native) instanceof Error)) {
			this.stack = native.stack;
		} else {
			let e = null;
			if(Error.captureStackTrace) {
				Error.captureStackTrace(this,haxe_Exception);
				e = this;
			} else {
				e = new Error();
				if(typeof(e.stack) == "undefined") {
					try { throw e; } catch(_) {}
					this.__skipStack++;
				}
			}
			this.stack = e.stack;
		}
		Error.prepareStackTrace = old;
	}
	unwrap() {
		return this.__nativeException;
	}
	toString() {
		return this.get_message();
	}
	details() {
		if(this.get_previous() == null) {
			let tmp = "Exception: " + this.toString();
			let tmp1 = this.get_stack();
			return tmp + (tmp1 == null ? "null" : haxe_CallStack.toString(tmp1));
		} else {
			let result = "";
			let e = this;
			let prev = null;
			while(e != null) {
				if(prev == null) {
					let result1 = "Exception: " + e.get_message();
					let tmp = e.get_stack();
					result = result1 + (tmp == null ? "null" : haxe_CallStack.toString(tmp)) + result;
				} else {
					let prevStack = haxe_CallStack.subtract(e.get_stack(),prev.get_stack());
					result = "Exception: " + e.get_message() + (prevStack == null ? "null" : haxe_CallStack.toString(prevStack)) + "\n\nNext " + result;
				}
				prev = e;
				e = e.get_previous();
			}
			return result;
		}
	}
	__shiftStack() {
		this.__skipStack++;
	}
	get_message() {
		return this.message;
	}
	get_previous() {
		return this.__previousException;
	}
	get_native() {
		return this.__nativeException;
	}
	get_stack() {
		let _g = this.__exceptionStack;
		if(_g == null) {
			let value = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.normalize(this.stack),this.__skipStack);
			this.setProperty("__exceptionStack",value);
			return value;
		} else {
			return _g;
		}
	}
	setProperty(name,value) {
		try {
			Object.defineProperty(this,name,{ value : value});
		} catch( _g ) {
			this[name] = value;
		}
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			e.__skipStack++;
			return e;
		}
	}
}
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.__super__ = Error;
Object.assign(haxe_Exception.prototype, {
	__class__: haxe_Exception
});
class haxe_Log {
	static formatOutput(v,infos) {
		let str = Std.string(v);
		if(infos == null) {
			return str;
		}
		let pstr = infos.fileName + ":" + infos.lineNumber;
		if(infos.customParams != null) {
			let _g = 0;
			let _g1 = infos.customParams;
			while(_g < _g1.length) str += ", " + Std.string(_g1[_g++]);
		}
		return pstr + ": " + str;
	}
	static trace(v,infos) {
		let str = haxe_Log.formatOutput(v,infos);
		if(typeof(console) != "undefined" && console.log != null) {
			console.log(str);
		}
	}
}
haxe_Log.__name__ = "haxe.Log";
class haxe_NativeStackTrace {
	static saveStack(e) {
		haxe_NativeStackTrace.lastError = e;
	}
	static callStack() {
		let e = new Error("");
		let stack = haxe_NativeStackTrace.tryHaxeStack(e);
		if(typeof(stack) == "undefined") {
			try {
				throw e;
			} catch( _g ) {
			}
			stack = e.stack;
		}
		return haxe_NativeStackTrace.normalize(stack,2);
	}
	static exceptionStack() {
		return haxe_NativeStackTrace.normalize(haxe_NativeStackTrace.tryHaxeStack(haxe_NativeStackTrace.lastError));
	}
	static toHaxe(s,skip) {
		if(skip == null) {
			skip = 0;
		}
		if(s == null) {
			return [];
		} else if(typeof(s) == "string") {
			let stack = s.split("\n");
			if(stack[0] == "Error") {
				stack.shift();
			}
			let m = [];
			let _g = 0;
			let _g1 = stack.length;
			while(_g < _g1) {
				let i = _g++;
				if(skip > i) {
					continue;
				}
				let line = stack[i];
				let matched = line.match(/^    at ([$A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
				if(matched != null) {
					let path = matched[1].split(".");
					if(path[0] == "$hxClasses") {
						path.shift();
					}
					let meth = path.pop();
					let file = matched[2];
					let line = Std.parseInt(matched[3]);
					let column = Std.parseInt(matched[4]);
					m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line,column));
				} else {
					m.push(haxe_StackItem.Module(StringTools.trim(line)));
				}
			}
			return m;
		} else if(skip > 0 && Array.isArray(s)) {
			return s.slice(skip);
		} else {
			return s;
		}
	}
	static tryHaxeStack(e) {
		if(e == null) {
			return [];
		}
		let oldValue = Error.prepareStackTrace;
		Error.prepareStackTrace = haxe_NativeStackTrace.prepareHxStackTrace;
		let stack = e.stack;
		Error.prepareStackTrace = oldValue;
		return stack;
	}
	static prepareHxStackTrace(e,callsites) {
		let stack = [];
		let _g = 0;
		while(_g < callsites.length) {
			let site = callsites[_g];
			++_g;
			if(haxe_NativeStackTrace.wrapCallSite != null) {
				site = haxe_NativeStackTrace.wrapCallSite(site);
			}
			let method = null;
			let fullName = site.getFunctionName();
			if(fullName != null) {
				let idx = fullName.lastIndexOf(".");
				if(idx >= 0) {
					method = haxe_StackItem.Method(fullName.substring(0,idx),fullName.substring(idx + 1));
				} else {
					method = haxe_StackItem.Method(null,fullName);
				}
			}
			let fileName = site.getFileName();
			let fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
			if(haxe_NativeStackTrace.wrapCallSite != null && fileAddr > 0) {
				fileName = fileName.substring(fileAddr + 6);
			}
			stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
		}
		return stack;
	}
	static normalize(stack,skipItems) {
		if(skipItems == null) {
			skipItems = 0;
		}
		if(Array.isArray(stack) && skipItems > 0) {
			return stack.slice(skipItems);
		} else if(typeof(stack) == "string") {
			switch(stack.substring(0,6)) {
			case "Error\n":case "Error:":
				++skipItems;
				break;
			default:
			}
			return haxe_NativeStackTrace.skipLines(stack,skipItems);
		} else {
			return stack;
		}
	}
	static skipLines(stack,skip,pos) {
		if(pos == null) {
			pos = 0;
		}
		while(true) if(skip > 0) {
			pos = stack.indexOf("\n",pos);
			if(pos < 0) {
				return "";
			} else {
				skip = --skip;
				pos += 1;
				continue;
			}
		} else {
			return stack.substring(pos);
		}
	}
}
haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace";
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
		this.__skipStack++;
	}
	unwrap() {
		return this.value;
	}
}
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
Object.assign(haxe_ValueException.prototype, {
	__class__: haxe_ValueException
});
var haxe_display_NoData = $hxEnums["haxe.display.NoData"] = { __ename__:true,__constructs__:null
};
haxe_display_NoData.__constructs__ = [];
class haxe_ds_ArraySort {
	static sort(a,cmp) {
		haxe_ds_ArraySort.rec(a,cmp,0,a.length);
	}
	static rec(a,cmp,from,to) {
		let middle = from + to >> 1;
		if(to - from < 12) {
			if(to <= from) {
				return;
			}
			let _g = from + 1;
			while(_g < to) {
				let j = _g++;
				while(j > from) {
					if(cmp(a[j],a[j - 1]) < 0) {
						haxe_ds_ArraySort.swap(a,j - 1,j);
					} else {
						break;
					}
					--j;
				}
			}
			return;
		}
		haxe_ds_ArraySort.rec(a,cmp,from,middle);
		haxe_ds_ArraySort.rec(a,cmp,middle,to);
		haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
	}
	static doMerge(a,cmp,from,pivot,to,len1,len2) {
		while(true) {
			let first_cut;
			let second_cut;
			let len11;
			let len22;
			if(len1 == 0 || len2 == 0) {
				return;
			}
			if(len1 + len2 == 2) {
				if(cmp(a[pivot],a[from]) < 0) {
					haxe_ds_ArraySort.swap(a,pivot,from);
				}
				return;
			}
			if(len1 > len2) {
				len11 = len1 >> 1;
				first_cut = from + len11;
				second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
				len22 = second_cut - pivot;
			} else {
				len22 = len2 >> 1;
				second_cut = pivot + len22;
				first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
				len11 = first_cut - from;
			}
			haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
			let new_mid = first_cut + len22;
			haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
			from = new_mid;
			pivot = second_cut;
			len1 -= len11;
			len2 -= len22;
		}
	}
	static rotate(a,cmp,from,mid,to) {
		if(from == mid || mid == to) {
			return;
		}
		let n = haxe_ds_ArraySort.gcd(to - from,mid - from);
		while(n-- != 0) {
			let val = a[from + n];
			let shift = mid - from;
			let p1 = from + n;
			let p2 = from + n + shift;
			while(p2 != from + n) {
				a[p1] = a[p2];
				p1 = p2;
				if(to - p2 > shift) {
					p2 += shift;
				} else {
					p2 = from + (shift - (to - p2));
				}
			}
			a[p1] = val;
		}
	}
	static gcd(m,n) {
		while(n != 0) {
			let t = m % n;
			m = n;
			n = t;
		}
		return m;
	}
	static upper(a,cmp,from,to,val) {
		let len = to - from;
		let half;
		let mid;
		while(len > 0) {
			half = len >> 1;
			mid = from + half;
			if(cmp(a[val],a[mid]) < 0) {
				len = half;
			} else {
				from = mid + 1;
				len = len - half - 1;
			}
		}
		return from;
	}
	static lower(a,cmp,from,to,val) {
		let len = to - from;
		let half;
		let mid;
		while(len > 0) {
			half = len >> 1;
			mid = from + half;
			if(cmp(a[mid],a[val]) < 0) {
				from = mid + 1;
				len = len - half - 1;
			} else {
				len = half;
			}
		}
		return from;
	}
	static swap(a,i,j) {
		let tmp = a[i];
		a[i] = a[j];
		a[j] = tmp;
	}
}
haxe_ds_ArraySort.__name__ = "haxe.ds.ArraySort";
class haxe_ds_BalancedTree {
	constructor() {
	}
	set(key,value) {
		this.root = this.setLoop(key,value,this.root);
	}
	get(key) {
		let node = this.root;
		while(node != null) {
			let c = this.compare(key,node.key);
			if(c == 0) {
				return node.value;
			}
			if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return null;
	}
	iterator() {
		let ret = [];
		haxe_ds_BalancedTree.iteratorLoop(this.root,ret);
		return new haxe_iterators_ArrayIterator(ret);
	}
	keys() {
		let ret = [];
		this.keysLoop(this.root,ret);
		return new haxe_iterators_ArrayIterator(ret);
	}
	setLoop(k,v,node) {
		if(node == null) {
			return new haxe_ds_TreeNode(null,k,v,null);
		}
		let c = this.compare(k,node.key);
		if(c == 0) {
			return new haxe_ds_TreeNode(node.left,k,v,node.right,node == null ? 0 : node._height);
		} else if(c < 0) {
			return this.balance(this.setLoop(k,v,node.left),node.key,node.value,node.right);
		} else {
			let nr = this.setLoop(k,v,node.right);
			return this.balance(node.left,node.key,node.value,nr);
		}
	}
	keysLoop(node,acc) {
		if(node != null) {
			this.keysLoop(node.left,acc);
			acc.push(node.key);
			this.keysLoop(node.right,acc);
		}
	}
	balance(l,k,v,r) {
		let hl = l == null ? 0 : l._height;
		let hr = r == null ? 0 : r._height;
		if(hl > hr + 2) {
			let _this = l.left;
			let _this1 = l.right;
			if((_this == null ? 0 : _this._height) >= (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(l.left,l.key,l.value,new haxe_ds_TreeNode(l.right,k,v,r));
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,new haxe_ds_TreeNode(l.right.right,k,v,r));
			}
		} else if(hr > hl + 2) {
			let _this = r.right;
			let _this1 = r.left;
			if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right);
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,new haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right));
			}
		} else {
			return new haxe_ds_TreeNode(l,k,v,r,(hl > hr ? hl : hr) + 1);
		}
	}
	compare(k1,k2) {
		return Reflect.compare(k1,k2);
	}
	static iteratorLoop(node,acc) {
		while(true) {
			if(node != null) {
				haxe_ds_BalancedTree.iteratorLoop(node.left,acc);
				acc.push(node.value);
				node = node.right;
				continue;
			}
			return;
		}
	}
}
haxe_ds_BalancedTree.__name__ = "haxe.ds.BalancedTree";
haxe_ds_BalancedTree.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_BalancedTree.prototype, {
	__class__: haxe_ds_BalancedTree
});
class haxe_ds_TreeNode {
	constructor(l,k,v,r,h) {
		if(h == null) {
			h = -1;
		}
		this.left = l;
		this.key = k;
		this.value = v;
		this.right = r;
		if(h == -1) {
			let tmp;
			let _this = this.left;
			let _this1 = this.right;
			if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
				let _this = this.left;
				tmp = _this == null ? 0 : _this._height;
			} else {
				let _this = this.right;
				tmp = _this == null ? 0 : _this._height;
			}
			this._height = tmp + 1;
		} else {
			this._height = h;
		}
	}
}
haxe_ds_TreeNode.__name__ = "haxe.ds.TreeNode";
Object.assign(haxe_ds_TreeNode.prototype, {
	__class__: haxe_ds_TreeNode
});
class haxe_ds_EnumValueMap extends haxe_ds_BalancedTree {
	constructor() {
		super();
	}
	compare(k1,k2) {
		let d = k1._hx_index - k2._hx_index;
		if(d != 0) {
			return d;
		}
		let p1 = Type.enumParameters(k1);
		let p2 = Type.enumParameters(k2);
		if(p1.length == 0 && p2.length == 0) {
			return 0;
		}
		return this.compareArgs(p1,p2);
	}
	compareArgs(a1,a2) {
		let ld = a1.length - a2.length;
		if(ld != 0) {
			return ld;
		}
		let _g = 0;
		let _g1 = a1.length;
		while(_g < _g1) {
			let i = _g++;
			let d = this.compareArg(a1[i],a2[i]);
			if(d != 0) {
				return d;
			}
		}
		return 0;
	}
	compareArg(v1,v2) {
		if(Reflect.isEnumValue(v1) && Reflect.isEnumValue(v2)) {
			return this.compare(v1,v2);
		} else if(((v1) instanceof Array) && ((v2) instanceof Array)) {
			return this.compareArgs(v1,v2);
		} else {
			return Reflect.compare(v1,v2);
		}
	}
}
haxe_ds_EnumValueMap.__name__ = "haxe.ds.EnumValueMap";
haxe_ds_EnumValueMap.__interfaces__ = [haxe_IMap];
haxe_ds_EnumValueMap.__super__ = haxe_ds_BalancedTree;
Object.assign(haxe_ds_EnumValueMap.prototype, {
	__class__: haxe_ds_EnumValueMap
});
class haxe_ds_GenericCell {
	constructor(elt,next) {
		this.elt = elt;
		this.next = next;
	}
}
haxe_ds_GenericCell.__name__ = "haxe.ds.GenericCell";
Object.assign(haxe_ds_GenericCell.prototype, {
	__class__: haxe_ds_GenericCell
});
class haxe_ds_GenericStack {
	constructor() {
	}
}
haxe_ds_GenericStack.__name__ = "haxe.ds.GenericStack";
Object.assign(haxe_ds_GenericStack.prototype, {
	__class__: haxe_ds_GenericStack
});
class haxe_ds_IntMap {
	constructor() {
		this.h = { };
	}
	remove(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	keys() {
		let a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(+key);
		return new haxe_iterators_ArrayIterator(a);
	}
	iterator() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			let i = this.it.next();
			return this.ref[i];
		}};
	}
}
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_IntMap.prototype, {
	__class__: haxe_ds_IntMap
});
class haxe_ds_List {
	constructor() {
		this.length = 0;
	}
	push(item) {
		let x = new haxe_ds__$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	remove(v) {
		let prev = null;
		let l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
}
haxe_ds_List.__name__ = "haxe.ds.List";
Object.assign(haxe_ds_List.prototype, {
	__class__: haxe_ds_List
});
class haxe_ds__$List_ListNode {
	constructor(item,next) {
		this.item = item;
		this.next = next;
	}
}
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
Object.assign(haxe_ds__$List_ListNode.prototype, {
	__class__: haxe_ds__$List_ListNode
});
class haxe_ds_ObjectMap {
	constructor() {
		this.h = { __keys__ : { }};
	}
	set(key,value) {
		let id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
}
haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap";
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_ObjectMap.prototype, {
	__class__: haxe_ds_ObjectMap
});
var haxe_ds_Option = $hxEnums["haxe.ds.Option"] = { __ename__:true,__constructs__:null
	,Some: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Option",toString:$estr}; },$_._hx_name="Some",$_.__params__ = ["v"],$_)
	,None: {_hx_name:"None",_hx_index:1,__enum__:"haxe.ds.Option",toString:$estr}
};
haxe_ds_Option.__constructs__ = [haxe_ds_Option.Some,haxe_ds_Option.None];
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
}
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_StringMap.prototype, {
	__class__: haxe_ds_StringMap
});
class haxe_ds__$StringMap_StringMapKeyIterator {
	constructor(h) {
		this.h = h;
		this.keys = Object.keys(h);
		this.length = this.keys.length;
		this.current = 0;
	}
	hasNext() {
		return this.current < this.length;
	}
	next() {
		return this.keys[this.current++];
	}
}
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
Object.assign(haxe_ds__$StringMap_StringMapKeyIterator.prototype, {
	__class__: haxe_ds__$StringMap_StringMapKeyIterator
});
class haxe_exceptions_PosException extends haxe_Exception {
	constructor(message,previous,pos) {
		super(message,previous);
		if(pos == null) {
			this.posInfos = { fileName : "(unknown)", lineNumber : 0, className : "(unknown)", methodName : "(unknown)"};
		} else {
			this.posInfos = pos;
		}
		this.__skipStack++;
	}
	toString() {
		return "" + super.toString() + " in " + this.posInfos.className + "." + this.posInfos.methodName + " at " + this.posInfos.fileName + ":" + this.posInfos.lineNumber;
	}
}
haxe_exceptions_PosException.__name__ = "haxe.exceptions.PosException";
haxe_exceptions_PosException.__super__ = haxe_Exception;
Object.assign(haxe_exceptions_PosException.prototype, {
	__class__: haxe_exceptions_PosException
});
class haxe_exceptions_NotImplementedException extends haxe_exceptions_PosException {
	constructor(message,previous,pos) {
		if(message == null) {
			message = "Not implemented";
		}
		super(message,previous,pos);
		this.__skipStack++;
	}
}
haxe_exceptions_NotImplementedException.__name__ = "haxe.exceptions.NotImplementedException";
haxe_exceptions_NotImplementedException.__super__ = haxe_exceptions_PosException;
Object.assign(haxe_exceptions_NotImplementedException.prototype, {
	__class__: haxe_exceptions_NotImplementedException
});
class haxe_io_Bytes {
	constructor(data) {
		this.length = data.byteLength;
		this.b = new Uint8Array(data);
		this.b.bufferValue = data;
		data.hxBytes = this;
		data.bytes = this.b;
	}
	sub(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	getString(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		let s = "";
		let b = this.b;
		let i = pos;
		let max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			while(i < max) {
				let c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					let code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					let code = (c & 31) << 12 | (b[i++] & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else {
					let u = (c & 15) << 18 | (b[i++] & 127) << 12 | (b[i++] & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				let c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	toString() {
		return this.getString(0,this.length);
	}
	static ofString(s,encoding) {
		if(encoding == haxe_io_Encoding.RawNative) {
			let buf = new Uint8Array(s.length << 1);
			let _g = 0;
			let _g1 = s.length;
			while(_g < _g1) {
				let i = _g++;
				let c = s.charCodeAt(i);
				buf[i << 1] = c & 255;
				buf[i << 1 | 1] = c >> 8;
			}
			return new haxe_io_Bytes(buf.buffer);
		}
		let a = [];
		let i = 0;
		while(i < s.length) {
			let c = s.charCodeAt(i++);
			if(55296 <= c && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
			}
			if(c <= 127) {
				a.push(c);
			} else if(c <= 2047) {
				a.push(192 | c >> 6);
				a.push(128 | c & 63);
			} else if(c <= 65535) {
				a.push(224 | c >> 12);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			} else {
				a.push(240 | c >> 18);
				a.push(128 | c >> 12 & 63);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			}
		}
		return new haxe_io_Bytes(new Uint8Array(a).buffer);
	}
}
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
Object.assign(haxe_io_Bytes.prototype, {
	__class__: haxe_io_Bytes
});
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
class haxe_io_Eof {
	constructor() {
	}
	toString() {
		return "Eof";
	}
}
haxe_io_Eof.__name__ = "haxe.io.Eof";
Object.assign(haxe_io_Eof.prototype, {
	__class__: haxe_io_Eof
});
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:true,__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
class haxe_io_Path {
	constructor(path) {
		switch(path) {
		case ".":case "..":
			this.dir = path;
			this.file = "";
			return;
		}
		let c1 = path.lastIndexOf("/");
		let c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			this.dir = HxOverrides.substr(path,0,c2);
			path = HxOverrides.substr(path,c2 + 1,null);
			this.backslash = true;
		} else if(c2 < c1) {
			this.dir = HxOverrides.substr(path,0,c1);
			path = HxOverrides.substr(path,c1 + 1,null);
		} else {
			this.dir = null;
		}
		let cp = path.lastIndexOf(".");
		if(cp != -1) {
			this.ext = HxOverrides.substr(path,cp + 1,null);
			this.file = HxOverrides.substr(path,0,cp);
		} else {
			this.ext = null;
			this.file = path;
		}
	}
	toString() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
	static withoutDirectory(path) {
		let s = new haxe_io_Path(path);
		s.dir = null;
		return s.toString();
	}
	static directory(path) {
		let s = new haxe_io_Path(path);
		if(s.dir == null) {
			return "";
		}
		return s.dir;
	}
	static join(paths) {
		let _g = [];
		let _g1 = 0;
		while(_g1 < paths.length) {
			let v = paths[_g1];
			++_g1;
			if(v != null && v != "") {
				_g.push(v);
			}
		}
		if(_g.length == 0) {
			return "";
		}
		let path = _g[0];
		let _g2 = 1;
		let _g3 = _g.length;
		while(_g2 < _g3) {
			path = haxe_io_Path.addTrailingSlash(path);
			path += _g[_g2++];
		}
		return haxe_io_Path.normalize(path);
	}
	static normalize(path) {
		let slash = "/";
		path = path.split("\\").join(slash);
		if(path == slash) {
			return slash;
		}
		let target = [];
		let _g = 0;
		let _g1 = path.split(slash);
		while(_g < _g1.length) {
			let token = _g1[_g];
			++_g;
			if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
				target.pop();
			} else if(token == "") {
				if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
					target.push(token);
				}
			} else if(token != ".") {
				target.push(token);
			}
		}
		let acc_b = "";
		let colon = false;
		let slashes = false;
		let _g_offset = 0;
		let _g_s = target.join(slash);
		while(_g_offset < _g_s.length) {
			let s = _g_s;
			let index = _g_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g_offset;
			}
			let c2 = c1;
			switch(c2) {
			case 47:
				if(!colon) {
					slashes = true;
				} else {
					let i = c2;
					colon = false;
					if(slashes) {
						acc_b += "/";
						slashes = false;
					}
					acc_b += String.fromCodePoint(i);
				}
				break;
			case 58:
				acc_b += ":";
				colon = true;
				break;
			default:
				let i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
		}
		return acc_b;
	}
	static addTrailingSlash(path) {
		if(path.length == 0) {
			return "/";
		}
		let c1 = path.lastIndexOf("/");
		let c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			if(c2 != path.length - 1) {
				return path + "\\";
			} else {
				return path;
			}
		} else if(c1 != path.length - 1) {
			return path + "/";
		} else {
			return path;
		}
	}
	static removeTrailingSlashes(path) {
		_hx_loop1: while(true) {
			let _g = HxOverrides.cca(path,path.length - 1);
			if(_g == null) {
				break;
			} else {
				switch(_g) {
				case 47:case 92:
					path = HxOverrides.substr(path,0,-1);
					break;
				default:
					break _hx_loop1;
				}
			}
		}
		return path;
	}
	static isAbsolute(path) {
		if(path.startsWith("/")) {
			return true;
		}
		if(path.charAt(1) == ":") {
			return true;
		}
		if(path.startsWith("\\\\")) {
			return true;
		}
		return false;
	}
}
haxe_io_Path.__name__ = "haxe.io.Path";
Object.assign(haxe_io_Path.prototype, {
	__class__: haxe_io_Path
});
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
Object.assign(haxe_iterators_ArrayIterator.prototype, {
	__class__: haxe_iterators_ArrayIterator
});
var haxe_macro_StringLiteralKind = $hxEnums["haxe.macro.StringLiteralKind"] = { __ename__:true,__constructs__:null
	,DoubleQuotes: {_hx_name:"DoubleQuotes",_hx_index:0,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
	,SingleQuotes: {_hx_name:"SingleQuotes",_hx_index:1,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
};
haxe_macro_StringLiteralKind.__constructs__ = [haxe_macro_StringLiteralKind.DoubleQuotes,haxe_macro_StringLiteralKind.SingleQuotes];
var haxe_macro_Binop = $hxEnums["haxe.macro.Binop"] = { __ename__:true,__constructs__:null
	,OpAdd: {_hx_name:"OpAdd",_hx_index:0,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMult: {_hx_name:"OpMult",_hx_index:1,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpDiv: {_hx_name:"OpDiv",_hx_index:2,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpSub: {_hx_name:"OpSub",_hx_index:3,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssign: {_hx_name:"OpAssign",_hx_index:4,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpEq: {_hx_name:"OpEq",_hx_index:5,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNotEq: {_hx_name:"OpNotEq",_hx_index:6,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGt: {_hx_name:"OpGt",_hx_index:7,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGte: {_hx_name:"OpGte",_hx_index:8,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLt: {_hx_name:"OpLt",_hx_index:9,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLte: {_hx_name:"OpLte",_hx_index:10,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAnd: {_hx_name:"OpAnd",_hx_index:11,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpOr: {_hx_name:"OpOr",_hx_index:12,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpXor: {_hx_name:"OpXor",_hx_index:13,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolAnd: {_hx_name:"OpBoolAnd",_hx_index:14,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolOr: {_hx_name:"OpBoolOr",_hx_index:15,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShl: {_hx_name:"OpShl",_hx_index:16,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShr: {_hx_name:"OpShr",_hx_index:17,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpUShr: {_hx_name:"OpUShr",_hx_index:18,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMod: {_hx_name:"OpMod",_hx_index:19,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssignOp: ($_=function(op) { return {_hx_index:20,op:op,__enum__:"haxe.macro.Binop",toString:$estr}; },$_._hx_name="OpAssignOp",$_.__params__ = ["op"],$_)
	,OpInterval: {_hx_name:"OpInterval",_hx_index:21,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpArrow: {_hx_name:"OpArrow",_hx_index:22,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpIn: {_hx_name:"OpIn",_hx_index:23,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNullCoal: {_hx_name:"OpNullCoal",_hx_index:24,__enum__:"haxe.macro.Binop",toString:$estr}
};
haxe_macro_Binop.__constructs__ = [haxe_macro_Binop.OpAdd,haxe_macro_Binop.OpMult,haxe_macro_Binop.OpDiv,haxe_macro_Binop.OpSub,haxe_macro_Binop.OpAssign,haxe_macro_Binop.OpEq,haxe_macro_Binop.OpNotEq,haxe_macro_Binop.OpGt,haxe_macro_Binop.OpGte,haxe_macro_Binop.OpLt,haxe_macro_Binop.OpLte,haxe_macro_Binop.OpAnd,haxe_macro_Binop.OpOr,haxe_macro_Binop.OpXor,haxe_macro_Binop.OpBoolAnd,haxe_macro_Binop.OpBoolOr,haxe_macro_Binop.OpShl,haxe_macro_Binop.OpShr,haxe_macro_Binop.OpUShr,haxe_macro_Binop.OpMod,haxe_macro_Binop.OpAssignOp,haxe_macro_Binop.OpInterval,haxe_macro_Binop.OpArrow,haxe_macro_Binop.OpIn,haxe_macro_Binop.OpNullCoal];
var haxe_macro_Unop = $hxEnums["haxe.macro.Unop"] = { __ename__:true,__constructs__:null
	,OpIncrement: {_hx_name:"OpIncrement",_hx_index:0,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpDecrement: {_hx_name:"OpDecrement",_hx_index:1,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNot: {_hx_name:"OpNot",_hx_index:2,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNeg: {_hx_name:"OpNeg",_hx_index:3,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNegBits: {_hx_name:"OpNegBits",_hx_index:4,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpSpread: {_hx_name:"OpSpread",_hx_index:5,__enum__:"haxe.macro.Unop",toString:$estr}
};
haxe_macro_Unop.__constructs__ = [haxe_macro_Unop.OpIncrement,haxe_macro_Unop.OpDecrement,haxe_macro_Unop.OpNot,haxe_macro_Unop.OpNeg,haxe_macro_Unop.OpNegBits,haxe_macro_Unop.OpSpread];
class haxe_macro_Printer {
	constructor(tabString) {
		if(tabString == null) {
			tabString = "\t";
		}
		this.tabs = "";
		this.tabString = tabString;
	}
	printUnop(op) {
		switch(op._hx_index) {
		case 0:
			return "++";
		case 1:
			return "--";
		case 2:
			return "!";
		case 3:
			return "-";
		case 4:
			return "~";
		case 5:
			return "...";
		}
	}
	printBinop(op) {
		switch(op._hx_index) {
		case 0:
			return "+";
		case 1:
			return "*";
		case 2:
			return "/";
		case 3:
			return "-";
		case 4:
			return "=";
		case 5:
			return "==";
		case 6:
			return "!=";
		case 7:
			return ">";
		case 8:
			return ">=";
		case 9:
			return "<";
		case 10:
			return "<=";
		case 11:
			return "&";
		case 12:
			return "|";
		case 13:
			return "^";
		case 14:
			return "&&";
		case 15:
			return "||";
		case 16:
			return "<<";
		case 17:
			return ">>";
		case 18:
			return ">>>";
		case 19:
			return "%";
		case 20:
			return this.printBinop(op.op) + "=";
		case 21:
			return "...";
		case 22:
			return "=>";
		case 23:
			return "in";
		case 24:
			return "??";
		}
	}
}
haxe_macro_Printer.__name__ = "haxe.macro.Printer";
Object.assign(haxe_macro_Printer.prototype, {
	__class__: haxe_macro_Printer
});
class haxe_xml_XmlParserException {
	constructor(message,xml,position) {
		this.xml = xml;
		this.message = message;
		this.position = position;
		this.lineNumber = 1;
		this.positionAtLine = 0;
		let _g = 0;
		while(_g < position) {
			let c = xml.charCodeAt(_g++);
			if(c == 10) {
				this.lineNumber++;
				this.positionAtLine = 0;
			} else if(c != 13) {
				this.positionAtLine++;
			}
		}
	}
	toString() {
		let c = js_Boot.getClass(this);
		return c.__name__ + ": " + this.message + " at line " + this.lineNumber + " char " + this.positionAtLine;
	}
}
haxe_xml_XmlParserException.__name__ = "haxe.xml.XmlParserException";
Object.assign(haxe_xml_XmlParserException.prototype, {
	__class__: haxe_xml_XmlParserException
});
class haxe_xml_Parser {
	static parse(str,strict) {
		if(strict == null) {
			strict = false;
		}
		let doc = Xml.createDocument();
		haxe_xml_Parser.doParse(str,strict,0,doc);
		return doc;
	}
	static doParse(str,strict,p,parent) {
		if(p == null) {
			p = 0;
		}
		let xml = null;
		let state = 1;
		let next = 1;
		let aname = null;
		let start = 0;
		let nsubs = 0;
		let nbrackets = 0;
		let buf = new StringBuf();
		let escapeNext = 1;
		let attrValQuote = -1;
		while(p < str.length) {
			let c = str.charCodeAt(p);
			switch(state) {
			case 0:
				switch(c) {
				case 9:case 10:case 13:case 32:
					break;
				default:
					state = next;
					continue;
				}
				break;
			case 1:
				if(c == 60) {
					state = 0;
					next = 2;
				} else {
					start = p;
					state = 13;
					continue;
				}
				break;
			case 2:
				switch(c) {
				case 33:
					if(str.charCodeAt(p + 1) == 91) {
						p += 2;
						if(HxOverrides.substr(str,p,6).toUpperCase() != "CDATA[") {
							throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <![CDATA[",str,p));
						}
						p += 5;
						state = 17;
						start = p + 1;
					} else if(str.charCodeAt(p + 1) == 68 || str.charCodeAt(p + 1) == 100) {
						if(HxOverrides.substr(str,p + 2,6).toUpperCase() != "OCTYPE") {
							throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!DOCTYPE",str,p));
						}
						p += 8;
						state = 16;
						start = p + 1;
					} else if(str.charCodeAt(p + 1) != 45 || str.charCodeAt(p + 2) != 45) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!--",str,p));
					} else {
						p += 2;
						state = 15;
						start = p + 1;
					}
					break;
				case 47:
					if(parent == null) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
					}
					start = p + 1;
					state = 0;
					next = 10;
					break;
				case 63:
					state = 14;
					start = p;
					break;
				default:
					state = 3;
					start = p;
					continue;
				}
				break;
			case 3:
				if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
					if(p == start) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
					}
					xml = Xml.createElement(HxOverrides.substr(str,start,p - start));
					parent.addChild(xml);
					++nsubs;
					state = 0;
					next = 4;
					continue;
				}
				break;
			case 4:
				switch(c) {
				case 47:
					state = 11;
					break;
				case 62:
					state = 9;
					break;
				default:
					state = 5;
					start = p;
					continue;
				}
				break;
			case 5:
				if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
					if(start == p) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected attribute name",str,p));
					}
					aname = HxOverrides.substr(str,start,p - start);
					if(xml.exists(aname)) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Duplicate attribute [" + aname + "]",str,p));
					}
					state = 0;
					next = 6;
					continue;
				}
				break;
			case 6:
				if(c == 61) {
					state = 0;
					next = 7;
				} else {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected =",str,p));
				}
				break;
			case 7:
				switch(c) {
				case 34:case 39:
					buf = new StringBuf();
					state = 8;
					start = p + 1;
					attrValQuote = c;
					break;
				default:
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected \"",str,p));
				}
				break;
			case 8:
				switch(c) {
				case 38:
					let len = p - start;
					buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
					state = 18;
					escapeNext = 8;
					start = p + 1;
					break;
				case 60:case 62:
					if(strict) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid unescaped " + String.fromCodePoint(c) + " in attribute value",str,p));
					} else if(c == attrValQuote) {
						let len = p - start;
						buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
						let val = buf.b;
						buf = new StringBuf();
						xml.set(aname,val);
						state = 0;
						next = 4;
					}
					break;
				default:
					if(c == attrValQuote) {
						let len = p - start;
						buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
						let val = buf.b;
						buf = new StringBuf();
						xml.set(aname,val);
						state = 0;
						next = 4;
					}
				}
				break;
			case 9:
				p = haxe_xml_Parser.doParse(str,strict,p,xml);
				start = p;
				state = 1;
				break;
			case 10:
				if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
					if(start == p) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
					}
					let v = HxOverrides.substr(str,start,p - start);
					if(parent == null || parent.nodeType != 0) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected </" + v + ">, tag is not open",str,p));
					}
					if(parent.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
					}
					if(v != parent.nodeName) {
						if(parent.nodeType != Xml.Element) {
							throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
						}
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected </" + parent.nodeName + ">",str,p));
					}
					state = 0;
					next = 12;
					continue;
				}
				break;
			case 11:
				if(c == 62) {
					state = 1;
				} else {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
				}
				break;
			case 12:
				if(c == 62) {
					if(nsubs == 0) {
						parent.addChild(Xml.createPCData(""));
					}
					return p;
				} else {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
				}
				break;
			case 13:
				if(c == 60) {
					let len = p - start;
					buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
					let child = Xml.createPCData(buf.b);
					buf = new StringBuf();
					parent.addChild(child);
					++nsubs;
					state = 0;
					next = 2;
				} else if(c == 38) {
					let len = p - start;
					buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
					state = 18;
					escapeNext = 13;
					start = p + 1;
				}
				break;
			case 14:
				if(c == 63 && str.charCodeAt(p + 1) == 62) {
					++p;
					parent.addChild(Xml.createProcessingInstruction(HxOverrides.substr(str,start + 1,p - start - 2)));
					++nsubs;
					state = 1;
				}
				break;
			case 15:
				if(c == 45 && str.charCodeAt(p + 1) == 45 && str.charCodeAt(p + 2) == 62) {
					parent.addChild(Xml.createComment(HxOverrides.substr(str,start,p - start)));
					++nsubs;
					p += 2;
					state = 1;
				}
				break;
			case 16:
				if(c == 91) {
					++nbrackets;
				} else if(c == 93) {
					--nbrackets;
				} else if(c == 62 && nbrackets == 0) {
					parent.addChild(Xml.createDocType(HxOverrides.substr(str,start,p - start)));
					++nsubs;
					state = 1;
				}
				break;
			case 17:
				if(c == 93 && str.charCodeAt(p + 1) == 93 && str.charCodeAt(p + 2) == 62) {
					parent.addChild(Xml.createCData(HxOverrides.substr(str,start,p - start)));
					++nsubs;
					p += 2;
					state = 1;
				}
				break;
			case 18:
				if(c == 59) {
					let s = HxOverrides.substr(str,start,p - start);
					if(s.charCodeAt(0) == 35) {
						let c = s.charCodeAt(1) == 120 ? Std.parseInt("0" + HxOverrides.substr(s,1,s.length - 1)) : Std.parseInt(HxOverrides.substr(s,1,s.length - 1));
						buf.b += String.fromCodePoint(c);
					} else if(!Object.prototype.hasOwnProperty.call(haxe_xml_Parser.escapes.h,s)) {
						if(strict) {
							throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Undefined entity: " + s,str,p));
						}
						buf.b += Std.string("&" + s + ";");
					} else {
						buf.b += Std.string(haxe_xml_Parser.escapes.h[s]);
					}
					start = p + 1;
					state = escapeNext;
				} else if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45) && c != 35) {
					if(strict) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid character in entity: " + String.fromCodePoint(c),str,p));
					}
					buf.b += String.fromCodePoint(38);
					let len = p - start;
					buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
					--p;
					start = p + 1;
					state = escapeNext;
				}
				break;
			}
			++p;
		}
		if(state == 1) {
			start = p;
			state = 13;
		}
		if(state == 13) {
			if(parent.nodeType == 0) {
				if(parent.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
				}
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unclosed node <" + parent.nodeName + ">",str,p));
			}
			if(p != start || nsubs == 0) {
				let len = p - start;
				buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
				parent.addChild(Xml.createPCData(buf.b));
				++nsubs;
			}
			return p;
		}
		if(!strict && state == 18 && escapeNext == 13) {
			buf.b += String.fromCodePoint(38);
			let len = p - start;
			buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
			parent.addChild(Xml.createPCData(buf.b));
			++nsubs;
			return p;
		}
		throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected end",str,p));
	}
}
haxe_xml_Parser.__name__ = "haxe.xml.Parser";
class haxe_xml_Printer {
	constructor(pretty) {
		this.output = new StringBuf();
		this.pretty = pretty;
	}
	writeNode(value,tabs) {
		switch(value.nodeType) {
		case 0:
			this.output.b += Std.string(tabs + "<");
			if(value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeName);
			let attribute = value.attributes();
			while(attribute.hasNext()) {
				let attribute1 = attribute.next();
				this.output.b += Std.string(" " + attribute1 + "=\"");
				let input = StringTools.htmlEscape(value.get(attribute1),true);
				this.output.b += Std.string(input);
				this.output.b += "\"";
			}
			if(this.hasChildren(value)) {
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
				if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				let _this = value.children;
				let _g_current = 0;
				while(_g_current < _this.length) this.writeNode(_this[_g_current++],this.pretty ? tabs + "\t" : tabs);
				this.output.b += Std.string(tabs + "</");
				if(value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				this.output.b += Std.string(value.nodeName);
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
			} else {
				this.output.b += "/>";
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 1:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let nodeValue = value.nodeValue;
			if(nodeValue.length != 0) {
				let input = tabs + StringTools.htmlEscape(nodeValue);
				this.output.b += Std.string(input);
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 2:
			this.output.b += Std.string(tabs + "<![CDATA[");
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeValue);
			this.output.b += "]]>";
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 3:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let commentContent = value.nodeValue;
			let _this_r = new RegExp("[\n\r\t]+","g".split("u").join(""));
			commentContent = commentContent.replace(_this_r,"");
			commentContent = "<!--" + commentContent + "-->";
			this.output.b += tabs == null ? "null" : "" + tabs;
			this.output.b += Std.string(StringTools.trim(commentContent));
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 4:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<!DOCTYPE " + value.nodeValue + ">");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 5:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<?" + value.nodeValue + "?>");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 6:
			if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let _this = value.children;
			let _g_current = 0;
			while(_g_current < _this.length) this.writeNode(_this[_g_current++],tabs);
			break;
		}
	}
	hasChildren(value) {
		if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
		}
		let _this = value.children;
		let _g_current = 0;
		while(_g_current < _this.length) {
			let child = _this[_g_current++];
			switch(child.nodeType) {
			case 0:case 1:
				return true;
			case 2:case 3:
				if(child.nodeType == Xml.Document || child.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				if(StringTools.ltrim(child.nodeValue).length != 0) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	static print(xml,pretty) {
		if(pretty == null) {
			pretty = false;
		}
		let printer = new haxe_xml_Printer(pretty);
		printer.writeNode(xml,"");
		return printer.output.b;
	}
}
haxe_xml_Printer.__name__ = "haxe.xml.Printer";
Object.assign(haxe_xml_Printer.prototype, {
	__class__: haxe_xml_Printer
});
var haxeLanguageServer_ConfigurationKind = $hxEnums["haxeLanguageServer.ConfigurationKind"] = { __ename__:true,__constructs__:null
	,User: {_hx_name:"User",_hx_index:0,__enum__:"haxeLanguageServer.ConfigurationKind",toString:$estr}
	,DisplayArguments: {_hx_name:"DisplayArguments",_hx_index:1,__enum__:"haxeLanguageServer.ConfigurationKind",toString:$estr}
	,DisplayServer: {_hx_name:"DisplayServer",_hx_index:2,__enum__:"haxeLanguageServer.ConfigurationKind",toString:$estr}
};
haxeLanguageServer_ConfigurationKind.__constructs__ = [haxeLanguageServer_ConfigurationKind.User,haxeLanguageServer_ConfigurationKind.DisplayArguments,haxeLanguageServer_ConfigurationKind.DisplayServer];
class haxeLanguageServer_Configuration {
	constructor(languageServerProtocol,onDidChange) {
		this.sendMethodResults = false;
		this.onDidChange = onDidChange;
		languageServerProtocol.onNotification("workspace/didChangeConfiguration",$bind(this,this.onDidChangeConfiguration));
		languageServerProtocol.onNotification("haxe/didChangeDisplayArguments",$bind(this,this.onDidChangeDisplayArguments));
		languageServerProtocol.onNotification("haxe/didChangeDisplayServerConfig",$bind(this,this.onDidChangeDisplayServerConfig));
	}
	onInitialize(params) {
		let options = params.initializationOptions;
		if(options == null) {
			options = haxeLanguageServer_Configuration.DefaultInitOptions;
		} else {
			if(options.displayArguments == null) {
				options.displayArguments = haxeLanguageServer_Configuration.DefaultInitOptions.displayArguments;
			}
			if(options.displayServerConfig == null) {
				options.displayServerConfig = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig;
			}
			if(options.displayServerConfig.arguments == null) {
				options.displayServerConfig.arguments = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.arguments;
			}
			if(options.displayServerConfig.env == null) {
				options.displayServerConfig.env = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.env;
			}
			if(options.displayServerConfig.path == null) {
				options.displayServerConfig.path = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.path;
			}
			if(options.displayServerConfig.print == null) {
				options.displayServerConfig.print = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print;
			}
			if(options.displayServerConfig.print.addedDirectory == null) {
				options.displayServerConfig.print.addedDirectory = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.addedDirectory;
			}
			if(options.displayServerConfig.print.arguments == null) {
				options.displayServerConfig.print.arguments = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.arguments;
			}
			if(options.displayServerConfig.print.cachedModules == null) {
				options.displayServerConfig.print.cachedModules = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.cachedModules;
			}
			if(options.displayServerConfig.print.changedDirectories == null) {
				options.displayServerConfig.print.changedDirectories = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.changedDirectories;
			}
			if(options.displayServerConfig.print.completion == null) {
				options.displayServerConfig.print.completion = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.completion;
			}
			if(options.displayServerConfig.print.defines == null) {
				options.displayServerConfig.print.defines = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.defines;
			}
			if(options.displayServerConfig.print.displayPosition == null) {
				options.displayServerConfig.print.displayPosition = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.displayPosition;
			}
			if(options.displayServerConfig.print.foundDirectories == null) {
				options.displayServerConfig.print.foundDirectories = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.foundDirectories;
			}
			if(options.displayServerConfig.print.message == null) {
				options.displayServerConfig.print.message = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.message;
			}
			if(options.displayServerConfig.print.modulePathChanged == null) {
				options.displayServerConfig.print.modulePathChanged = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.modulePathChanged;
			}
			if(options.displayServerConfig.print.newContext == null) {
				options.displayServerConfig.print.newContext = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.newContext;
			}
			if(options.displayServerConfig.print.notCached == null) {
				options.displayServerConfig.print.notCached = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.notCached;
			}
			if(options.displayServerConfig.print.parsed == null) {
				options.displayServerConfig.print.parsed = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.parsed;
			}
			if(options.displayServerConfig.print.removedDirectory == null) {
				options.displayServerConfig.print.removedDirectory = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.removedDirectory;
			}
			if(options.displayServerConfig.print.reusing == null) {
				options.displayServerConfig.print.reusing = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.reusing;
			}
			if(options.displayServerConfig.print.signature == null) {
				options.displayServerConfig.print.signature = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.signature;
			}
			if(options.displayServerConfig.print.skippingDep == null) {
				options.displayServerConfig.print.skippingDep = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.skippingDep;
			}
			if(options.displayServerConfig.print.socketMessage == null) {
				options.displayServerConfig.print.socketMessage = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.socketMessage;
			}
			if(options.displayServerConfig.print.stats == null) {
				options.displayServerConfig.print.stats = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.stats;
			}
			if(options.displayServerConfig.print.uncaughtError == null) {
				options.displayServerConfig.print.uncaughtError = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.uncaughtError;
			}
			if(options.displayServerConfig.print.unchangedContent == null) {
				options.displayServerConfig.print.unchangedContent = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.print.unchangedContent;
			}
			if(options.displayServerConfig.useSocket == null) {
				options.displayServerConfig.useSocket = haxeLanguageServer_Configuration.DefaultInitOptions.displayServerConfig.useSocket;
			}
			if(options.experimentalClientCapabilities == null) {
				options.experimentalClientCapabilities = haxeLanguageServer_Configuration.DefaultInitOptions.experimentalClientCapabilities;
			}
			if(options.experimentalClientCapabilities.supportedCommands == null) {
				options.experimentalClientCapabilities.supportedCommands = haxeLanguageServer_Configuration.DefaultInitOptions.experimentalClientCapabilities.supportedCommands;
			}
			if(options.haxelibConfig == null) {
				options.haxelibConfig = haxeLanguageServer_Configuration.DefaultInitOptions.haxelibConfig;
			}
			if(options.haxelibConfig.executable == null) {
				options.haxelibConfig.executable = haxeLanguageServer_Configuration.DefaultInitOptions.haxelibConfig.executable;
			}
			if(options.sendMethodResults == null) {
				options.sendMethodResults = haxeLanguageServer_Configuration.DefaultInitOptions.sendMethodResults;
			}
		}
		this.displayServer = options.displayServerConfig;
		this.displayArguments = options.displayArguments;
		this.haxelib = options.haxelibConfig;
		this.sendMethodResults = options.sendMethodResults;
	}
	onDidChangeConfiguration(newConfig) {
		let initialized = this.user != null;
		let newHaxeConfig = newConfig.settings.haxe;
		if(newHaxeConfig == null) {
			newHaxeConfig = { };
		}
		let newConfigJson = JSON.stringify(newHaxeConfig);
		let configUnchanged = this.unmodifiedUserConfig != null && JSON.stringify(this.unmodifiedUserConfig) == newConfigJson;
		if(initialized && configUnchanged) {
			return;
		}
		this.unmodifiedUserConfig = JSON.parse(newConfigJson);
		this.processSettings(newHaxeConfig);
		this.onDidChange(haxeLanguageServer_ConfigurationKind.User);
	}
	processSettings(newConfig) {
		Reflect.deleteField(newConfig,"displayServer");
		Reflect.deleteField(newConfig,"displayConfigurations");
		Reflect.deleteField(newConfig,"configurations");
		Reflect.deleteField(newConfig,"executable");
		this.user = newConfig;
		if(newConfig.codeGeneration != null) {
			newConfig.codeGeneration.switch_ = Reflect.field(newConfig.codeGeneration,"switch");
			Reflect.deleteField(newConfig.codeGeneration,"switch");
		}
		if(this.user == null) {
			this.user = haxeLanguageServer_Configuration.DefaultUserSettings;
		} else {
			if(this.user.buildCompletionCache == null) {
				this.user.buildCompletionCache = haxeLanguageServer_Configuration.DefaultUserSettings.buildCompletionCache;
			}
			if(this.user.codeGeneration == null) {
				this.user.codeGeneration = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration;
			}
			if(this.user.codeGeneration.functions == null) {
				this.user.codeGeneration.functions = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions;
			}
			if(this.user.codeGeneration.functions.anonymous == null) {
				this.user.codeGeneration.functions.anonymous = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions.anonymous;
			}
			if(this.user.codeGeneration.functions.anonymous.argumentTypeHints == null) {
				this.user.codeGeneration.functions.anonymous.argumentTypeHints = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions.anonymous.argumentTypeHints;
			}
			if(this.user.codeGeneration.functions.anonymous.explicitNull == null) {
				this.user.codeGeneration.functions.anonymous.explicitNull = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions.anonymous.explicitNull;
			}
			if(this.user.codeGeneration.functions.anonymous.explicitPrivate == null) {
				this.user.codeGeneration.functions.anonymous.explicitPrivate = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions.anonymous.explicitPrivate;
			}
			if(this.user.codeGeneration.functions.anonymous.explicitPublic == null) {
				this.user.codeGeneration.functions.anonymous.explicitPublic = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions.anonymous.explicitPublic;
			}
			if(this.user.codeGeneration.functions.anonymous.placeOpenBraceOnNewLine == null) {
				this.user.codeGeneration.functions.anonymous.placeOpenBraceOnNewLine = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions.anonymous.placeOpenBraceOnNewLine;
			}
			if(this.user.codeGeneration.functions.anonymous.returnTypeHint == null) {
				this.user.codeGeneration.functions.anonymous.returnTypeHint = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions.anonymous.returnTypeHint;
			}
			if(this.user.codeGeneration.functions.anonymous.useArrowSyntax == null) {
				this.user.codeGeneration.functions.anonymous.useArrowSyntax = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions.anonymous.useArrowSyntax;
			}
			if(this.user.codeGeneration.functions.field == null) {
				this.user.codeGeneration.functions.field = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions.field;
			}
			if(this.user.codeGeneration.functions.field.argumentTypeHints == null) {
				this.user.codeGeneration.functions.field.argumentTypeHints = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions.field.argumentTypeHints;
			}
			if(this.user.codeGeneration.functions.field.explicitNull == null) {
				this.user.codeGeneration.functions.field.explicitNull = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions.field.explicitNull;
			}
			if(this.user.codeGeneration.functions.field.explicitPrivate == null) {
				this.user.codeGeneration.functions.field.explicitPrivate = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions.field.explicitPrivate;
			}
			if(this.user.codeGeneration.functions.field.explicitPublic == null) {
				this.user.codeGeneration.functions.field.explicitPublic = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions.field.explicitPublic;
			}
			if(this.user.codeGeneration.functions.field.placeOpenBraceOnNewLine == null) {
				this.user.codeGeneration.functions.field.placeOpenBraceOnNewLine = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions.field.placeOpenBraceOnNewLine;
			}
			if(this.user.codeGeneration.functions.field.returnTypeHint == null) {
				this.user.codeGeneration.functions.field.returnTypeHint = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions.field.returnTypeHint;
			}
			if(this.user.codeGeneration.functions.field.useArrowSyntax == null) {
				this.user.codeGeneration.functions.field.useArrowSyntax = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.functions.field.useArrowSyntax;
			}
			if(this.user.codeGeneration.imports == null) {
				this.user.codeGeneration.imports = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.imports;
			}
			if(this.user.codeGeneration.imports.enableAutoImports == null) {
				this.user.codeGeneration.imports.enableAutoImports = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.imports.enableAutoImports;
			}
			if(this.user.codeGeneration.imports.style == null) {
				this.user.codeGeneration.imports.style = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.imports.style;
			}
			if(this.user.codeGeneration.switch_ == null) {
				this.user.codeGeneration.switch_ = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.switch_;
			}
			if(this.user.codeGeneration.switch_.parentheses == null) {
				this.user.codeGeneration.switch_.parentheses = haxeLanguageServer_Configuration.DefaultUserSettings.codeGeneration.switch_.parentheses;
			}
			if(this.user.diagnosticsPathFilter == null) {
				this.user.diagnosticsPathFilter = haxeLanguageServer_Configuration.DefaultUserSettings.diagnosticsPathFilter;
			}
			if(this.user.displayPort == null) {
				this.user.displayPort = haxeLanguageServer_Configuration.DefaultUserSettings.displayPort;
			}
			if(this.user.enableCodeLens == null) {
				this.user.enableCodeLens = haxeLanguageServer_Configuration.DefaultUserSettings.enableCodeLens;
			}
			if(this.user.enableCompletionCacheWarning == null) {
				this.user.enableCompletionCacheWarning = haxeLanguageServer_Configuration.DefaultUserSettings.enableCompletionCacheWarning;
			}
			if(this.user.enableDiagnostics == null) {
				this.user.enableDiagnostics = haxeLanguageServer_Configuration.DefaultUserSettings.enableDiagnostics;
			}
			if(this.user.enableServerView == null) {
				this.user.enableServerView = haxeLanguageServer_Configuration.DefaultUserSettings.enableServerView;
			}
			if(this.user.enableSignatureHelpDocumentation == null) {
				this.user.enableSignatureHelpDocumentation = haxeLanguageServer_Configuration.DefaultUserSettings.enableSignatureHelpDocumentation;
			}
			if(this.user.exclude == null) {
				this.user.exclude = haxeLanguageServer_Configuration.DefaultUserSettings.exclude;
			}
			if(this.user.importsSortOrder == null) {
				this.user.importsSortOrder = haxeLanguageServer_Configuration.DefaultUserSettings.importsSortOrder;
			}
			if(this.user.inlayHints == null) {
				this.user.inlayHints = haxeLanguageServer_Configuration.DefaultUserSettings.inlayHints;
			}
			if(this.user.inlayHints.conditionals == null) {
				this.user.inlayHints.conditionals = haxeLanguageServer_Configuration.DefaultUserSettings.inlayHints.conditionals;
			}
			if(this.user.inlayHints.functionReturnTypes == null) {
				this.user.inlayHints.functionReturnTypes = haxeLanguageServer_Configuration.DefaultUserSettings.inlayHints.functionReturnTypes;
			}
			if(this.user.inlayHints.parameterNames == null) {
				this.user.inlayHints.parameterNames = haxeLanguageServer_Configuration.DefaultUserSettings.inlayHints.parameterNames;
			}
			if(this.user.inlayHints.parameterTypes == null) {
				this.user.inlayHints.parameterTypes = haxeLanguageServer_Configuration.DefaultUserSettings.inlayHints.parameterTypes;
			}
			if(this.user.inlayHints.variableTypes == null) {
				this.user.inlayHints.variableTypes = haxeLanguageServer_Configuration.DefaultUserSettings.inlayHints.variableTypes;
			}
			if(this.user.maxCompletionItems == null) {
				this.user.maxCompletionItems = haxeLanguageServer_Configuration.DefaultUserSettings.maxCompletionItems;
			}
			if(this.user.populateCacheFromDisplay == null) {
				this.user.populateCacheFromDisplay = haxeLanguageServer_Configuration.DefaultUserSettings.populateCacheFromDisplay;
			}
			if(this.user.postfixCompletion == null) {
				this.user.postfixCompletion = haxeLanguageServer_Configuration.DefaultUserSettings.postfixCompletion;
			}
			if(this.user.postfixCompletion.level == null) {
				this.user.postfixCompletion.level = haxeLanguageServer_Configuration.DefaultUserSettings.postfixCompletion.level;
			}
			if(this.user.renameSourceFolders == null) {
				this.user.renameSourceFolders = haxeLanguageServer_Configuration.DefaultUserSettings.renameSourceFolders;
			}
			if(this.user.serverRecording == null) {
				this.user.serverRecording = haxeLanguageServer_Configuration.DefaultUserSettings.serverRecording;
			}
			if(this.user.serverRecording.enabled == null) {
				this.user.serverRecording.enabled = haxeLanguageServer_Configuration.DefaultUserSettings.serverRecording.enabled;
			}
			if(this.user.serverRecording.exclude == null) {
				this.user.serverRecording.exclude = haxeLanguageServer_Configuration.DefaultUserSettings.serverRecording.exclude;
			}
			if(this.user.serverRecording.excludeUntracked == null) {
				this.user.serverRecording.excludeUntracked = haxeLanguageServer_Configuration.DefaultUserSettings.serverRecording.excludeUntracked;
			}
			if(this.user.serverRecording.path == null) {
				this.user.serverRecording.path = haxeLanguageServer_Configuration.DefaultUserSettings.serverRecording.path;
			}
			if(this.user.serverRecording.watch == null) {
				this.user.serverRecording.watch = haxeLanguageServer_Configuration.DefaultUserSettings.serverRecording.watch;
			}
			if(this.user.useLegacyCompletion == null) {
				this.user.useLegacyCompletion = haxeLanguageServer_Configuration.DefaultUserSettings.useLegacyCompletion;
			}
		}
	}
	onDidChangeDisplayArguments(params) {
		this.displayArguments = params.arguments;
		this.onDidChange(haxeLanguageServer_ConfigurationKind.DisplayArguments);
	}
	onDidChangeDisplayServerConfig(config) {
		this.displayServer = config;
		this.onDidChange(haxeLanguageServer_ConfigurationKind.DisplayServer);
	}
}
haxeLanguageServer_Configuration.__name__ = "haxeLanguageServer.Configuration";
Object.assign(haxeLanguageServer_Configuration.prototype, {
	__class__: haxeLanguageServer_Configuration
});
class haxeLanguageServer_Context {
	constructor(languageServerProtocol) {
		this.invalidated = new haxe_ds_StringMap();
		this.progressId = 0;
		this.initialized = false;
		this.latestActiveFilePackage = "";
		this.languageServerProtocol = languageServerProtocol;
		this.serverRecording = new haxeLanguageServer_server_ServerRecording();
		this.haxeDisplayProtocol = new jsonrpc_Protocol($bind(this,this.writeMessage));
		this.haxeServer = new haxeLanguageServer_server_HaxeServer(this);
		this.documents = new haxeLanguageServer_documents_TextDocuments();
		let _gthis = this;
		this.config = new haxeLanguageServer_Configuration(languageServerProtocol,function(kind) {
			_gthis.restartServer("" + Std.string(kind) + " configuration was changed");
		});
		languageServerProtocol.onRequest("initialize",$bind(this,this.onInitialize));
		languageServerProtocol.onRequest("shutdown",$bind(this,this.onShutdown));
		languageServerProtocol.onNotification("exit",$bind(this,this.onExit));
		languageServerProtocol.onNotification("textDocument/didOpen",$bind(this,this.onDidOpenTextDocument));
		languageServerProtocol.onNotification("textDocument/didChange",$bind(this,this.onDidChangeTextDocument));
		languageServerProtocol.onNotification("textDocument/didClose",$bind(this,this.onDidCloseTextDocument));
		languageServerProtocol.onNotification("textDocument/didSave",$bind(this,this.onDidSaveTextDocument));
		languageServerProtocol.onNotification("workspace/didChangeWatchedFiles",$bind(this,this.onDidChangeWatchedFiles));
		languageServerProtocol.onNotification("haxe/didChangeActiveTextEditor",$bind(this,this.onDidChangeActiveTextEditor));
		languageServerProtocol.onRequest("haxe/runMethod",$bind(this,this.runMethod));
		languageServerProtocol.onRequest("haxe/exportServerRecording",($_=this.serverRecording,$bind($_,$_.export)));
	}
	writeMessage(message,token) {
		let method = Reflect.field(message,"method");
		if(method == "$/cancelRequest") {
			return;
		}
		let includeDisplayArguments = method.startsWith("display/") || method == "server/readClassPaths";
		let _gthis = this;
		this.callDisplay(method,[JSON.stringify(message)],null,token,function(result) {
			switch(result._hx_index) {
			case 0:
				break;
			case 1:
				_gthis.haxeDisplayProtocol.handleMessage(JSON.parse(result.msg));
				break;
			}
		},function(error) {
			let _gthis1 = _gthis.haxeDisplayProtocol;
			let tmp;
			try {
				tmp = JSON.parse(error);
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				let message = _gthis.haxeDisplayProtocol.nextRequestId - 1;
				let data = [{ severity : 1, message : error}];
				let this1 = { code : -32603, message : "Compiler error"};
				if(data != null) {
					this1.data = data;
				}
				tmp = { jsonrpc : "2.0", id : message, error : this1};
			}
			_gthis1.handleMessage(tmp);
		},includeDisplayArguments);
	}
	startProgress(title) {
		let _v_ = this.capabilities.window;
		if((_v_ == null ? null : _v_.workDoneProgress) == false) {
			return function() {
			};
		}
		let id = this.progressId++;
		this.languageServerProtocol.sendRequest("window/workDoneProgress/create",{ token : id});
		let _this = this.languageServerProtocol;
		let params = { token : id, value : { kind : "begin", title : "Haxe: " + title + "..."}};
		let message = { jsonrpc : "2.0", method : "$/progress"};
		if(params != null) {
			message.params = params;
		}
		_this.writeMessage(message,null);
		if(_this.didSendNotification != null) {
			_this.didSendNotification(message);
		}
		let _gthis = this;
		return function() {
			let _this = _gthis.languageServerProtocol;
			let params = { token : id, value : { kind : "end"}};
			let message = { jsonrpc : "2.0", method : "$/progress"};
			if(params != null) {
				message.params = params;
			}
			_this.writeMessage(message,null);
			if(_this.didSendNotification != null) {
				_this.didSendNotification(message);
			}
		};
	}
	resetInvalidatedFiles() {
		this.invalidated = new haxe_ds_StringMap();
	}
	onInitialize(params,_,resolve,_1) {
		if(params.rootUri != null) {
			this.workspacePath = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(params.rootUri);
		}
		this.capabilities = params.capabilities;
		this.capabilities.experimental = this.capabilities.experimental != null ? this.capabilities.experimental : { };
		let initOptions = params.initializationOptions;
		let experimentals = initOptions == null ? null : initOptions.experimentalClientCapabilities;
		if(experimentals != null) {
			this.capabilities.experimental.supportedCommands = experimentals.supportedCommands;
		}
		this.config.onInitialize(params);
		this.serverRecording.onInitialize(this);
		new haxeLanguageServer_features_haxe_documentSymbols_DocumentSymbolsFeature(this);
		new haxeLanguageServer_features_haxe_foldingRange_FoldingRangeFeature(this);
		new haxeLanguageServer_features_haxe_DocumentFormattingFeature(this);
		new haxeLanguageServer_features_haxe_ColorProviderFeature(this);
		new haxeLanguageServer_features_haxe_InlayHintFeature(this);
		let _v_ = this.capabilities;
		let textDocument = _v_ == null ? null : _v_.textDocument;
		let _v_1 = this.capabilities;
		let workspace = _v_1 == null ? null : _v_1.workspace;
		let registrations = [];
		let register = function(method,registerId,selector,registerOptions) {
			if(registerOptions == null) {
				registerOptions = { documentSelector : selector};
			}
			registrations.push({ id : registerId != null ? registerId : "" + method, method : method, registerOptions : registerOptions});
		};
		let capabilities = { textDocumentSync : { openClose : true, change : 2, save : { includeText : false}}};
		let completionTriggerCharacters = [".","@",":"," ",">","$"];
		let _v_2 = textDocument;
		let _v_3 = _v_2 == null ? null : _v_2.completion;
		if((_v_3 == null ? null : _v_3.dynamicRegistration) == true) {
			register("textDocument/completion","haxeDocument/completion",null,{ documentSelector : haxeLanguageServer_Context.haxeSelector, triggerCharacters : completionTriggerCharacters, resolveProvider : true});
			register("textDocument/completion","hxmlDocument/completion",null,{ documentSelector : haxeLanguageServer_Context.hxmlSelector, triggerCharacters : ["-","/","\\","="," "], resolveProvider : true});
		} else {
			capabilities.completionProvider = { triggerCharacters : completionTriggerCharacters, resolveProvider : true};
		}
		let signatureHelpTriggerCharacters = ["(",","];
		let _v_4 = textDocument;
		let _v_5 = _v_4 == null ? null : _v_4.signatureHelp;
		if((_v_5 == null ? null : _v_5.dynamicRegistration) == true) {
			register("textDocument/signatureHelp",null,null,{ documentSelector : haxeLanguageServer_Context.haxeSelector, triggerCharacters : signatureHelpTriggerCharacters});
		} else {
			capabilities.signatureHelpProvider = { triggerCharacters : signatureHelpTriggerCharacters};
		}
		let _v_6 = textDocument;
		let _v_7 = _v_6 == null ? null : _v_6.definition;
		if((_v_7 == null ? null : _v_7.dynamicRegistration) == true) {
			register("textDocument/definition",null,haxeLanguageServer_Context.haxeSelector);
		} else {
			capabilities.definitionProvider = true;
		}
		let _v_8 = textDocument;
		let _v_9 = _v_8 == null ? null : _v_8.hover;
		if((_v_9 == null ? null : _v_9.dynamicRegistration) == true) {
			register("textDocument/hover","haxeDocument/hover",haxeLanguageServer_Context.haxeSelector);
			register("textDocument/hover","hxmlDocument/hover",haxeLanguageServer_Context.hxmlSelector);
		} else {
			capabilities.hoverProvider = true;
		}
		let _v_10 = textDocument;
		let _v_11 = _v_10 == null ? null : _v_10.references;
		if((_v_11 == null ? null : _v_11.dynamicRegistration) == true) {
			register("textDocument/references",null,haxeLanguageServer_Context.haxeSelector);
		} else {
			capabilities.referencesProvider = true;
		}
		let _v_12 = textDocument;
		let _v_13 = _v_12 == null ? null : _v_12.documentSymbol;
		if((_v_13 == null ? null : _v_13.dynamicRegistration) == true) {
			register("textDocument/documentSymbol",null,haxeLanguageServer_Context.haxeSelector);
		} else {
			capabilities.documentSymbolProvider = true;
		}
		let _v_14 = workspace;
		let _v_15 = _v_14 == null ? null : _v_14.symbol;
		if((_v_15 == null ? null : _v_15.dynamicRegistration) == true) {
			register("workspace/symbol",null,haxeLanguageServer_Context.haxeSelector);
		} else {
			capabilities.workspaceSymbolProvider = true;
		}
		let _v_16 = textDocument;
		let _v_17 = _v_16 == null ? null : _v_16.formatting;
		if((_v_17 == null ? null : _v_17.dynamicRegistration) == true) {
			register("textDocument/formatting",null,haxeLanguageServer_Context.haxeSelector);
		} else {
			capabilities.documentFormattingProvider = true;
		}
		let _v_18 = textDocument;
		let _v_19 = _v_18 == null ? null : _v_18.rangeFormatting;
		if((_v_19 == null ? null : _v_19.dynamicRegistration) == true) {
			register("textDocument/rangeFormatting",null,haxeLanguageServer_Context.haxeSelector);
		} else {
			capabilities.documentRangeFormattingProvider = true;
		}
		let _v_20 = textDocument;
		let _v_21 = _v_20 == null ? null : _v_20.rename;
		if((_v_21 == null ? null : _v_21.dynamicRegistration) == true) {
			register("textDocument/rename",null,null,{ documentSelector : haxeLanguageServer_Context.haxeSelector, prepareProvider : true});
		} else {
			let _v_ = textDocument;
			let _v_1 = _v_ == null ? null : _v_.rename;
			if((_v_1 == null ? null : _v_1.prepareSupport) == true) {
				capabilities.renameProvider = { prepareProvider : true};
			} else {
				capabilities.renameProvider = true;
			}
		}
		let _v_22 = textDocument;
		let _v_23 = _v_22 == null ? null : _v_22.foldingRange;
		if((_v_23 == null ? null : _v_23.dynamicRegistration) == true) {
			register("textDocument/foldingRange",null,haxeLanguageServer_Context.haxeSelector);
		} else {
			capabilities.foldingRangeProvider = true;
		}
		let _v_24 = textDocument;
		let _v_25 = _v_24 == null ? null : _v_24.colorProvider;
		if((_v_25 == null ? null : _v_25.dynamicRegistration) == true) {
			register("textDocument/documentColor",null,haxeLanguageServer_Context.haxeSelector);
		} else {
			capabilities.colorProvider = true;
		}
		let _v_26 = textDocument;
		let _v_27 = _v_26 == null ? null : _v_26.inlayHint;
		if((_v_27 == null ? null : _v_27.dynamicRegistration) == true) {
			register("textDocument/inlayHint",null,haxeLanguageServer_Context.haxeSelector);
		} else {
			capabilities.inlayHintProvider = true;
		}
		resolve({ capabilities : capabilities});
		this.languageServerProtocol.sendRequest("client/registerCapability",{ registrations : registrations},null,function(_) {
		},function(error) {
			haxe_Log.trace(error,{ fileName : "src/haxeLanguageServer/Context.hx", lineNumber : 300, className : "haxeLanguageServer.Context", methodName : "onInitialize"});
		});
	}
	onShutdown(_,_1,resolve,_2) {
		this.haxeServer.stop();
		resolve(null);
	}
	onExit(_) {
		if(this.haxeServer != null) {
			this.haxeServer.stop();
			process.exit(1);
		} else {
			process.exit(0);
		}
	}
	onServerStarted() {
		this.displayOffsetConverter = haxeLanguageServer_helper_DisplayOffsetConverter.create(this.haxeServer.haxeVersion);
		this.handleRegistration("display/typeDefinition","textDocument/typeDefinition",{ documentSelector : haxeLanguageServer_Context.haxeSelector});
		this.handleRegistration("display/implementation","textDocument/implementation",{ documentSelector : haxeLanguageServer_Context.haxeSelector});
	}
	handleRegistration(displayMethod,lspMethod,registerOptions) {
		if(this.haxeServer.supports(displayMethod)) {
			this.registerCapability(lspMethod,null,registerOptions);
		} else {
			this.unregisterCapability(lspMethod);
		}
	}
	registerCapability(method,registerId,registerOptions) {
		this.languageServerProtocol.sendRequest("client/registerCapability",{ registrations : [{ id : registerId != null ? registerId : "" + method, method : method, registerOptions : registerOptions}]},null,function(_) {
		},function(error) {
			haxe_Log.trace(error,{ fileName : "src/haxeLanguageServer/Context.hx", lineNumber : 342, className : "haxeLanguageServer.Context", methodName : "registerCapability"});
		});
	}
	unregisterCapability(method,registerId) {
		this.languageServerProtocol.sendRequest("client/unregisterCapability",{ unregisterations : [{ id : registerId != null ? registerId : "" + method, method : method}]},null,function(_) {
		},function(error) {
			haxe_Log.trace(error,{ fileName : "src/haxeLanguageServer/Context.hx", lineNumber : 353, className : "haxeLanguageServer.Context", methodName : "unregisterCapability"});
		});
	}
	hasClientCommandSupport(command) {
		let experimental;
		let tmp = this.capabilities.experimental;
		if(tmp != null) {
			experimental = tmp;
		} else {
			return false;
		}
		let tmp1 = experimental.supportedCommands;
		if(tmp1 == null) {
			return false;
		}
		return tmp1.includes(command);
	}
	restartServer(reason) {
		this.serverRecording.restartServer(reason,this);
		let _gthis = this;
		if(!this.initialized) {
			this.haxeServer.start(function() {
				_gthis.onServerStarted();
				new haxeLanguageServer_features_CompletionFeature(_gthis);
				new haxeLanguageServer_features_HoverFeature(_gthis);
				new haxeLanguageServer_features_haxe_SignatureHelpFeature(_gthis);
				_gthis.gotoDefinition = new haxeLanguageServer_features_haxe_GotoDefinitionFeature(_gthis);
				new haxeLanguageServer_features_haxe_GotoImplementationFeature(_gthis);
				new haxeLanguageServer_features_haxe_GotoTypeDefinitionFeature(_gthis);
				_gthis.findReferences = new haxeLanguageServer_features_haxe_FindReferencesFeature(_gthis);
				_gthis.determinePackage = new haxeLanguageServer_features_haxe_DeterminePackageFeature(_gthis);
				new haxeLanguageServer_features_haxe_RenameFeature(_gthis);
				_gthis.diagnostics = new haxeLanguageServer_features_haxe_DiagnosticsFeature(_gthis);
				new haxeLanguageServer_features_haxe_codeAction_CodeActionFeature(_gthis);
				new haxeLanguageServer_features_haxe_CodeLensFeature(_gthis);
				new haxeLanguageServer_features_haxe_WorkspaceSymbolsFeature(_gthis);
				let h = _gthis.documents.documents.h;
				let doc_keys = Object.keys(h);
				let doc_length = doc_keys.length;
				let doc_current = 0;
				while(doc_current < doc_length) _gthis.publishDiagnostics(h[doc_keys[doc_current++]].uri);
				_gthis.initialized = true;
			});
		} else {
			this.haxeServer.restart(reason,function() {
				_gthis.onServerStarted();
				if(_gthis.activeEditor != null) {
					_gthis.publishDiagnostics(_gthis.activeEditor);
				}
			});
		}
	}
	isUriSupported(uri) {
		if(!haxeLanguageServer_extensions_DocumentUriExtensions_isFile(uri)) {
			return haxeLanguageServer_extensions_DocumentUriExtensions_isUntitled(uri);
		} else {
			return true;
		}
	}
	onDidOpenTextDocument(event) {
		let uri = event.textDocument.uri;
		if(this.isUriSupported(uri)) {
			this.activeEditor = uri;
			this.documents.onDidOpenTextDocument(event);
			this.publishDiagnostics(uri);
		}
	}
	onDidChangeTextDocument(event) {
		let uri = event.textDocument.uri;
		if(this.isUriSupported(uri)) {
			this.serverRecording.onDidChangeTextDocument(event);
			this.invalidateFile(uri);
			this.documents.onDidChangeTextDocument(event);
		}
	}
	onDidCloseTextDocument(event) {
		let uri = event.textDocument.uri;
		if(this.isUriSupported(uri)) {
			this.documents.onDidCloseTextDocument(event);
			this.diagnostics.clearDiagnostics(uri);
		}
	}
	onDidSaveTextDocument(event) {
		let uri = event.textDocument.uri;
		if(this.isUriSupported(uri)) {
			this.publishDiagnostics(uri);
			let _this = this.invalidated;
			let key = uri;
			if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
				delete(_this.h[key]);
			}
		}
	}
	onDidChangeWatchedFiles(event) {
		let _g = 0;
		let _g1 = event.changes;
		while(_g < _g1.length) {
			let change = _g1[_g];
			++_g;
			this.serverRecording.onFileEvent(change);
			switch(change.type) {
			case 1:
				this.callFileParamsMethod(change.uri,"server/moduleCreated");
				break;
			case 3:
				this.diagnostics.clearDiagnostics(change.uri);
				this.invalidateFile(change.uri);
				break;
			default:
			}
		}
	}
	invalidateFile(uri) {
		if(!Object.prototype.hasOwnProperty.call(this.invalidated.h,uri)) {
			this.callFileParamsMethod(uri,"server/invalidate");
			this.invalidated.h[uri] = true;
		}
	}
	callFileParamsMethod(uri,method) {
		if(haxeLanguageServer_extensions_DocumentUriExtensions_isFile(uri) && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri) && this.haxeServer.supports(method)) {
			this.callHaxeMethod(method,{ file : haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri)},null,function(_) {
				return null;
			},function(error) {
				haxe_Log.trace("Error during " + method + " " + error,{ fileName : "src/haxeLanguageServer/Context.hx", lineNumber : 461, className : "haxeLanguageServer.Context", methodName : "callFileParamsMethod"});
			});
		}
	}
	onDidChangeActiveTextEditor(params) {
		this.activeEditor = params.uri;
		let uri = params.uri;
		let value = this.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let document = doc;
		if(document == null) {
			return;
		}
		let hrtime = process.hrtime();
		if(hrtime[0] + hrtime[1] / 1e9 - document.openTimestamp > 0.1) {
			this.publishDiagnostics(params.uri);
			let key = this.activeEditor;
			let _this = this.invalidated;
			if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
				delete(_this.h[key]);
			}
		}
		this.updateActiveEditorPackage(this.activeEditor);
	}
	updateActiveEditorPackage(uri) {
		if(this.determinePackage == null || !haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			this.latestActiveFilePackage = "";
			return;
		}
		let _gthis = this;
		this.determinePackage.onDeterminePackage({ fsPath : haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri)},null,function(result) {
			_gthis.latestActiveFilePackage = result.pack;
		},function(error) {
			_gthis.latestActiveFilePackage = "";
		});
	}
	publishDiagnostics(uri) {
		if(this.diagnostics != null && this.config.user.enableDiagnostics) {
			this.diagnostics.publishDiagnostics(uri);
		}
	}
	runMethod(params,token,resolve,reject) {
		this.callHaxeMethod(params.method,params.params,token,function(response) {
			resolve(response);
			return null;
		},function(error) {
			let reject1 = reject;
			let data = null;
			let this1 = { code : 0, message : error};
			if(data != null) {
				this1.data = data;
			}
			reject1(this1);
		});
	}
	callHaxeMethod(method,params,token,callback,errback) {
		let beforeCallTime = new Date().getTime();
		let _gthis = this;
		this.haxeDisplayProtocol.sendRequest(method,params,token,function(response) {
			let arrivalTime = new Date().getTime();
			if(!_gthis.config.sendMethodResults) {
				callback(response.result);
				return;
			}
			let beforeProcessingTime = new Date().getTime();
			let debugInfo;
			try {
				debugInfo = callback(response.result);
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g);
				errback(_g1.toString());
				haxe_Log.trace(_g1,{ fileName : "src/haxeLanguageServer/Context.hx", lineNumber : 524, className : "haxeLanguageServer.Context", methodName : "callHaxeMethod"});
				let tmp = _g1.get_stack();
				haxe_Log.trace(tmp == null ? "null" : haxe_CallStack.toString(tmp),{ fileName : "src/haxeLanguageServer/Context.hx", lineNumber : 525, className : "haxeLanguageServer.Context", methodName : "callHaxeMethod"});
				debugInfo = null;
			}
			let afterProcessingTime = new Date().getTime();
			let methodResult = { kind : "Haxe", method : method, debugInfo : debugInfo, additionalTimes : { beforeCall : beforeCallTime, arrival : arrivalTime, beforeProcessing : beforeProcessingTime, afterProcessing : afterProcessingTime}, response : response};
			let _this = _gthis.languageServerProtocol;
			let message = { jsonrpc : "2.0", method : "haxe/didRunHaxeMethod"};
			if(methodResult != null) {
				message.params = methodResult;
			}
			_this.writeMessage(message,null);
			if(_this.didSendNotification != null) {
				_this.didSendNotification(message);
			}
		},function(error) {
			errback(error.data != null ? error.data[0].message : "unknown error");
		});
	}
	callDisplay(label,args,stdin,token,callback,errback,includeDisplayArguments) {
		if(includeDisplayArguments == null) {
			includeDisplayArguments = true;
		}
		let actualArgs = [];
		if(includeDisplayArguments) {
			actualArgs = actualArgs.concat(["--cwd",this.workspacePath,"-D","display-details","--no-output"]);
		}
		if(this.haxeServer.supports("initialize") && this.config.user.enableServerView) {
			actualArgs = actualArgs.concat(["--times","-D","macro-times"]);
		}
		if(includeDisplayArguments && this.config.displayArguments != null) {
			actualArgs = actualArgs.concat(this.config.displayArguments);
		}
		actualArgs.push("--display");
		actualArgs = actualArgs.concat(args);
		this.haxeServer.process(label,actualArgs,token,true,stdin,haxeLanguageServer_server_ResultHandler.Processed(callback,errback));
	}
	startTimer(method) {
		let startTime = new Date().getTime();
		let _gthis = this;
		return function(result,debugInfo) {
			if(_gthis.config.sendMethodResults) {
				let _this = _gthis.languageServerProtocol;
				let params = { kind : "Haxe", method : method, debugInfo : debugInfo, response : { timestamp : 0, timers : { name : method, time : (new Date().getTime() - startTime) / 1000}, result : result}};
				let message = { jsonrpc : "2.0", method : "haxe/didRunHaxeMethod"};
				if(params != null) {
					message.params = params;
				}
				_this.writeMessage(message,null);
				if(_this.didSendNotification != null) {
					_this.didSendNotification(message);
				}
			}
		};
	}
}
haxeLanguageServer_Context.__name__ = "haxeLanguageServer.Context";
Object.assign(haxeLanguageServer_Context.prototype, {
	__class__: haxeLanguageServer_Context
});
function haxeLanguageServer_Main_main() {
	let reader = new jsonrpc_node_MessageReader(process.stdin);
	let writer = new jsonrpc_node_MessageWriter(process.stdout);
	let languageServerProtocol = new jsonrpc_Protocol($bind(writer,writer.write));
	languageServerProtocol.logError = function(message) {
		let params = { type : 2, message : message};
		let message1 = { jsonrpc : "2.0", method : "window/logMessage"};
		if(params != null) {
			message1.params = params;
		}
		languageServerProtocol.writeMessage(message1,null);
		if(languageServerProtocol.didSendNotification != null) {
			languageServerProtocol.didSendNotification(message1);
		}
	};
	haxeLanguageServer_Main_setupTrace(languageServerProtocol);
	let context = new haxeLanguageServer_Context(languageServerProtocol);
	reader.listen($bind(languageServerProtocol,languageServerProtocol.handleMessage));
	let log = function(method,data) {
		if(context.config.sendMethodResults) {
			let params = { kind : "Lsp", method : method, debugInfo : null, response : { result : data}};
			let message = { jsonrpc : "2.0", method : "haxe/didRunHaxeMethod"};
			if(params != null) {
				message.params = params;
			}
			languageServerProtocol.writeMessage(message,null);
			if(languageServerProtocol.didSendNotification != null) {
				languageServerProtocol.didSendNotification(message);
			}
		}
	};
	languageServerProtocol.didRespondToRequest = function(request,response) {
		log(request.method,{ request : request, response : response});
	};
	languageServerProtocol.didSendNotification = function(notification) {
		if(notification.method != "window/logMessage" && !notification.method.startsWith("haxe/")) {
			log(notification.method,notification);
		}
	};
}
function haxeLanguageServer_Main_setupTrace(languageServerProtocol) {
	haxe_Log.trace = function(v,i) {
		let r = [Std.string(v)];
		if(i != null && i.customParams != null) {
			let _g = 0;
			let _g1 = i.customParams;
			while(_g < _g1.length) r.push(Std.string(_g1[_g++]));
		}
		let params = { type : 4, message : r.join(" ")};
		let message = { jsonrpc : "2.0", method : "window/logMessage"};
		if(params != null) {
			message.params = params;
		}
		languageServerProtocol.writeMessage(message,null);
		if(languageServerProtocol.didSendNotification != null) {
			languageServerProtocol.didSendNotification(message);
		}
	};
}
class haxeLanguageServer_documents_HxTextDocument {
	constructor(uri,languageId,version,content) {
		this.onUpdateListeners = [];
		this.uri = uri;
		this.languageId = languageId;
		let hrtime = process.hrtime();
		this.openTimestamp = hrtime[0] + hrtime[1] / 1e9;
		this.version = version;
		this.content = content;
	}
	update(events,version) {
		let _g = 0;
		let _g1 = this.onUpdateListeners;
		while(_g < _g1.length) _g1[_g++](this,events,version);
		this.version = version;
		let _g2 = 0;
		while(_g2 < events.length) {
			let event = events[_g2];
			++_g2;
			if(event.range == null) {
				this.content = event.text;
				this.lineOffsets = null;
			} else {
				let startOffset = this.offsetAt(event.range.start);
				let endOffset = this.offsetAt(event.range.end);
				this.content = this.content.substring(0,startOffset) + event.text + this.content.substring(endOffset);
				let startLine = Math.max(event.range.start.line,0) | 0;
				let endLine = Math.max(event.range.end.line,0) | 0;
				let addedLineOffsets = this.computeLineOffsets(event.text,false,startOffset);
				if(endLine - startLine == addedLineOffsets.length) {
					let _g = 0;
					let _g1 = addedLineOffsets.length;
					while(_g < _g1) {
						let i = _g++;
						let value = this.lineOffsets;
						if(value == null) {
							throw new safety_NullPointerException("Null pointer in .sure() call");
						}
						value[i + startLine + 1] = addedLineOffsets[i];
					}
				} else {
					let value = this.lineOffsets;
					if(value == null) {
						throw new safety_NullPointerException("Null pointer in .sure() call");
					}
					let tmp = value.slice(0,startLine + 1).concat(addedLineOffsets);
					let value1 = this.lineOffsets;
					if(value1 == null) {
						throw new safety_NullPointerException("Null pointer in .sure() call");
					}
					this.lineOffsets = tmp.concat(value1.slice(endLine + 1));
				}
				let diff = event.text.length - (endOffset - startOffset);
				if(diff != 0) {
					let _g = startLine + 1 + addedLineOffsets.length;
					let value = this.lineOffsets;
					if(value == null) {
						throw new safety_NullPointerException("Null pointer in .sure() call");
					}
					let _g1 = value.length;
					while(_g < _g1) {
						let i = _g++;
						let value = this.lineOffsets;
						if(value == null) {
							throw new safety_NullPointerException("Null pointer in .sure() call");
						}
						let value1 = this.lineOffsets;
						if(value1 == null) {
							throw new safety_NullPointerException("Null pointer in .sure() call");
						}
						value[i] = value1[i] + diff;
					}
				}
			}
		}
	}
	positionAt(offset,offsetKind) {
		if(offsetKind == null) {
			offsetKind = 1;
		}
		if(offsetKind == 0) {
			offset = this.utf8Offset(this.content,offset,1);
		}
		offset = Math.max(Math.min(offset,this.content.length),0) | 0;
		let lineOffsets = this.getLineOffsets();
		let low = 0;
		let high = lineOffsets.length;
		if(high == 0) {
			return { line : 0, character : offset};
		}
		while(low < high) {
			let mid = (low + high) / 2 | 0;
			if(lineOffsets[mid] > offset) {
				high = mid;
			} else {
				low = mid + 1;
			}
		}
		let line = low - 1;
		return { line : line, character : offset - lineOffsets[line]};
	}
	lineRangeAt(offsetInLine) {
		let start = this.positionAt(offsetInLine);
		let line = this.lineAt(start.line);
		return { start : { line : start.line, character : 0}, end : { line : start.line, character : StringTools.rtrim(line).length}};
	}
	lineAt(line) {
		let lineOffsets = this.getLineOffsets();
		if(line >= lineOffsets.length) {
			return "";
		} else if(line == lineOffsets.length - 1) {
			return this.content.substring(lineOffsets[line]);
		} else {
			return this.content.substring(lineOffsets[line],lineOffsets[line + 1]);
		}
	}
	offsetAt(position) {
		let lineOffsets = this.getLineOffsets();
		if(position.line >= lineOffsets.length) {
			return this.content.length;
		} else if(position.line < 0) {
			return 0;
		}
		let lineOffset = lineOffsets[position.line];
		return Math.max(Math.min(lineOffset + position.character,position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this.content.length),lineOffset) | 0;
	}
	indentAt(line) {
		let re = new EReg("^\\s*","");
		re.match(this.lineAt(line));
		return re.matched(0);
	}
	getText(range) {
		if(range == null) {
			return this.content;
		}
		return this.content.substring(this.offsetAt(range.start),this.offsetAt(range.end));
	}
	addUpdateListener(listener) {
		this.onUpdateListeners.push(listener);
	}
	removeUpdateListener(listener) {
		HxOverrides.remove(this.onUpdateListeners,listener);
	}
	getLineOffsets() {
		if(this.lineOffsets == null) {
			this.lineOffsets = this.computeLineOffsets(this.content,true);
		}
		return this.lineOffsets;
	}
	computeLineOffsets(text,isLineStart,offset) {
		if(offset == null) {
			offset = 0;
		}
		let offsets = isLineStart ? [offset] : [];
		let i = 0;
		while(i < text.length) {
			let ch = HxOverrides.cca(text,i);
			if(ch == 13 && i + 1 < text.length && HxOverrides.cca(text,i + 1) == 10) {
				++i;
			}
			++i;
			if(ch == 13 || ch == 10) {
				offsets.push(offset + i);
			}
		}
		return offsets;
	}
	utf8Offset(string,offset,direction) {
		let ret = offset;
		let i = 0;
		let j = 0;
		while(j < string.length && i < offset) {
			let value = HxOverrides.cca(string,j);
			if(value == null) {
				throw new safety_NullPointerException("Null pointer in .sure() call");
			}
			if(!(value >= 0 && value <= 127)) {
				if(value >= 128 && value <= 2047) {
					ret -= direction;
				} else if(value >= 55296 && value < 56320) {
					ret -= direction * 2;
					++j;
				} else if(value >= 2048 && value <= 65535) {
					ret -= direction * 2;
				} else if(value >= 65536 && value <= 1114111) {
					ret -= direction * 3;
				}
			}
			++i;
			++j;
		}
		return ret;
	}
}
haxeLanguageServer_documents_HxTextDocument.__name__ = "haxeLanguageServer.documents.HxTextDocument";
Object.assign(haxeLanguageServer_documents_HxTextDocument.prototype, {
	__class__: haxeLanguageServer_documents_HxTextDocument
});
class haxeLanguageServer_documents_HaxeDocument extends haxeLanguageServer_documents_HxTextDocument {
	constructor(uri,languageId,version,content) {
		super(uri,languageId,version,content);
	}
	update(events,version) {
		super.update(events,version);
		this._parseTree = null;
		this._tokens = null;
	}
	get_tokens() {
		if(this._tokens == null) {
			try {
				this._tokens = haxeLanguageServer_tokentree_TokenTreeManager.create(this.content);
			} catch( _g ) {
			}
		}
		return this._tokens;
	}
}
haxeLanguageServer_documents_HaxeDocument.__name__ = "haxeLanguageServer.documents.HaxeDocument";
haxeLanguageServer_documents_HaxeDocument.__super__ = haxeLanguageServer_documents_HxTextDocument;
Object.assign(haxeLanguageServer_documents_HaxeDocument.prototype, {
	__class__: haxeLanguageServer_documents_HaxeDocument
});
class haxeLanguageServer_documents_HxmlDocument extends haxeLanguageServer_documents_HxTextDocument {
	constructor(uri,languageId,version,content) {
		super(uri,languageId,version,content);
	}
}
haxeLanguageServer_documents_HxmlDocument.__name__ = "haxeLanguageServer.documents.HxmlDocument";
haxeLanguageServer_documents_HxmlDocument.__super__ = haxeLanguageServer_documents_HxTextDocument;
Object.assign(haxeLanguageServer_documents_HxmlDocument.prototype, {
	__class__: haxeLanguageServer_documents_HxmlDocument
});
class haxeLanguageServer_documents_TextDocuments {
	constructor() {
		this.documents = new haxe_ds_StringMap();
	}
	onDidOpenTextDocument(event) {
		let td = event.textDocument;
		let uri = td.uri;
		if(haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			let this1 = this.documents;
			let k = td.uri;
			let v = new haxeLanguageServer_documents_HaxeDocument(td.uri,td.languageId,td.version,td.text);
			this1.h[k] = v;
		} else if(haxeLanguageServer_extensions_DocumentUriExtensions_isHxmlFile(uri)) {
			let this1 = this.documents;
			let k = td.uri;
			let v = new haxeLanguageServer_documents_HxmlDocument(td.uri,td.languageId,td.version,td.text);
			this1.h[k] = v;
		} else {
			throw haxe_Exception.thrown((uri == null ? "null" : uri) + " has unsupported file type (must be .hx or .hxml)");
		}
	}
	onDidChangeTextDocument(event) {
		let td = event.textDocument;
		let changes = event.contentChanges;
		if(changes.length == 0) {
			return;
		}
		let document = this.documents.h[td.uri];
		if(document != null) {
			document.update(changes,td.version);
		}
	}
	onDidCloseTextDocument(event) {
		let _this = this.documents;
		let key = event.textDocument.uri;
		if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
			delete(_this.h[key]);
		}
	}
}
haxeLanguageServer_documents_TextDocuments.__name__ = "haxeLanguageServer.documents.TextDocuments";
Object.assign(haxeLanguageServer_documents_TextDocuments.prototype, {
	__class__: haxeLanguageServer_documents_TextDocuments
});
function haxeLanguageServer_extensions_ArrayExtensions_filterDuplicates(array,filter) {
	let unique = [];
	let _g = 0;
	while(_g < array.length) {
		let element = array[_g];
		++_g;
		let present = false;
		let _g1 = 0;
		while(_g1 < unique.length) if(filter(unique[_g1++],element)) {
			present = true;
		}
		if(!present) {
			unique.push(element);
		}
	}
	return unique;
}
function haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri) {
	if(!haxeLanguageServer_extensions_DocumentUriExtensions_uriRe.match(uri) || haxeLanguageServer_extensions_DocumentUriExtensions_uriRe.matched(2) != "file") {
		throw haxe_Exception.thrown("Invalid uri: " + (uri == null ? "null" : uri));
	}
	let s = haxeLanguageServer_extensions_DocumentUriExtensions_uriRe.matched(5);
	let path = decodeURIComponent(s.split("+").join(" "));
	if(haxeLanguageServer_extensions_DocumentUriExtensions_driveLetterPathRe.match(path)) {
		return path.charAt(1).toLowerCase() + HxOverrides.substr(path,2,null);
	} else {
		return path;
	}
}
function haxeLanguageServer_extensions_DocumentUriExtensions_isFile(uri) {
	return uri.startsWith("file://");
}
function haxeLanguageServer_extensions_DocumentUriExtensions_isUntitled(uri) {
	return uri.startsWith("untitled:");
}
function haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri) {
	return uri.endsWith(".hx");
}
function haxeLanguageServer_extensions_DocumentUriExtensions_isHxmlFile(uri) {
	return uri.endsWith(".hxml");
}
function haxeLanguageServer_extensions_FsPathExtensions_toUri(path) {
	let path1 = path;
	path1 = StringTools.replace(path1,"\\","/");
	if(path1.charCodeAt(0) != 47) {
		path1 = "/" + path1;
	}
	let parts = ["file://"];
	if(haxeLanguageServer_extensions_FsPathExtensions_upperCaseDriveRe.match(path1)) {
		path1 = haxeLanguageServer_extensions_FsPathExtensions_upperCaseDriveRe.matched(1) + haxeLanguageServer_extensions_FsPathExtensions_upperCaseDriveRe.matched(2).toLowerCase() + haxeLanguageServer_extensions_FsPathExtensions_upperCaseDriveRe.matchedRight();
	}
	let lastIdx = 0;
	while(true) {
		let idx = path1.indexOf("/",lastIdx);
		if(idx == -1) {
			parts.push(haxeLanguageServer_extensions_FsPathExtensions_urlEncode2(path1.substring(lastIdx)));
			break;
		}
		parts.push(haxeLanguageServer_extensions_FsPathExtensions_urlEncode2(path1.substring(lastIdx,idx)));
		parts.push("/");
		lastIdx = idx + 1;
	}
	return parts.join("");
}
function haxeLanguageServer_extensions_FsPathExtensions_urlEncode2(s) {
	return new EReg("[!'()*]","g").map(encodeURIComponent(s),function(re) {
		return "%" + StringTools.hex(re.matched(0).charCodeAt(0));
	});
}
function haxeLanguageServer_extensions_FunctionFormattingConfigExtensions_shouldPrintReturn(config,signature) {
	if(config.useArrowSyntax == true) {
		return false;
	}
	let returnStyle = config.returnTypeHint;
	if(returnStyle != "always") {
		if(returnStyle == "non-void") {
			return haxeLanguageServer_protocol_DotPath_getDotPath(signature.ret) != "StdTypes.Void";
		} else {
			return false;
		}
	} else {
		return true;
	}
}
class haxeLanguageServer_extensions_PositionStatics {
	static Min(pos1,pos2) {
		if(haxeLanguageServer_extensions_PositionExtensions_isBefore(pos1,pos2)) {
			return pos1;
		} else {
			return pos2;
		}
	}
	static Max(pos1,pos2) {
		if(haxeLanguageServer_extensions_PositionExtensions_isAfter(pos1,pos2)) {
			return pos1;
		} else {
			return pos2;
		}
	}
}
haxeLanguageServer_extensions_PositionStatics.__name__ = "haxeLanguageServer.extensions.PositionStatics";
function haxeLanguageServer_extensions_PositionExtensions_isBefore(pos,other) {
	if(pos.line < other.line) {
		return true;
	}
	if(other.line < pos.line) {
		return false;
	}
	return pos.character < other.character;
}
function haxeLanguageServer_extensions_PositionExtensions_isBeforeOrEqual(pos,other) {
	if(pos.line < other.line) {
		return true;
	}
	if(other.line < pos.line) {
		return false;
	}
	return pos.character <= other.character;
}
function haxeLanguageServer_extensions_PositionExtensions_isAfter(pos,other) {
	return !haxeLanguageServer_extensions_PositionExtensions_isBeforeOrEqual(pos,other);
}
function haxeLanguageServer_extensions_PositionExtensions_isEqual(pos,other) {
	if(pos.line == other.line) {
		return pos.character == other.character;
	} else {
		return false;
	}
}
function haxeLanguageServer_extensions_RangeExtensions_isEmpty(range) {
	return haxeLanguageServer_extensions_PositionExtensions_isEqual(range.end,range.start);
}
function haxeLanguageServer_extensions_RangeExtensions_containsPos(range,pos) {
	if(haxeLanguageServer_extensions_PositionExtensions_isBefore(pos,range.start)) {
		return false;
	}
	if(haxeLanguageServer_extensions_PositionExtensions_isBefore(range.end,pos)) {
		return false;
	}
	return true;
}
function haxeLanguageServer_extensions_RangeExtensions_intersection(range,other) {
	let start = haxeLanguageServer_extensions_PositionStatics.Max(other.start,range.start);
	let end = haxeLanguageServer_extensions_PositionStatics.Min(other.end,range.end);
	if(haxeLanguageServer_extensions_PositionExtensions_isAfter(start,end)) {
		return null;
	}
	return { start : start, end : end};
}
function haxeLanguageServer_extensions_RangeExtensions_union(range,other) {
	if(haxeLanguageServer_extensions_RangeExtensions_containsPos(range,other.start) && haxeLanguageServer_extensions_RangeExtensions_containsPos(range,other.end)) {
		return range;
	} else if(haxeLanguageServer_extensions_RangeExtensions_containsPos(other,range.start) && haxeLanguageServer_extensions_RangeExtensions_containsPos(other,range.end)) {
		return other;
	}
	return { start : haxeLanguageServer_extensions_PositionStatics.Min(other.start,range.start), end : haxeLanguageServer_extensions_PositionStatics.Max(other.end,range.end)};
}
function haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject) {
	return function(error) {
		let reject1 = reject;
		let data = null;
		let this1 = { code : -32603, message : error};
		if(data != null) {
			this1.data = data;
		}
		reject1(this1);
	};
}
function haxeLanguageServer_extensions_ResponseErrorExtensions_invalidXml(reject,data) {
	let data1 = null;
	let this1 = { code : -32603, message : "Invalid xml data: " + data};
	if(data1 != null) {
		this1.data = data1;
	}
	reject(this1);
}
function haxeLanguageServer_extensions_ResponseErrorExtensions_noTokens(reject) {
	let data = null;
	let this1 = { code : -32603, message : "Unable to build token tree"};
	if(data != null) {
		this1.data = data;
	}
	reject(this1);
}
function haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri) {
	let data = null;
	let this1 = { code : -32603, message : "Unable to find document for URI " + (uri == null ? "null" : uri) + ", or feature is not supported for this file type / scheme"};
	if(data != null) {
		this1.data = data;
	}
	reject(this1);
}
function haxeLanguageServer_extensions_StringExtensions_untilLastDot(s) {
	let dotIndex = s.lastIndexOf(".");
	if(dotIndex == -1) {
		return s;
	}
	return s.substring(0,dotIndex);
}
function haxeLanguageServer_extensions_StringExtensions_untilFirstDot(s) {
	let dotIndex = s.indexOf(".");
	if(dotIndex == -1) {
		return s;
	}
	return s.substring(0,dotIndex);
}
function haxeLanguageServer_extensions_StringExtensions_capitalize(s) {
	return s.charAt(0).toUpperCase() + HxOverrides.substr(s,1,null);
}
class haxeLanguageServer_features_CompletionFeature {
	constructor(context) {
		this.haxe = new haxeLanguageServer_features_haxe_completion_CompletionFeature(context);
		this.hxml = new haxeLanguageServer_features_hxml_CompletionFeature(context);
		context.languageServerProtocol.onRequest("textDocument/completion",$bind(this,this.onCompletion));
		context.languageServerProtocol.onRequest("completionItem/resolve",$bind(this,this.onCompletionResolve));
	}
	onCompletion(params,token,resolve,reject) {
		let uri = params.textDocument.uri;
		if(haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			this.haxe.onCompletion(params,token,resolve,reject);
		} else if(haxeLanguageServer_extensions_DocumentUriExtensions_isHxmlFile(uri)) {
			this.hxml.onCompletion(params,token,resolve,reject);
		} else {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
		}
	}
	onCompletionResolve(item,token,resolve,reject) {
		if(item.data != null) {
			this.haxe.onCompletionResolve(item,token,resolve,reject);
		} else {
			resolve(item);
		}
	}
}
haxeLanguageServer_features_CompletionFeature.__name__ = "haxeLanguageServer.features.CompletionFeature";
Object.assign(haxeLanguageServer_features_CompletionFeature.prototype, {
	__class__: haxeLanguageServer_features_CompletionFeature
});
class haxeLanguageServer_features_HoverFeature {
	constructor(context) {
		this.haxe = new haxeLanguageServer_features_haxe_HoverFeature(context);
		this.hxml = new haxeLanguageServer_features_hxml_HoverFeature(context);
		context.languageServerProtocol.onRequest("textDocument/hover",$bind(this,this.onHover));
	}
	onHover(params,token,resolve,reject) {
		let uri = params.textDocument.uri;
		if(haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			this.haxe.onHover(params,token,resolve,reject);
		} else if(haxeLanguageServer_extensions_DocumentUriExtensions_isHxmlFile(uri)) {
			this.hxml.onHover(params,token,resolve,reject);
		} else {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
		}
	}
}
haxeLanguageServer_features_HoverFeature.__name__ = "haxeLanguageServer.features.HoverFeature";
Object.assign(haxeLanguageServer_features_HoverFeature.prototype, {
	__class__: haxeLanguageServer_features_HoverFeature
});
class haxeLanguageServer_features_haxe_CodeLensFeature {
	constructor(context) {
		this.cache = new haxe_ds_StringMap();
		this.context = context;
		context.registerCapability("textDocument/codeLens",null,{ documentSelector : haxeLanguageServer_Context.haxeSelector});
		context.languageServerProtocol.onRequest("textDocument/codeLens",$bind(this,this.onCodeLens));
	}
	getCodeLensFromStatistics(uri,statistics) {
		let actions = [];
		let addRelation = function(kind,plural,range,relations) {
			if(relations == null) {
				relations = [];
			}
			let title = relations.length + " " + kind + (relations.length == 1 ? "" : plural);
			let action;
			if(relations.length == 0) {
				action = { command : { title : title, command : "", 'arguments' : []}, range : range};
			} else {
				let uri1 = uri;
				let range1 = range.start;
				let _g = [];
				let _g1 = 0;
				let _g2 = relations;
				while(_g1 < _g2.length) {
					let v = _g2[_g1];
					++_g1;
					if(v.range != null) {
						_g.push(v);
					}
				}
				let result = new Array(_g.length);
				let _g3 = 0;
				let _g4 = _g.length;
				while(_g3 < _g4) {
					let i = _g3++;
					let c = _g[i];
					let cRange = c.range;
					if(c.range.start.line != c.range.end.line) {
						cRange = { start : c.range.start, end : { character : 0, line : c.range.start.line + 1}};
					}
					result[i] = { range : cRange, uri : haxeLanguageServer_extensions_FsPathExtensions_toUri(c.file)};
				}
				action = { command : { title : title, command : "haxe.showReferences", 'arguments' : [uri1,range1,result]}, range : range};
			}
			actions.push(action);
		};
		let _g = 0;
		while(_g < statistics.length) {
			let statistic = statistics[_g];
			++_g;
			if(statistic.kind == null) {
				continue;
			}
			let range = statistic.range;
			switch(statistic.kind) {
			case "class field":
				if(statistic.overrides != null) {
					addRelation("override","s",range,statistic.overrides);
				}
				addRelation("reference","s",range,statistic.references);
				if(statistic.implementers != null) {
					addRelation("implementation","s",range,statistic.implementers);
				}
				break;
			case "class type":
				if(statistic.subclasses != null) {
					addRelation("subclass","es",range,statistic.subclasses);
				}
				break;
			case "enum field":
				addRelation("reference","s",range,statistic.references);
				break;
			case "enum type":
				addRelation("reference","s",range,statistic.references);
				break;
			case "interface type":
				addRelation("implementation","s",range,statistic.implementers);
				if(statistic.subclasses != null) {
					addRelation("subinterface","s",range,statistic.subclasses);
				}
				break;
			}
		}
		return actions;
	}
	onCodeLens(params,token,resolve,reject) {
		if(this.context.config.user.enableCodeLens == false) {
			resolve([]);
			return;
		}
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null || !haxeLanguageServer_extensions_DocumentUriExtensions_isFile(uri)) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		let onResolve = this.context.startTimer("@statistics");
		let _gthis = this;
		let tmp = this.context;
		let tmp1 = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc1.uri);
		tmp.callDisplay("@statistics",[(tmp1 == null ? "null" : tmp1) + "@0@statistics"],doc1.content,token,function(r) {
			switch(r._hx_index) {
			case 0:
				resolve([]);
				break;
			case 1:
				let _gmsg = r.msg;
				let data;
				try {
					data = JSON.parse(_gmsg);
				} catch( _g ) {
					let reject1 = reject;
					let data = null;
					let this1 = { code : -32603, message : "Error parsing stats response"};
					if(data != null) {
						this1.data = data;
					}
					reject1(this1);
					return;
				}
				onResolve(data);
				let _g = 0;
				while(_g < data.length) {
					let statistics = data[_g];
					++_g;
					if(haxeLanguageServer_extensions_FsPathExtensions_toUri(statistics.file) == uri) {
						let codeLens = _gthis.getCodeLensFromStatistics(uri,statistics.statistics);
						_gthis.cache.h[uri] = codeLens;
						resolve(codeLens);
					}
				}
				break;
			}
		},function(error) {
			let lens = _gthis.cache.h[uri];
			if(lens != null) {
				resolve(lens);
				haxe_Log.trace("Reusing cached code lens - failed with:\n\t" + error,{ fileName : "src/haxeLanguageServer/features/haxe/CodeLensFeature.hx", lineNumber : 130, className : "haxeLanguageServer.features.haxe.CodeLensFeature", methodName : "onCodeLens"});
			} else {
				let reject1 = reject;
				let data = null;
				let this1 = { code : -32603, message : error};
				if(data != null) {
					this1.data = data;
				}
				reject1(this1);
			}
		});
	}
}
haxeLanguageServer_features_haxe_CodeLensFeature.__name__ = "haxeLanguageServer.features.haxe.CodeLensFeature";
Object.assign(haxeLanguageServer_features_haxe_CodeLensFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_CodeLensFeature
});
class haxeLanguageServer_features_haxe_ColorProviderFeature {
	constructor(context) {
		this.upperCaseHexRegex = new EReg("0x([A-F0-9]{6})","g");
		this.context = context;
		this.computer = new haxeLanguageServer_features_haxe__$ColorProviderFeature_ColorComputer();
		context.languageServerProtocol.onRequest("textDocument/documentColor",$bind(this,this.onDocumentColor));
		context.languageServerProtocol.onRequest("textDocument/colorPresentation",$bind(this,this.onColorPresentation));
	}
	onDocumentColor(params,token,resolve,reject) {
		let onResolve = this.context.startTimer("textDocument/documentColor");
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		let colors = this.computer.compute(doc1);
		resolve(colors);
		onResolve(null,colors.length + " colors");
	}
	onColorPresentation(params,token,resolve,reject) {
		let onResolve = this.context.startTimer("textDocument/colorPresentation");
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		let hex = this.toHexColor(Math.round(params.color.alpha * 255),Math.round(params.color.red * 255),Math.round(params.color.green * 255),Math.round(params.color.blue * 255));
		if(params.range.end.character - params.range.start.character == 8 && params.color.alpha == 1) {
			hex = HxOverrides.substr(hex,2,null);
		}
		let originalText = doc1.getText(params.range);
		if(!this.upperCaseHexRegex.match(originalText)) {
			hex = hex.toLowerCase();
		}
		let colors = [{ label : "0x" + hex, textEdit : { range : params.range, newText : "0x" + hex}}];
		resolve(colors);
		onResolve(null,colors.length + " color presentations");
	}
	toHexColor(a,r,g,b) {
		a = this.clamp(a,0,255);
		r = this.clamp(r,0,255);
		g = this.clamp(g,0,255);
		b = this.clamp(b,0,255);
		return "" + this.asHex(a) + this.asHex(r) + this.asHex(g) + this.asHex(b);
	}
	asHex(v) {
		return StringTools.hex(Math.round(v),2);
	}
	clamp(v,min,max) {
		return Math.min(Math.max(min,v),max);
	}
}
haxeLanguageServer_features_haxe_ColorProviderFeature.__name__ = "haxeLanguageServer.features.haxe.ColorProviderFeature";
Object.assign(haxeLanguageServer_features_haxe_ColorProviderFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_ColorProviderFeature
});
class haxeLanguageServer_features_haxe__$ColorProviderFeature_ColorComputer {
	constructor() {
		this.rgbHexRegex = new EReg("0x([A-Fa-f0-9]{6})(\\W|$)","g");
		this.argbHexRegex = new EReg("0x([A-Fa-f0-9]{8})(\\W|$)","g");
	}
	compute(document) {
		let text = document.getText();
		let colors = [];
		let _gthis = this;
		text = this.argbHexRegex.map(text,function(r) {
			let color = _gthis.fromArgb(r.matched(1));
			let p = r.matchedPos();
			colors.push({ range : _gthis.toRange(document,p.pos,p.len - 1), color : color});
			return "0xAARRGGBB" + r.matched(2);
		});
		this.rgbHexRegex.map(text,function(r) {
			let color = _gthis.fromRgb(r.matched(1));
			let p = r.matchedPos();
			colors.push({ range : _gthis.toRange(document,p.pos,p.len - 1), color : color});
			return "0xRRGGBB" + r.matched(2);
		});
		return colors;
	}
	toRange(document,offset,length) {
		return { start : document.positionAt(offset), end : document.positionAt(offset + length)};
	}
	fromArgb(input) {
		let tmp = Std.parseInt("0x" + HxOverrides.substr(input,0,2));
		let tmp1 = Std.parseInt("0x" + HxOverrides.substr(input,2,2));
		let tmp2 = Std.parseInt("0x" + HxOverrides.substr(input,4,2));
		let tmp3 = Std.parseInt("0x" + HxOverrides.substr(input,6,2));
		return { red : (tmp1 != null ? tmp1 : 255) / 255, green : (tmp2 != null ? tmp2 : 255) / 255, blue : (tmp3 != null ? tmp3 : 255) / 255, alpha : (tmp != null ? tmp : 255) / 255};
	}
	fromRgb(input) {
		let tmp = Std.parseInt("0x" + HxOverrides.substr(input,0,2));
		let tmp1 = Std.parseInt("0x" + HxOverrides.substr(input,2,2));
		let tmp2 = Std.parseInt("0x" + HxOverrides.substr(input,4,2));
		return { red : (tmp != null ? tmp : 255) / 255, green : (tmp1 != null ? tmp1 : 255) / 255, blue : (tmp2 != null ? tmp2 : 255) / 255, alpha : 1};
	}
}
haxeLanguageServer_features_haxe__$ColorProviderFeature_ColorComputer.__name__ = "haxeLanguageServer.features.haxe._ColorProviderFeature.ColorComputer";
Object.assign(haxeLanguageServer_features_haxe__$ColorProviderFeature_ColorComputer.prototype, {
	__class__: haxeLanguageServer_features_haxe__$ColorProviderFeature_ColorComputer
});
class haxeLanguageServer_features_haxe_DeterminePackageFeature {
	constructor(context) {
		this.context = context;
		context.languageServerProtocol.onRequest("haxe/determinePackage",$bind(this,this.onDeterminePackage));
	}
	onDeterminePackage(params,token,resolve,reject) {
		(this.context.haxeServer.supports("display/package") ? $bind(this,this.handleJsonRpc) : $bind(this,this.handleLegacy))(params.fsPath,token,resolve,reject);
	}
	handleJsonRpc(path,token,resolve,reject) {
		let tmp = this.context;
		let tmp1 = haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject);
		tmp.callHaxeMethod("display/package",{ file : path},token,function(result) {
			resolve({ pack : result.join(".")});
			return null;
		},tmp1);
	}
	handleLegacy(path,token,resolve,reject) {
		this.context.callDisplay("@package",["" + (path == null ? "null" : path) + "@0@package"],null,token,function(r) {
			switch(r._hx_index) {
			case 0:
				resolve({ pack : ""});
				break;
			case 1:
				resolve({ pack : r.msg});
				break;
			}
		},haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject));
	}
}
haxeLanguageServer_features_haxe_DeterminePackageFeature.__name__ = "haxeLanguageServer.features.haxe.DeterminePackageFeature";
Object.assign(haxeLanguageServer_features_haxe_DeterminePackageFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_DeterminePackageFeature
});
class haxeLanguageServer_features_haxe_DiagnosticsFeature {
	constructor(context) {
		this.context = context;
		this.diagnosticsArguments = new haxe_ds_StringMap();
		this.pendingRequests = new haxe_ds_StringMap();
		this.errorUri = haxeLanguageServer_extensions_FsPathExtensions_toUri(haxe_io_Path.join([context.workspacePath,"Error"]));
		let _gthis = this;
		js_node_ChildProcess.exec(context.config.haxelib.executable + " config",function(error,stdout,stderr) {
			_gthis.haxelibPath = StringTools.trim(stdout);
		});
		context.languageServerProtocol.onNotification("haxe/runGlobalDiagnostics",$bind(this,this.onRunGlobalDiagnostics));
	}
	onRunGlobalDiagnostics(_) {
		let stopProgress = this.context.startProgress("Collecting Diagnostics");
		let onResolve = this.context.startTimer("@diagnostics");
		let _gthis = this;
		this.context.callDisplay("global diagnostics",["diagnostics"],null,null,function(result) {
			_gthis.processDiagnosticsReply(null,onResolve,result);
			let _this = _gthis.context.languageServerProtocol;
			let message = { jsonrpc : "2.0", method : "haxe/didRunGlobalDiagnostics"};
			_this.writeMessage(message,null);
			if(_this.didSendNotification != null) {
				_this.didSendNotification(message);
			}
			stopProgress();
		},function(error) {
			_gthis.processErrorReply(null,error);
			stopProgress();
		});
	}
	processErrorReply(uri,error) {
		if(!this.extractDiagnosticsFromHaxeError(uri,error) && !this.extractDiagnosticsFromHaxeError2(error)) {
			if(uri != null) {
				this.clearDiagnosticsOnClient(uri);
			}
			this.clearDiagnosticsOnClient(this.errorUri);
		}
		haxe_Log.trace(error,{ fileName : "src/haxeLanguageServer/features/haxe/DiagnosticsFeature.hx", lineNumber : 67, className : "haxeLanguageServer.features.haxe.DiagnosticsFeature", methodName : "processErrorReply"});
	}
	extractDiagnosticsFromHaxeError(uri,error) {
		let problemMatcher = new EReg("(.+):(\\d+): (?:lines \\d+-(\\d+)|character(?:s (\\d+)-| )(\\d+)) : (?:(Warning) : )?(.*)","");
		if(!problemMatcher.match(error)) {
			return false;
		}
		let file = problemMatcher.matched(1);
		if(!haxe_io_Path.isAbsolute(file)) {
			file = haxe_io_Path.join([process.cwd(),file]);
		}
		let targetUri = haxeLanguageServer_extensions_FsPathExtensions_toUri(file);
		if(targetUri != uri) {
			return false;
		}
		if(this.isPathFiltered(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(targetUri))) {
			return false;
		}
		let line = Std.parseInt(problemMatcher.matched(2));
		let endLine = Std.parseInt(problemMatcher.matched(3));
		let column = Std.parseInt(problemMatcher.matched(4));
		let endColumn = Std.parseInt(problemMatcher.matched(5));
		if(line == null) {
			return false;
		}
		let _gthis = this;
		let makePosition = function(line,character) {
			return { line : line - 1, character : character == null ? 0 : _gthis.context.displayOffsetConverter.positionCharToZeroBasedColumn(character)};
		};
		if(endLine == null) {
			endLine = line;
		}
		let position = makePosition(line,column);
		let endPosition = makePosition(endLine,endColumn);
		let diag = problemMatcher.matched(7);
		this.publishDiagnostic(targetUri,{ range : { start : position, end : endPosition}, severity : 1, message : diag},error);
		return true;
	}
	extractDiagnosticsFromHaxeError2(error) {
		let problemMatcher = new EReg("^(Error): (.*)$","");
		if(!problemMatcher.match(error)) {
			return false;
		}
		let diag = problemMatcher.matched(2);
		this.publishDiagnostic(this.errorUri,{ range : { start : { line : 0, character : 0}, end : { line : 0, character : 0}}, severity : 1, message : diag},error);
		return true;
	}
	publishDiagnostic(uri,diag,error) {
		let _this = this.context.languageServerProtocol;
		let params = { uri : uri, diagnostics : [diag]};
		let message = { jsonrpc : "2.0", method : "textDocument/publishDiagnostics"};
		if(params != null) {
			message.params = params;
		}
		_this.writeMessage(message,null);
		if(_this.didSendNotification != null) {
			_this.didSendNotification(message);
		}
		let v = new haxeLanguageServer_features_haxe__$DiagnosticsFeature_DiagnosticsMap();
		this.diagnosticsArguments.h[uri] = v;
		v.set({ code : 2, range : diag.range},error);
	}
	processDiagnosticsReply(uri,onResolve,result) {
		this.clearDiagnosticsOnClient(this.errorUri);
		let data;
		switch(result._hx_index) {
		case 0:
			return;
		case 1:
			let _gmsg = result.msg;
			try {
				data = JSON.parse(_gmsg);
			} catch( _g ) {
				haxe_Log.trace("Error parsing diagnostics response: " + Std.string(haxe_Exception.caught(_g)),{ fileName : "src/haxeLanguageServer/features/haxe/DiagnosticsFeature.hx", lineNumber : 145, className : "haxeLanguageServer.features.haxe.DiagnosticsFeature", methodName : "processDiagnosticsReply"});
				return;
			}
			break;
		}
		let count = 0;
		let sent_h = Object.create(null);
		let _g = 0;
		while(_g < data.length) {
			let data1 = data[_g];
			++_g;
			count += data1.diagnostics.length;
			let file = data1.file;
			if(file == null) {
				file = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(this.errorUri);
			}
			if(this.isPathFiltered(file)) {
				continue;
			}
			let uri = haxeLanguageServer_extensions_FsPathExtensions_toUri(file);
			let v = new haxeLanguageServer_features_haxe__$DiagnosticsFeature_DiagnosticsMap();
			this.diagnosticsArguments.h[uri] = v;
			let value = this.context.documents.documents.h[uri];
			let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let doc1 = doc;
			let newDiagnostics = this.filterRelevantDiagnostics(data1.diagnostics);
			let diagnostics = [];
			let _g1 = 0;
			while(_g1 < newDiagnostics.length) {
				let hxDiag = newDiagnostics[_g1];
				++_g1;
				let kind = hxDiag.kind;
				let range = hxDiag.range == null ? { start : { line : 0, character : 0}, end : { line : 0, character : 0}} : this.context.displayOffsetConverter.byteRangeToCharacterRange(hxDiag.range,doc1);
				let hxDiag1 = hxDiag.code;
				let hxDiag2 = hxDiag.severity;
				let diag = haxeLanguageServer_features_haxe_DiagnosticKind.getMessage(hxDiag.kind,doc1,hxDiag.args,range);
				let diag1 = { kind : hxDiag.kind};
				let tmp = hxDiag.relatedInformation;
				let diag2;
				if(tmp != null) {
					let result = new Array(tmp.length);
					let _g = 0;
					let _g1 = tmp.length;
					while(_g < _g1) {
						let i = _g++;
						let rel = tmp[i];
						result[i] = { location : { uri : haxeLanguageServer_extensions_FsPathExtensions_toUri(rel.location.file), range : rel.location.range}, message : this.convertIndentation(rel.message,rel.depth)};
					}
					diag2 = result;
				} else {
					diag2 = null;
				}
				let diag3 = { range : range, code : hxDiag1, severity : hxDiag2, message : diag, data : diag1, relatedInformation : diag2};
				if(kind == 3 || kind == 0 || diag3.message.includes("has no effect") || kind == 6) {
					diag3.severity = 4;
					diag3.tags = [1];
				}
				if(diag3.message == "This case is unused") {
					diag3.tags = [1];
				}
				if(kind == 5) {
					diag3.tags = [2];
				}
				v.set({ code : kind, range : diag3.range},hxDiag.args);
				diagnostics.push(diag3);
			}
			let _this = this.context.languageServerProtocol;
			let params = { uri : uri, diagnostics : diagnostics};
			let message = { jsonrpc : "2.0", method : "textDocument/publishDiagnostics"};
			if(params != null) {
				message.params = params;
			}
			_this.writeMessage(message,null);
			if(_this.didSendNotification != null) {
				_this.didSendNotification(message);
			}
			sent_h[uri] = true;
		}
		if(uri == null) {
			let uri = new haxe_ds__$StringMap_StringMapKeyIterator(this.diagnosticsArguments.h);
			while(uri.hasNext()) {
				let uri1 = uri.next();
				if(!Object.prototype.hasOwnProperty.call(sent_h,uri1)) {
					this.clearDiagnosticsOnClient(uri1);
				}
			}
		} else if(!Object.prototype.hasOwnProperty.call(sent_h,uri)) {
			this.clearDiagnosticsOnClient(uri);
		}
		onResolve(data,count + " diagnostics");
	}
	isPathFiltered(path) {
		return !haxeLanguageServer_helper_PathHelper.matches(path,haxeLanguageServer_helper_PathHelper.preparePathFilter(this.context.config.user.diagnosticsPathFilter,this.haxelibPath,this.context.workspacePath));
	}
	filterRelevantDiagnostics(diagnostics) {
		if(Lambda.find(diagnostics,function(d) {
			if(d.kind == 4) {
				return d.args != "Missing ;";
			} else {
				return false;
			}
		}) != null) {
			let _g = [];
			let _g1 = 0;
			let _g2 = diagnostics;
			while(_g1 < _g2.length) {
				let v = _g2[_g1];
				++_g1;
				let diagnostics;
				switch(v.kind) {
				case 1:case 2:
					diagnostics = false;
					break;
				default:
					diagnostics = true;
				}
				if(diagnostics) {
					_g.push(v);
				}
			}
			diagnostics = _g;
		}
		if(Lambda.find(diagnostics,function(d) {
			return d.kind == 2;
		}) != null) {
			let _g = [];
			let _g1 = 0;
			let _g2 = diagnostics;
			while(_g1 < _g2.length) {
				let v = _g2[_g1];
				++_g1;
				if(v.kind != 0) {
					_g.push(v);
				}
			}
			diagnostics = _g;
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = diagnostics;
		while(_g1 < _g2.length) {
			let v = _g2[_g1];
			++_g1;
			let a = v;
			if(a.kind != 6 || !Lambda.exists(diagnostics,function(b) {
				if(a != b && a.range != null && b.range != null) {
					let range = b.range;
					let other = a.range;
					if(haxeLanguageServer_extensions_RangeExtensions_containsPos(range,other.start)) {
						return haxeLanguageServer_extensions_RangeExtensions_containsPos(range,other.end);
					} else {
						return false;
					}
				} else {
					return false;
				}
			})) {
				_g.push(v);
			}
		}
		return _g;
	}
	convertIndentation(msg,depth) {
		if(msg.startsWith("... ")) {
			msg = HxOverrides.substr(msg,4,null);
			++depth;
		}
		if(depth < 2) {
			return msg;
		}
		let buf_b = "";
		let _g = 1;
		let _g1 = depth;
		while(_g < _g1) {
			++_g;
			buf_b += "";
		}
		buf_b += " ";
		buf_b += msg == null ? "null" : "" + msg;
		return buf_b;
	}
	clearDiagnostics(uri) {
		this.cancelPendingRequest(uri);
		this.clearDiagnosticsOnClient(uri);
	}
	clearDiagnosticsOnClient(uri) {
		let _this = this.diagnosticsArguments;
		let key = uri;
		let tmp;
		if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
			delete(_this.h[key]);
			tmp = true;
		} else {
			tmp = false;
		}
		if(tmp) {
			let _this = this.context.languageServerProtocol;
			let params = { uri : uri, diagnostics : []};
			let message = { jsonrpc : "2.0", method : "textDocument/publishDiagnostics"};
			if(params != null) {
				message.params = params;
			}
			_this.writeMessage(message,null);
			if(_this.didSendNotification != null) {
				_this.didSendNotification(message);
			}
		}
	}
	publishDiagnostics(uri) {
		if(!haxeLanguageServer_extensions_DocumentUriExtensions_isFile(uri) || this.isPathFiltered(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri))) {
			this.clearDiagnosticsOnClient(uri);
			return;
		}
		this.cancelPendingRequest(uri);
		let tokenSource = new jsonrpc__$CancellationToken_CancellationTokenImpl();
		let immediate = global.setImmediate($bind(this,this.invokePendingRequest),uri,tokenSource);
		let immediate1 = immediate;
		tokenSource.callback = function() {
			global.clearImmediate(immediate1);
		};
		this.pendingRequests.h[uri] = tokenSource;
	}
	invokePendingRequest(uri,token) {
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		let _gthis = this;
		if(doc1 != null) {
			let onResolve = this.context.startTimer("@diagnostics");
			let tmp = this.context;
			let tmp1 = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc1.uri);
			tmp.callDisplay("@diagnostics",[(tmp1 == null ? "null" : tmp1) + "@0@diagnostics"],null,token,function(result) {
				let _this = _gthis.pendingRequests;
				let key = uri;
				if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
					delete(_this.h[key]);
				}
				_gthis.processDiagnosticsReply(uri,onResolve,result);
			},function(error) {
				let _this = _gthis.pendingRequests;
				let key = uri;
				if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
					delete(_this.h[key]);
				}
				_gthis.processErrorReply(uri,error);
			});
		} else {
			let _this = this.pendingRequests;
			let key = uri;
			if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
				delete(_this.h[key]);
			}
		}
	}
	cancelPendingRequest(uri) {
		let tokenSource = this.pendingRequests.h[uri];
		if(tokenSource != null) {
			let _this = this.pendingRequests;
			let key = uri;
			if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
				delete(_this.h[key]);
			}
			if(!tokenSource.canceled) {
				tokenSource.canceled = true;
				if(tokenSource.callback != null) {
					tokenSource.callback();
				}
			}
		}
	}
	getArguments(uri,kind,range) {
		let map = this.diagnosticsArguments.h[uri];
		if(map == null) {
			return null;
		} else {
			return map.get({ code : kind, range : range});
		}
	}
	getArgumentsMap(uri) {
		return this.diagnosticsArguments.h[uri];
	}
}
haxeLanguageServer_features_haxe_DiagnosticsFeature.__name__ = "haxeLanguageServer.features.haxe.DiagnosticsFeature";
Object.assign(haxeLanguageServer_features_haxe_DiagnosticsFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_DiagnosticsFeature
});
class haxeLanguageServer_features_haxe_DiagnosticKind {
	static getMessage(this1,doc,args,range) {
		switch(this1) {
		case 0:
			return "Unused import/using";
		case 1:
			let message = "Unknown identifier";
			if(doc != null) {
				message = "Unknown identifier" + (" : " + doc.getText(range));
			}
			return message;
		case 2:
			return StringTools.trim(args);
		case 3:
			return args.description;
		case 4:
			return args;
		case 5:
			return args;
		case 6:
			return "Inactive conditional compilation block";
		case 7:
			let printer = new haxeLanguageServer_protocol_DisplayPrinter(null,haxeLanguageServer_protocol_PathPrinting.Never);
			let _this = args.entries;
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				let diag = _this[i];
				let cause;
				switch(diag.cause.kind) {
				case "AbstractParent":
					cause = printer.printPathWithParams(diag.cause.args.parent);
					break;
				case "FieldAccess":
					cause = "this";
					break;
				case "FinalFields":
					cause = "this";
					break;
				case "ImplementedInterface":
					cause = printer.printPathWithParams(diag.cause.args.parent);
					break;
				case "PropertyAccessor":
					cause = diag.cause.args.property.name;
					break;
				}
				result[i] = cause;
			}
			return "Missing fields for " + result.join(", ");
		}
	}
}
class haxeLanguageServer_features_haxe__$DiagnosticsFeature_DiagnosticsMap extends haxe_ds_BalancedTree {
	constructor() {
		super();
	}
	compare(k1,k2) {
		let start1 = k1.range.start;
		let start2 = k2.range.start;
		let end1 = k1.range.end;
		let end2 = k2.range.end;
		let i1 = k1.code;
		let i2 = k2.code;
		if(i1 < i2) {
			return -1;
		} else if(i1 > i2) {
			return 1;
		} else {
			let i1 = start1.line;
			let i2 = start2.line;
			if(i1 < i2) {
				return -1;
			} else if(i1 > i2) {
				return 1;
			} else {
				let i1 = start1.character;
				let i2 = start2.character;
				if(i1 < i2) {
					return -1;
				} else if(i1 > i2) {
					return 1;
				} else {
					let i1 = end1.line;
					let i2 = end2.line;
					if(i1 < i2) {
						return -1;
					} else if(i1 > i2) {
						return 1;
					} else {
						let i1 = end1.character;
						let i2 = end2.character;
						if(i1 < i2) {
							return -1;
						} else if(i1 > i2) {
							return 1;
						} else {
							return 0;
						}
					}
				}
			}
		}
	}
}
haxeLanguageServer_features_haxe__$DiagnosticsFeature_DiagnosticsMap.__name__ = "haxeLanguageServer.features.haxe._DiagnosticsFeature.DiagnosticsMap";
haxeLanguageServer_features_haxe__$DiagnosticsFeature_DiagnosticsMap.__super__ = haxe_ds_BalancedTree;
Object.assign(haxeLanguageServer_features_haxe__$DiagnosticsFeature_DiagnosticsMap.prototype, {
	__class__: haxeLanguageServer_features_haxe__$DiagnosticsFeature_DiagnosticsMap
});
class haxeLanguageServer_features_haxe_DocumentFormattingFeature {
	constructor(context) {
		this.context = context;
		context.languageServerProtocol.onRequest("textDocument/formatting",$bind(this,this.onDocumentFormatting));
		context.languageServerProtocol.onRequest("textDocument/rangeFormatting",$bind(this,this.onDocumentRangeFormatting));
	}
	onDocumentFormatting(params,token,resolve,reject) {
		this.format(params.textDocument.uri,null,resolve,reject);
	}
	onDocumentRangeFormatting(params,token,resolve,reject) {
		this.format(params.textDocument.uri,params.range,resolve,reject);
	}
	format(uri,range,resolve,reject) {
		let onResolve = this.context.startTimer("textDocument/formatting");
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		let tokens = doc1.get_tokens();
		if(tokens == null) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noTokens(reject);
			return;
		}
		let path;
		let origin;
		if(haxeLanguageServer_extensions_DocumentUriExtensions_isFile(doc1.uri)) {
			let this1 = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc1.uri);
			path = this1;
			origin = formatter_CodeOrigin.SourceFile(this1);
		} else {
			path = this.context.workspacePath;
			origin = formatter_CodeOrigin.Snippet;
		}
		let config = formatter_Formatter.loadConfig(path);
		let inputRange = null;
		if(range != null) {
			range.start.character = 0;
			let converter = new haxeLanguageServer_helper_Haxe3DisplayOffsetConverter();
			let convert = function(position) {
				return converter.characterOffsetToByteOffset(doc1.content,doc1.offsetAt(position));
			};
			inputRange = { startPos : convert(range.start), endPos : convert(range.end)};
		}
		let result = formatter_Formatter.format(formatter_FormatterInput.Tokens(tokens.list,tokens.tree,tokens.bytes,origin),config,null,null,inputRange);
		switch(result._hx_index) {
		case 0:
			let _gformattedCode = result.formattedCode;
			let range1;
			if(range == null) {
				let range = doc1.getLineOffsets().length - 1;
				let doc = doc1;
				let range2 = doc1.getLineOffsets().length - 1;
				range1 = { start : { line : 0, character : 0}, end : { line : range, character : doc.lineAt(range2).length}};
			} else {
				range1 = range;
			}
			let edits = doc1.getText(range1) != _gformattedCode ? [{ range : range1, newText : _gformattedCode}] : [];
			resolve(edits);
			onResolve(null,edits.length + " changes");
			break;
		case 1:
			let data = null;
			let this1 = { code : -32603, message : result.errorMessage};
			if(data != null) {
				this1.data = data;
			}
			reject(this1);
			break;
		case 2:
			let data1 = null;
			let this2 = { code : -32603, message : "Formatting is disabled for this file"};
			if(data1 != null) {
				this2.data = data1;
			}
			reject(this2);
			break;
		}
	}
}
haxeLanguageServer_features_haxe_DocumentFormattingFeature.__name__ = "haxeLanguageServer.features.haxe.DocumentFormattingFeature";
Object.assign(haxeLanguageServer_features_haxe_DocumentFormattingFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_DocumentFormattingFeature
});
class haxeLanguageServer_features_haxe_FindReferencesFeature {
	constructor(context) {
		this.context = context;
		context.languageServerProtocol.onRequest("textDocument/references",$bind(this,this.onFindReferences));
	}
	onFindReferences(params,token,resolve,reject) {
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null || !haxeLanguageServer_extensions_DocumentUriExtensions_isFile(uri)) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		(this.context.haxeServer.supports("display/references") ? $bind(this,this.handleJsonRpc) : $bind(this,this.handleLegacy))(params,token,resolve,reject,doc1,this.context.displayOffsetConverter.characterOffsetToByteOffset(doc1.content,doc1.offsetAt(params.position)));
	}
	handleJsonRpc(params,token,resolve,reject,doc,offset) {
		this.context.callHaxeMethod("display/references",{ file : haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc.uri), contents : doc.content, offset : offset, kind : "withBaseAndDescendants"},token,function(locations) {
			let resolve1 = resolve;
			let _g = [];
			let _g1 = 0;
			while(_g1 < locations.length) {
				let v = locations[_g1];
				++_g1;
				if(v != null) {
					_g.push(v);
				}
			}
			let result = new Array(_g.length);
			let _g2 = 0;
			let _g3 = _g.length;
			while(_g2 < _g3) {
				let i = _g2++;
				let location = _g[i];
				result[i] = { uri : haxeLanguageServer_extensions_FsPathExtensions_toUri(location.file), range : location.range};
			}
			resolve1(result);
			return null;
		},haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject));
	}
	handleLegacy(params,token,resolve,reject,doc,offset) {
		let tmp = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc.uri);
		let _gthis = this;
		this.context.callDisplay("@usage",["" + (tmp == null ? "null" : tmp) + "@" + offset + "@usage"],doc.content,token,function(r) {
			switch(r._hx_index) {
			case 0:
				resolve(null);
				break;
			case 1:
				let _gmsg = r.msg;
				let xml;
				try {
					xml = Xml.parse(_gmsg).firstElement();
				} catch( _g ) {
					haxe_NativeStackTrace.lastError = _g;
					xml = null;
				}
				if(xml == null) {
					haxeLanguageServer_extensions_ResponseErrorExtensions_invalidXml(reject,_gmsg);
					return;
				}
				let _g = [];
				let el = xml.elements();
				while(el.hasNext()) {
					let el1 = el.next();
					if(el1.nodeType != Xml.Document && el1.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (el1.nodeType == null ? "null" : XmlType.toString(el1.nodeType)));
					}
					let _this = el1.children[0];
					if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, unexpected " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
					}
					_g.push(_this.nodeValue);
				}
				if(_g.length == 0) {
					resolve([]);
					return;
				}
				let results = [];
				let haxePosCache = new haxe_ds_StringMap();
				let _g1 = 0;
				while(_g1 < _g.length) {
					let pos = _g[_g1];
					++_g1;
					let location = haxeLanguageServer_helper_HaxePosition.parse(pos,doc,haxePosCache,_gthis.context.displayOffsetConverter);
					if(location == null) {
						haxe_Log.trace("Got invalid position: " + pos,{ fileName : "src/haxeLanguageServer/features/haxe/FindReferencesFeature.hx", lineNumber : 69, className : "haxeLanguageServer.features.haxe.FindReferencesFeature", methodName : "handleLegacy"});
						continue;
					}
					results.push(location);
				}
				resolve(results);
				break;
			}
		},haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject));
	}
}
haxeLanguageServer_features_haxe_FindReferencesFeature.__name__ = "haxeLanguageServer.features.haxe.FindReferencesFeature";
Object.assign(haxeLanguageServer_features_haxe_FindReferencesFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_FindReferencesFeature
});
class haxeLanguageServer_features_haxe_GotoDefinitionFeature {
	constructor(context) {
		this.context = context;
		context.languageServerProtocol.onRequest("textDocument/definition",$bind(this,this.onGotoDefinition));
	}
	onGotoDefinition(params,token,resolve,reject) {
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null || !haxeLanguageServer_extensions_DocumentUriExtensions_isFile(uri)) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		(this.context.haxeServer.supports("display/definition") ? $bind(this,this.handleJsonRpc) : $bind(this,this.handleLegacy))(params,token,resolve,reject,doc1,this.context.displayOffsetConverter.characterOffsetToByteOffset(doc1.content,doc1.offsetAt(params.position)));
	}
	handleJsonRpc(params,token,resolve,reject,doc,offset) {
		let _gthis = this;
		this.context.callHaxeMethod("display/definition",{ file : haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc.uri), contents : doc.content, offset : offset},token,function(locations) {
			if(locations == null) {
				locations = [];
			}
			let resolve1 = resolve;
			let result = new Array(locations.length);
			let _g = 0;
			let _g1 = locations.length;
			while(_g < _g1) {
				let i = _g++;
				let location = locations[i];
				let document = _gthis.getHaxeDocument(haxeLanguageServer_extensions_FsPathExtensions_toUri(location.file));
				let tokens = document == null ? null : document.get_tokens();
				let previewDeclarationRange = location.range;
				if(document != null && tokens != null) {
					let _v_ = tokens;
					let _v_1 = _v_ == null ? null : _v_.getTokenAtOffset(document.offsetAt(location.range.start));
					let _v_2 = _v_1 == null ? null : _v_1.parent;
					let pos = _v_2 == null ? null : _v_2.getPos();
					if(pos != null) {
						let endOffset = pos.max;
						previewDeclarationRange = { start : document.positionAt(pos.min,1), end : document.positionAt(endOffset,1)};
					}
				}
				result[i] = { targetUri : haxeLanguageServer_extensions_FsPathExtensions_toUri(location.file), targetRange : previewDeclarationRange, targetSelectionRange : location.range};
			}
			resolve1(result);
			return null;
		},haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject));
	}
	getHaxeDocument(uri) {
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let document = doc;
		if(document == null) {
			let this1 = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri);
			if(!sys_FileSystem.exists(this1)) {
				return null;
			}
			let content = js_node_Fs.readFileSync(this1,{ encoding : "utf8"});
			document = new haxeLanguageServer_documents_HaxeDocument(uri,"haxe",0,content);
		}
		return document;
	}
	handleLegacy(params,token,resolve,reject,doc,offset) {
		let tmp = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc.uri);
		let _gthis = this;
		this.context.callDisplay("@position",["" + (tmp == null ? "null" : tmp) + "@" + offset + "@position"],doc.content,token,function(r) {
			switch(r._hx_index) {
			case 0:
				resolve([]);
				break;
			case 1:
				let _gmsg = r.msg;
				let xml;
				try {
					xml = Xml.parse(_gmsg).firstElement();
				} catch( _g ) {
					haxe_NativeStackTrace.lastError = _g;
					xml = null;
				}
				if(xml == null) {
					haxeLanguageServer_extensions_ResponseErrorExtensions_invalidXml(reject,_gmsg);
					return;
				}
				let _g = [];
				let el = xml.elements();
				while(el.hasNext()) {
					let el1 = el.next();
					if(el1.nodeType != Xml.Document && el1.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (el1.nodeType == null ? "null" : XmlType.toString(el1.nodeType)));
					}
					let _this = el1.children[0];
					if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, unexpected " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
					}
					_g.push(_this.nodeValue);
				}
				if(_g.length == 0) {
					resolve([]);
				}
				let results = [];
				let _g1 = 0;
				while(_g1 < _g.length) {
					let pos = _g[_g1];
					++_g1;
					let location = haxeLanguageServer_helper_HaxePosition.parse(pos,doc,null,_gthis.context.displayOffsetConverter);
					if(location == null) {
						haxe_Log.trace("Got invalid position: " + pos,{ fileName : "src/haxeLanguageServer/features/haxe/GotoDefinitionFeature.hx", lineNumber : 93, className : "haxeLanguageServer.features.haxe.GotoDefinitionFeature", methodName : "handleLegacy"});
						continue;
					}
					results.push({ targetUri : location.uri, targetRange : location.range, targetSelectionRange : location.range});
				}
				resolve(results);
				break;
			}
		},haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject));
	}
}
haxeLanguageServer_features_haxe_GotoDefinitionFeature.__name__ = "haxeLanguageServer.features.haxe.GotoDefinitionFeature";
Object.assign(haxeLanguageServer_features_haxe_GotoDefinitionFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_GotoDefinitionFeature
});
class haxeLanguageServer_features_haxe_GotoImplementationFeature {
	constructor(context) {
		this.context = context;
		context.languageServerProtocol.onRequest("textDocument/implementation",$bind(this,this.onGotoImplementation));
	}
	onGotoImplementation(params,token,resolve,reject) {
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null || !haxeLanguageServer_extensions_DocumentUriExtensions_isFile(uri)) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		this.handleJsonRpc(params,token,resolve,reject,doc1,this.context.displayOffsetConverter.characterOffsetToByteOffset(doc1.content,doc1.offsetAt(params.position)));
	}
	handleJsonRpc(params,token,resolve,reject,doc,offset) {
		this.context.callHaxeMethod("display/implementation",{ file : haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc.uri), contents : doc.content, offset : offset},token,function(locations) {
			let resolve1 = resolve;
			let result = new Array(locations.length);
			let _g = 0;
			let _g1 = locations.length;
			while(_g < _g1) {
				let i = _g++;
				let location = locations[i];
				result[i] = { uri : haxeLanguageServer_extensions_FsPathExtensions_toUri(location.file), range : location.range};
			}
			resolve1(result);
			return null;
		},haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject));
	}
}
haxeLanguageServer_features_haxe_GotoImplementationFeature.__name__ = "haxeLanguageServer.features.haxe.GotoImplementationFeature";
Object.assign(haxeLanguageServer_features_haxe_GotoImplementationFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_GotoImplementationFeature
});
class haxeLanguageServer_features_haxe_GotoTypeDefinitionFeature {
	constructor(context) {
		this.context = context;
		context.languageServerProtocol.onRequest("textDocument/typeDefinition",$bind(this,this.onGotoTypeDefinition));
	}
	onGotoTypeDefinition(params,token,resolve,reject) {
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null || !haxeLanguageServer_extensions_DocumentUriExtensions_isFile(uri)) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		let offset = this.context.displayOffsetConverter.characterOffsetToByteOffset(doc1.content,doc1.offsetAt(params.position));
		this.context.callHaxeMethod("display/typeDefinition",{ file : haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri), contents : doc1.content, offset : offset},token,function(locations) {
			let resolve1 = resolve;
			let result = new Array(locations.length);
			let _g = 0;
			let _g1 = locations.length;
			while(_g < _g1) {
				let i = _g++;
				let location = locations[i];
				result[i] = { uri : haxeLanguageServer_extensions_FsPathExtensions_toUri(location.file), range : location.range};
			}
			resolve1(result);
			return null;
		},haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject));
	}
}
haxeLanguageServer_features_haxe_GotoTypeDefinitionFeature.__name__ = "haxeLanguageServer.features.haxe.GotoTypeDefinitionFeature";
Object.assign(haxeLanguageServer_features_haxe_GotoTypeDefinitionFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_GotoTypeDefinitionFeature
});
class haxeLanguageServer_features_haxe_HoverFeature {
	constructor(context) {
		this.context = context;
	}
	onHover(params,token,resolve,reject) {
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null || !haxeLanguageServer_extensions_DocumentUriExtensions_isFile(uri)) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		(this.context.haxeServer.supports("display/hover") ? $bind(this,this.handleJsonRpc) : $bind(this,this.handleLegacy))(params,token,resolve,reject,doc1,this.context.displayOffsetConverter.characterOffsetToByteOffset(doc1.content,doc1.offsetAt(params.position)));
	}
	handleJsonRpc(params,token,resolve,reject,doc,offset) {
		let _gthis = this;
		this.context.callHaxeMethod("display/hover",{ file : haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc.uri), contents : doc.content, offset : offset},token,function(hover) {
			if(hover == null) {
				resolve(null);
			} else {
				let range = _gthis.context.displayOffsetConverter.byteRangeToCharacterRange(hover.range,doc);
				resolve(_gthis.createHover(_gthis.printContent(doc,hover),haxeLanguageServer_protocol_Extensions_getDocumentation(hover.item),range));
			}
			return null;
		},haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject));
	}
	printContent(doc,hover) {
		let printer = new haxeLanguageServer_protocol_DisplayPrinter(true,haxeLanguageServer_protocol_PathPrinting.Qualified,{ argumentTypeHints : true, returnTypeHint : "non-void", useArrowSyntax : false, placeOpenBraceOnNewLine : false, explicitPublic : true, explicitPrivate : true, explicitNull : true});
		let item = hover.item;
		let getType = function() {
			let value = hover.item.type;
			if(value == null) {
				throw new safety_NullPointerException("Null pointer in .sure() call");
			} else {
				return value;
			}
		};
		let printType = function() {
			return { definition : haxeLanguageServer_helper_DocHelper.printCodeBlock(printer.printType(getType()),"haxe.type")};
		};
		let result;
		switch(item.kind) {
		case "Define":
			let value = item.args.value;
			result = { definition : value == null ? "_not defined_" : haxeLanguageServer_helper_DocHelper.printCodeBlock("\"" + value + "\"","haxe")};
			break;
		case "ClassField":case "EnumAbstractField":
			result = { definition : haxeLanguageServer_helper_DocHelper.printCodeBlock(printer.printClassFieldDefinition(item.args,getType(),item.kind == "EnumAbstractField"),"haxe"), origin : printer.printClassFieldOrigin(item.args.origin,item.kind)};
			break;
		case "EnumField":
			let field = item.args.field;
			let concreteType = getType();
			result = { definition : haxeLanguageServer_helper_DocHelper.printCodeBlock(printer.printEnumField(field,concreteType,false,true),"haxe"), origin : printer.printEnumFieldOrigin(item.args.origin)};
			break;
		case "Literal":
			let value1 = item.args.name;
			if(value1 != doc.getText(hover.range) && haxeLanguageServer_protocol_DotPath_getDotPath(getType()) != "String") {
				return { definition : haxeLanguageServer_helper_DocHelper.printCodeBlock(value1,"haxe")};
			} else {
				result = printType();
			}
			break;
		case "Local":
			let languageId = item.args.origin == 1 ? "haxe.argument" : "haxe";
			result = { definition : haxeLanguageServer_helper_DocHelper.printCodeBlock(printer.printLocalDefinition(hover.item.args,getType()),languageId), origin : printer.printLocalOrigin(item.args.origin)};
			break;
		case "Metadata":
			result = { definition : haxeLanguageServer_helper_DocHelper.printCodeBlock(item.args.name,"haxe")};
			break;
		case "Type":
			result = { definition : haxeLanguageServer_helper_DocHelper.printCodeBlock(printer.printEmptyTypeDefinition(hover.item.args),"haxe")};
			break;
		default:
			result = printType();
		}
		let expected = hover.expected;
		if(expected != null && expected.name != null && expected.name.kind == 0) {
			let argument = expected.name.name;
			if(expected.type != null) {
				argument += ":" + new haxeLanguageServer_protocol_DisplayPrinter(null,haxeLanguageServer_protocol_PathPrinting.Never).printType(expected.type);
			}
			result.additionalSections = ["*for argument `" + argument + "`*"];
			if(expected.name.doc != null) {
				result.additionalSections.push(haxeLanguageServer_helper_DocHelper.markdownFormat(expected.name.doc));
			}
		}
		return result;
	}
	handleLegacy(params,token,resolve,reject,doc,offset) {
		let tmp = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc.uri);
		let _gthis = this;
		this.context.callDisplay("@type",["" + (tmp == null ? "null" : tmp) + "@" + offset + "@type"],doc.content,token,function(result) {
			switch(result._hx_index) {
			case 0:
				resolve(null);
				break;
			case 1:
				let _gmsg = result.msg;
				let xml;
				try {
					xml = Xml.parse(_gmsg).firstElement();
				} catch( _g ) {
					haxe_NativeStackTrace.lastError = _g;
					xml = null;
				}
				if(xml == null) {
					haxeLanguageServer_extensions_ResponseErrorExtensions_invalidXml(reject,_gmsg);
					return;
				}
				if(xml.nodeType != Xml.Document && xml.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
				}
				let _this = xml.children[0];
				if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
				}
				let s = StringTools.trim(_this.nodeValue);
				if(xml.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
				}
				if(xml.nodeName == "metadata") {
					if(s.length == 0) {
						let reject1 = reject;
						let data = null;
						let this1 = { code : 0, message : "No metadata information"};
						if(data != null) {
							this1.data = data;
						}
						reject1(this1);
						return;
					}
					resolve({ contents : s});
				} else {
					if(s.length == 0) {
						let reject1 = reject;
						let data = null;
						let this1 = { code : 0, message : "No type information"};
						if(data != null) {
							this1.data = data;
						}
						reject1(this1);
						return;
					}
					let type;
					let _g = haxeLanguageServer_helper_TypeHelper.parseDisplayType(s);
					switch(_g._hx_index) {
					case 0:
						let _gtype = _g.type;
						type = _gtype == null ? "unknown" : _gtype;
						break;
					case 1:
						type = haxeLanguageServer_helper_TypeHelper.printFunctionType(_g.args,_g.ret);
						break;
					}
					let documentation = xml.get("d");
					let pos = haxeLanguageServer_helper_HaxePosition.parse(xml.get("p"),doc,null,_gthis.context.displayOffsetConverter);
					let range = null;
					if(pos != null) {
						range = pos.range;
					}
					resolve(_gthis.createHover({ definition : haxeLanguageServer_helper_DocHelper.printCodeBlock(type,"haxe.type")},documentation,range));
				}
				break;
			}
		},haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject));
	}
	createHover(content,documentation,range) {
		if(documentation != null) {
			documentation = StringTools.trim(haxeLanguageServer_helper_DocHelper.markdownFormat(documentation));
			if(documentation != "") {
				documentation = "\n" + documentation;
			}
		}
		if(content.origin != null) {
			if(documentation == null) {
				documentation = "";
			}
			documentation = "*" + content.origin + "*\n" + documentation;
		}
		let sections = [content.definition];
		if(documentation != null && documentation != "") {
			sections.push(documentation);
		}
		if(content.additionalSections != null) {
			sections = sections.concat(content.additionalSections);
		}
		let hover = { contents : { kind : "markdown", value : sections.join("\n\n---\n")}};
		if(range != null) {
			hover.range = range;
		}
		return hover;
	}
}
haxeLanguageServer_features_haxe_HoverFeature.__name__ = "haxeLanguageServer.features.haxe.HoverFeature";
Object.assign(haxeLanguageServer_features_haxe_HoverFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_HoverFeature
});
class haxeLanguageServer_features_haxe_InlayHintFeature {
	constructor(context) {
		this.inlayHintsConditionls = false;
		this.inlayHintsFunctionReturnTypes = true;
		this.inlayHintsParameterTypes = false;
		this.inlayHintsParameterNames = true;
		this.inlayHintsVariableTypes = true;
		this.hoverRequests = [];
		this.context = context;
		this.cache = new haxe_ds_StringMap();
		this.converter = new haxeLanguageServer_helper_Haxe3DisplayOffsetConverter();
		this.printer = new haxeLanguageServer_protocol_DisplayPrinter(true,haxeLanguageServer_protocol_PathPrinting.Qualified,{ argumentTypeHints : true, returnTypeHint : "non-void", useArrowSyntax : false, placeOpenBraceOnNewLine : false, explicitPublic : true, explicitPrivate : true, explicitNull : true});
		context.languageServerProtocol.onRequest("textDocument/inlayHint",$bind(this,this.onInlayHint));
	}
	onInlayHint(params,token,resolve,reject) {
		let onResolve = this.context.startTimer("textDocument/inlayHint");
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		let this1 = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri);
		this.registerChangeHandler(doc1,this1);
		let startPos = doc1.offsetAt(params.range.start);
		let endPos = doc1.offsetAt(params.range.end);
		let _v_ = doc1 == null ? null : doc1.get_tokens();
		let root = _v_ == null ? null : _v_.tree;
		if(root == null) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		haxe_Log.trace("[inlayHints] requesting inlay hints for " + this1 + " lines " + params.range.start.line + "-" + params.range.end.line,{ fileName : "src/haxeLanguageServer/features/haxe/InlayHintFeature.hx", lineNumber : 66, className : "haxeLanguageServer.features.haxe.InlayHintFeature", methodName : "onInlayHint"});
		this.removeCancelledRequests();
		let tmp = this.context.config.user;
		let tmp1 = tmp != null ? tmp.inlayHints : null;
		let tmp2 = tmp1 != null ? tmp1.variableTypes : null;
		this.inlayHintsVariableTypes = tmp2 != null ? tmp2 : true;
		let tmp3 = this.context.config.user;
		let tmp4 = tmp3 != null ? tmp3.inlayHints : null;
		let tmp5 = tmp4 != null ? tmp4.parameterNames : null;
		this.inlayHintsParameterNames = tmp5 != null ? tmp5 : true;
		let tmp6 = this.context.config.user;
		let tmp7 = tmp6 != null ? tmp6.inlayHints : null;
		let tmp8 = tmp7 != null ? tmp7.parameterTypes : null;
		this.inlayHintsParameterTypes = tmp8 != null && tmp8;
		let tmp9 = this.context.config.user;
		let tmp10 = tmp9 != null ? tmp9.inlayHints : null;
		let tmp11 = tmp10 != null ? tmp10.functionReturnTypes : null;
		this.inlayHintsFunctionReturnTypes = tmp11 != null ? tmp11 : true;
		let tmp12 = this.context.config.user;
		let tmp13 = tmp12 != null ? tmp12.inlayHints : null;
		let tmp14 = tmp13 != null ? tmp13.conditionals : null;
		this.inlayHintsConditionls = tmp14 != null ? tmp14 : true;
		if(!this.inlayHintsVariableTypes && !this.inlayHintsParameterNames && !this.inlayHintsParameterTypes && !this.inlayHintsFunctionReturnTypes && !this.inlayHintsConditionls) {
			resolve([]);
			onResolve(null,"disabled");
			return;
		}
		let promises = [];
		if(this.inlayHintsVariableTypes) {
			promises = promises.concat(this.findAllVars(doc1,this1,root,startPos,endPos,token));
		}
		if(this.inlayHintsParameterNames || this.inlayHintsFunctionReturnTypes || this.inlayHintsParameterTypes) {
			promises = promises.concat(this.findAllPOpens(doc1,this1,root,startPos,endPos,token));
		}
		if(this.inlayHintsConditionls) {
			promises = promises.concat(this.findAllConditionals(doc1,this1,root,startPos,endPos,token));
		}
		if(promises.length <= 0) {
			resolve([]);
			onResolve(null,"0 hints");
			return;
		}
		Promise.all(promises).then(function(inlayHints) {
			let hints = [];
			let _g = 0;
			while(_g < inlayHints.length) {
				let hintList = inlayHints[_g];
				++_g;
				if(hintList == null) {
					continue;
				}
				hints = hints.concat(hintList);
			}
			resolve(hints);
			onResolve(null,hints.length + " hints");
		}).catch(function(_) {
			return Promise.resolve();
		});
	}
	findAllConditionals(doc,fileName,root,startPos,endPos,token) {
		let promises = [];
		let allConditionals = root.filterCallback(function(token,_) {
			if(startPos > token.pos.min) {
				return tokentree_FilterResult.GoDeeper;
			}
			if(endPos < token.pos.min) {
				return tokentree_FilterResult.GoDeeper;
			}
			let _g = token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "end") {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < allConditionals.length) {
			let c = allConditionals[_g];
			++_g;
			let parent = c.parent;
			while(parent != null) {
				let _g = parent.tok;
				if(_g._hx_index == 3) {
					if(_g.s == "if") {
						break;
					} else {
						parent = parent.parent;
					}
				} else {
					parent = parent.parent;
				}
			}
			if(parent == null) {
				continue;
			}
			let conditionToken = parent.getFirstChild();
			if(conditionToken == null) {
				continue;
			}
			let pos = conditionToken.getPos();
			let conditionStart = this.converter.byteOffsetToCharacterOffset(doc.content,pos.min);
			let conditionEnd = this.converter.byteOffsetToCharacterOffset(doc.content,pos.max);
			let text = " // " + doc.content.substring(conditionStart,conditionEnd);
			let insertPos = this.converter.byteOffsetToCharacterOffset(doc.content,c.pos.max);
			let indexOfText = doc.content.indexOf(text,insertPos);
			if(indexOfText - insertPos >= 0 && indexOfText - insertPos < 5) {
				continue;
			}
			let hint = { position : doc.positionAt(insertPos), label : text, kind : 1, textEdits : [{ range : { start : doc.positionAt(insertPos,1), end : doc.positionAt(insertPos,1)}, newText : text}], paddingRight : false, paddingLeft : true};
			if(hint == null) {
				continue;
			}
			promises.push(Promise.resolve([hint]));
		}
		return promises;
	}
	findAllVars(doc,fileName,root,startPos,endPos,token) {
		let promises = [];
		let allVars = root.filterCallback(function(token,_) {
			if(startPos > token.pos.min) {
				return tokentree_FilterResult.GoDeeper;
			}
			if(endPos < token.pos.min) {
				return tokentree_FilterResult.GoDeeper;
			}
			let _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 2:
					return tokentree_FilterResult.FoundGoDeeper;
				case 42:
					if(!token.hasChildren()) {
						return tokentree_FilterResult.SkipSubtree;
					}
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _gthis = this;
		let _g = 0;
		while(_g < allVars.length) {
			let nameToken = allVars[_g++].getFirstChild();
			if(nameToken == null) {
				continue;
			}
			if(nameToken.tok._hx_index == 22) {
				nameToken = nameToken.getFirstChild();
			}
			if(nameToken == null) {
				continue;
			}
			if(tokentree_TokenTreeAccessHelper.firstOf(nameToken,tokentree_TokenTreeDef.DblDot) != null) {
				continue;
			}
			let insertPos = nameToken.pos.max;
			let childs = nameToken.children;
			if(childs != null) {
				let _g = 0;
				_hx_loop2: while(_g < childs.length) {
					let child = childs[_g];
					++_g;
					switch(child.tok._hx_index) {
					case 20:
						insertPos = child.getPos().max;
						break;
					case 23:
						break;
					default:
						break _hx_loop2;
					}
				}
			}
			let hint = this.hintFromCache(fileName,nameToken.index,nameToken.pos.min);
			if(hint != null) {
				promises.push(Promise.resolve([hint]));
				continue;
			}
			let pos = this.converter.byteOffsetToCharacterOffset(doc.content,nameToken.pos.min);
			promises.push(this.resolveType(fileName,pos,token).then(function(hover) {
				if(hover == null) {
					return Promise.resolve();
				}
				let hint = _gthis.makeTypeHint(doc,hover,insertPos,$bind(_gthis,_gthis.buildTypeHint));
				if(hint == null) {
					return Promise.resolve();
				}
				_gthis.cacheHint(fileName,nameToken.index,nameToken.pos.min,hint);
				return Promise.resolve([hint]);
			}).catch(function(_) {
				return Promise.resolve();
			}));
		}
		return promises;
	}
	findAllPOpens(doc,fileName,root,startPos,endPos,token) {
		let promises = [];
		let allPOpens = root.filterCallback(function(token,_) {
			if(startPos > token.pos.min) {
				return tokentree_FilterResult.GoDeeper;
			}
			if(endPos < token.pos.min) {
				return tokentree_FilterResult.GoDeeper;
			}
			if(token.tok._hx_index == 20) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < allPOpens.length) {
			let pOpen = allPOpens[_g];
			++_g;
			switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(pOpen)._hx_index) {
			case 1:
				if(this.inlayHintsFunctionReturnTypes) {
					promises = promises.concat(this.makeFunctionInlayHints(doc,fileName,pOpen,token));
				}
				break;
			case 2:
				if(this.inlayHintsParameterNames || this.inlayHintsParameterTypes) {
					promises = promises.concat(this.makeCallInlayHints(doc,fileName,pOpen,token));
				}
				break;
			case 0:case 3:case 4:case 5:case 6:case 7:case 8:case 9:
				break;
			}
		}
		return promises;
	}
	makeFunctionInlayHints(doc,fileName,pOpen,token) {
		let promises = [];
		if(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.parent(pOpen),tokentree_TokenTreeDef.DblDot) != null) {
			return promises;
		}
		if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(pOpen),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdNew)) != null) {
			return promises;
		}
		let _v_ = tokentree_TokenTreeAccessHelper.firstOf(pOpen,tokentree_TokenTreeDef.PClose);
		let pClose = _v_ == null ? null : _v_;
		if(pClose == null) {
			return promises;
		}
		let hint = this.hintFromCache(fileName,pOpen.index,pOpen.pos.min);
		if(hint != null) {
			promises.push(Promise.resolve([hint]));
			return promises;
		}
		let insertPos = pClose.pos.max;
		let pos = this.converter.byteOffsetToCharacterOffset(doc.content,pOpen.pos.min);
		let _gthis = this;
		promises.push(this.resolveType(fileName,pos,token).then(function(hover) {
			if(hover == null) {
				return Promise.resolve();
			}
			let hint = _gthis.makeTypeHint(doc,hover,insertPos,$bind(_gthis,_gthis.buildReturnTypeHint));
			if(hint == null) {
				return Promise.resolve();
			}
			_gthis.cacheHint(fileName,pOpen.index,pOpen.pos.min,hint);
			return Promise.resolve([hint]);
		}).catch(function(_) {
			return Promise.resolve();
		}));
		return promises;
	}
	makeTypeHint(doc,hover,insertPos,printFunc) {
		let type = printFunc(hover);
		if(type == null) {
			return null;
		}
		let text = ":" + type;
		return { position : doc.positionAt(this.converter.byteOffsetToCharacterOffset(doc.content,insertPos)), label : text, kind : 1, textEdits : [{ range : { start : doc.positionAt(insertPos,1), end : doc.positionAt(insertPos,1)}, newText : text}], paddingRight : false, paddingLeft : true};
	}
	makeCallInlayHints(doc,fileName,pOpen,token) {
		let promises = [];
		let this1 = tokentree_TokenTreeAccessHelper.firstOf(pOpen,tokentree_TokenTreeDef.PClose);
		if(this1 == null) {
			return promises;
		}
		if(this1.pos.min == pOpen.pos.max) {
			return promises;
		}
		let childs = pOpen.children;
		if(childs == null) {
			return promises;
		}
		let _gthis = this;
		let _g = 0;
		while(_g < childs.length) {
			let paramChild = childs[_g];
			++_g;
			let _g1 = paramChild.tok;
			switch(_g1._hx_index) {
			case 2:
				let _gc = _g1.c;
				if(_gc._hx_index == 3) {
					if(_gc.s == "_") {
						continue;
					}
				}
				break;
			case 6:
				continue;
			case 21:
				return promises;
			default:
			}
			let insertPos = paramChild.pos.min;
			let typeInsertPos = this.findParamTypePos(paramChild);
			let hoverTarget = this.findHoverTarget(paramChild);
			let cachedHints = [];
			if(this.inlayHintsParameterNames) {
				let hint = this.hintFromCache(fileName,hoverTarget.index,hoverTarget.pos.min);
				if(hint != null) {
					cachedHints.push(hint);
				}
			}
			if(this.inlayHintsParameterTypes) {
				let hint = this.hintFromCache(fileName,hoverTarget.index,typeInsertPos);
				if(hint != null) {
					cachedHints.push(hint);
				}
			}
			if(cachedHints.length > 0) {
				promises.push(Promise.resolve(cachedHints));
				continue;
			}
			let pos = this.converter.byteOffsetToCharacterOffset(doc.content,hoverTarget.pos.min);
			promises.push(this.resolveType(fileName,pos,token).then(function(hover) {
				if(hover == null) {
					return Promise.resolve();
				}
				let hints = [];
				if(_gthis.inlayHintsParameterNames) {
					let name = _gthis.buildParameterName(hover);
					if(name == null) {
						return Promise.resolve();
					}
					if(name == "") {
						name = "<unnamed>";
					}
					let nameHint = { position : doc.positionAt(_gthis.converter.byteOffsetToCharacterOffset(doc.content,insertPos)), label : "" + name + ":", kind : 2, paddingRight : true, paddingLeft : false};
					_gthis.cacheHint(fileName,hoverTarget.index,hoverTarget.pos.min,nameHint);
					hints.push(nameHint);
				}
				if(_gthis.inlayHintsParameterTypes) {
					let type = _gthis.buildTypeHint(hover);
					if(type == null) {
						return Promise.resolve(hints);
					}
					if(type != "") {
						let typeHint = { position : doc.positionAt(_gthis.converter.byteOffsetToCharacterOffset(doc.content,typeInsertPos)), label : " /* " + type + " */", kind : 1, paddingRight : false, paddingLeft : true};
						_gthis.cacheHint(fileName,hoverTarget.index,typeInsertPos,typeHint);
						hints.push(typeHint);
					}
				}
				return Promise.resolve(hints);
			}).catch(function(_) {
				return Promise.resolve();
			}));
		}
		return promises;
	}
	findHoverTarget(token) {
		let lastBinop = null;
		while(token.nextSibling != null) if(token.nextSibling.tok._hx_index == 6) {
			token = token.nextSibling;
			lastBinop = token;
		} else {
			break;
		}
		if(lastBinop != null) {
			return lastBinop;
		}
		if(!token.hasChildren()) {
			return token;
		}
		let _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index != 23) {
				return token;
			}
			break;
		case 15:case 18:
			return token;
		default:
		}
		let lastChild = token.getLastChild();
		if(lastChild == null) {
			return token;
		}
		if(lastChild.tok._hx_index == 15) {
			lastChild = lastChild.previousSibling;
			if(lastChild == null) {
				return token;
			}
			return this.findHoverTarget(lastChild);
		} else {
			return this.findHoverTarget(lastChild);
		}
	}
	findParamTypePos(token) {
		let lastChild = token.getLastChild();
		if(lastChild == null) {
			return token.pos.max;
		}
		if(lastChild.tok._hx_index == 15) {
			if(lastChild.previousSibling == null) {
				return token.pos.max;
			}
			lastChild = lastChild.previousSibling;
		}
		if(lastChild == null) {
			return token.pos.max;
		}
		return lastChild.getPos().max;
	}
	resolveType(fileName,pos,token) {
		let newRequest = { params : { file : fileName, offset : pos}, token : token, resolve : null};
		let promise = new Promise(function(resolve,reject) {
			newRequest.resolve = resolve;
		});
		this.hoverRequests.push(newRequest);
		if(this.hoverRequests.length != 1) {
			return promise;
		}
		this.requestHover(newRequest);
		return promise;
	}
	requestHover(request) {
		if(request.token.canceled) {
			this.hoverRequests.shift();
			this.nextHover();
			return;
		}
		let _gthis = this;
		this.context.callHaxeMethod("display/hover",request.params,request.token,function(hover) {
			if(request.resolve != null) {
				if(hover == null) {
					request.resolve(null);
				} else {
					request.resolve(hover);
				}
			}
			_gthis.hoverRequests.shift();
			_gthis.nextHover();
			return null;
		},function(msg) {
			if(request.resolve != null) {
				request.resolve(null);
			}
			_gthis.hoverRequests.shift();
			_gthis.nextHover();
		});
	}
	nextHover() {
		if(this.hoverRequests.length <= 0) {
			return;
		}
		this.requestHover(this.hoverRequests[0]);
	}
	removeCancelledRequests() {
		while(this.hoverRequests.length > 0) {
			if(!this.hoverRequests[0].token.canceled) {
				return;
			}
			this.hoverRequests.shift();
		}
	}
	buildParameterName(hover) {
		let _v_ = hover.expected;
		let _v_1 = _v_ == null ? null : _v_.name;
		if(_v_1 == null) {
			return null;
		} else {
			return _v_1.name;
		}
	}
	buildTypeHint(hover) {
		let _v_ = hover.item;
		let type = _v_ == null ? null : _v_.type;
		if(type == null) {
			return null;
		}
		return this.printer.printType(type);
	}
	buildReturnTypeHint(hover) {
		let _v_ = hover.item.type;
		let _v_1 = _v_ == null ? null : _v_.args;
		let type = _v_1 == null ? null : _v_1.ret;
		if(type == null) {
			return null;
		}
		return this.printer.printType(type);
	}
	registerChangeHandler(doc,fileName) {
		if(Object.prototype.hasOwnProperty.call(this.cache.h,fileName)) {
			return;
		}
		doc.removeUpdateListener($bind(this,this.onDocChange));
		doc.addUpdateListener($bind(this,this.onDocChange));
	}
	onDocChange(doc,changes,version) {
		let this1 = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc.uri);
		let _this = this.cache;
		if(Object.prototype.hasOwnProperty.call(_this.h,this1)) {
			delete(_this.h[this1]);
		}
	}
	hintFromCache(fileName,tokenIndex,position) {
		let fileCache = this.cache.h[fileName];
		if(fileCache == null) {
			return null;
		}
		return fileCache.h["" + position + "." + tokenIndex];
	}
	cacheHint(fileName,tokenIndex,position,hint) {
		let fileCache = this.cache.h[fileName];
		if(fileCache == null) {
			fileCache = new haxe_ds_StringMap();
			this.cache.h[fileName] = fileCache;
		}
		fileCache.h["" + position + "." + tokenIndex] = hint;
	}
}
haxeLanguageServer_features_haxe_InlayHintFeature.__name__ = "haxeLanguageServer.features.haxe.InlayHintFeature";
Object.assign(haxeLanguageServer_features_haxe_InlayHintFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_InlayHintFeature
});
class haxeLanguageServer_features_haxe_RenameFeature {
	constructor(context) {
		this.context = context;
		this.cache = new refactor_cache_MemCache();
		this.typer = new haxeLanguageServer_features_haxe_LanguageServerTyper(context);
		this.converter = new haxeLanguageServer_helper_Haxe3DisplayOffsetConverter();
		context.languageServerProtocol.onRequest("textDocument/prepareRename",$bind(this,this.onPrepareRename));
		context.languageServerProtocol.onRequest("textDocument/rename",$bind(this,this.onRename));
	}
	onPrepareRename(params,token,resolve,reject) {
		let onResolve = this.context.startTimer("textDocument/prepareRename");
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null || !haxeLanguageServer_extensions_DocumentUriExtensions_isFile(uri)) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		let filePath = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri);
		let usageContext = this.makeUsageContext();
		usageContext.fileName = filePath;
		let _v_ = doc1 == null ? null : doc1.get_tokens();
		let root = _v_ == null ? null : _v_.tree;
		if(root == null) {
			usageContext.usageCollector.parseFile(haxe_io_Bytes.ofString(doc1.content),usageContext);
		} else {
			usageContext.usageCollector.parseFileWithTokens(root,usageContext);
		}
		let editList = new haxeLanguageServer_features_haxe_EditList();
		let _gthis = this;
		refactor_Refactor.canRename({ nameMap : usageContext.nameMap, fileList : usageContext.fileList, typeList : usageContext.typeList, what : { fileName : filePath, toName : "", pos : this.converter.characterOffsetToByteOffset(doc1.content,doc1.offsetAt(params.position))}, verboseLog : function(text,pos) {
			haxe_Log.trace("[canRename] " + text,{ fileName : "src/haxeLanguageServer/features/haxe/RenameFeature.hx", lineNumber : 80, className : "haxeLanguageServer.features.haxe.RenameFeature", methodName : "onPrepareRename"});
		}, typer : this.typer}).then(function(result) {
			if(result == null) {
				let reject1 = reject;
				let data = null;
				let this1 = { code : -32603, message : "cannot rename identifier"};
				if(data != null) {
					this1.data = data;
				}
				reject1(this1);
			}
			resolve({ range : new haxeLanguageServer_features_haxe_EditDoc(filePath,editList,_gthis.context,_gthis.converter).posToRange(result.pos), placeholder : result.name});
			onResolve();
		}).catch(function(msg) {
			haxe_Log.trace("[canRename] error: " + msg,{ fileName : "src/haxeLanguageServer/features/haxe/RenameFeature.hx", lineNumber : 95, className : "haxeLanguageServer.features.haxe.RenameFeature", methodName : "onPrepareRename"});
			let reject1 = reject;
			let data = null;
			let this1 = { code : -32603, message : "" + msg};
			if(data != null) {
				this1.data = data;
			}
			reject1(this1);
		});
	}
	onRename(params,token,resolve,reject) {
		let onResolve = this.context.startTimer("textDocument/rename");
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null || !haxeLanguageServer_extensions_DocumentUriExtensions_isFile(uri)) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		let filePath = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri);
		let usageContext = this.makeUsageContext();
		this.typer.typeList = usageContext.typeList;
		let srcFolders = ["src","source","Source","test","tests"];
		if(this.context.config.user.renameSourceFolders != null) {
			srcFolders = this.context.config.user.renameSourceFolders;
		}
		let workspacePath = haxeLanguageServer_helper_PathHelper.normalize(this.context.workspacePath);
		let result = new Array(srcFolders.length);
		let _g = 0;
		let _g1 = srcFolders.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = haxe_io_Path.join([workspacePath,srcFolders[i]]);
		}
		refactor_discover_TraverseSources.traverseSources(result,usageContext);
		usageContext.usageCollector.updateImportHx(usageContext);
		let editList = new haxeLanguageServer_features_haxe_EditList();
		let _gthis = this;
		refactor_Refactor.rename({ nameMap : usageContext.nameMap, fileList : usageContext.fileList, typeList : usageContext.typeList, what : { fileName : filePath, toName : params.newName, pos : this.converter.characterOffsetToByteOffset(doc1.content,doc1.offsetAt(params.position))}, forRealExecute : true, docFactory : function(filePath) {
			return new haxeLanguageServer_features_haxe_EditDoc(filePath,editList,_gthis.context,_gthis.converter);
		}, verboseLog : function(text,pos) {
			haxe_Log.trace("[rename] " + text,{ fileName : "src/haxeLanguageServer/features/haxe/RenameFeature.hx", lineNumber : 140, className : "haxeLanguageServer.features.haxe.RenameFeature", methodName : "onRename"});
		}, typer : this.typer}).then(function(result) {
			switch(result._hx_index) {
			case 0:
				haxe_Log.trace("[rename] no change",{ fileName : "src/haxeLanguageServer/features/haxe/RenameFeature.hx", lineNumber : 147, className : "haxeLanguageServer.features.haxe.RenameFeature", methodName : "onRename"});
				let reject1 = reject;
				let data = null;
				let this1 = { code : -32603, message : "no change"};
				if(data != null) {
					this1.data = data;
				}
				reject1(this1);
				break;
			case 1:
				haxe_Log.trace("[rename] could not find identifier at \"" + (filePath == null ? "null" : filePath) + "@" + Std.string(params.position) + "\"" + haxeLanguageServer_features_haxe_RenameFeature.HINT_SETTINGS,{ fileName : "src/haxeLanguageServer/features/haxe/RenameFeature.hx", lineNumber : 150, className : "haxeLanguageServer.features.haxe.RenameFeature", methodName : "onRename"});
				let reject2 = reject;
				let data1 = null;
				let this2 = { code : -32603, message : "could not find identifier at \"" + (filePath == null ? "null" : filePath) + "@" + Std.string(params.position) + "\"" + haxeLanguageServer_features_haxe_RenameFeature.HINT_SETTINGS};
				if(data1 != null) {
					this2.data = data1;
				}
				reject2(this2);
				break;
			case 2:
				let _gname = result.name;
				haxe_Log.trace("[rename] refactoring not supported for \"" + _gname + "\"",{ fileName : "src/haxeLanguageServer/features/haxe/RenameFeature.hx", lineNumber : 153, className : "haxeLanguageServer.features.haxe.RenameFeature", methodName : "onRename"});
				let reject3 = reject;
				let data2 = null;
				let this3 = { code : -32603, message : "refactoring not supported for \"" + _gname + "\""};
				if(data2 != null) {
					this3.data = data2;
				}
				reject3(this3);
				break;
			case 3:
				haxe_Log.trace("[rename] dry run",{ fileName : "src/haxeLanguageServer/features/haxe/RenameFeature.hx", lineNumber : 156, className : "haxeLanguageServer.features.haxe.RenameFeature", methodName : "onRename"});
				let reject4 = reject;
				let data3 = null;
				let this4 = { code : -32603, message : "dry run"};
				if(data3 != null) {
					this4.data = data3;
				}
				reject4(this4);
				break;
			case 4:
				resolve({ documentChanges : editList.documentChanges});
				break;
			}
			onResolve(null,editList.documentChanges.length + " changes");
		}).catch(function(msg) {
			haxe_Log.trace("[rename] error: " + msg + haxeLanguageServer_features_haxe_RenameFeature.HINT_SETTINGS,{ fileName : "src/haxeLanguageServer/features/haxe/RenameFeature.hx", lineNumber : 163, className : "haxeLanguageServer.features.haxe.RenameFeature", methodName : "onRename"});
			let reject1 = reject;
			let data = null;
			let this1 = { code : -32603, message : "" + msg + haxeLanguageServer_features_haxe_RenameFeature.HINT_SETTINGS};
			if(data != null) {
				this1.data = data;
			}
			reject1(this1);
		});
	}
	makeUsageContext() {
		return { fileName : "", file : null, usageCollector : new refactor_discover_UsageCollector(), nameMap : new refactor_discover_NameMap(), fileList : new refactor_discover_FileList(), typeList : new refactor_discover_TypeList(), type : null, cache : this.cache};
	}
}
haxeLanguageServer_features_haxe_RenameFeature.__name__ = "haxeLanguageServer.features.haxe.RenameFeature";
Object.assign(haxeLanguageServer_features_haxe_RenameFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_RenameFeature
});
class haxeLanguageServer_features_haxe_EditList {
	constructor() {
		this.documentChanges = [];
	}
	addEdit(edit) {
		this.documentChanges.push(edit);
	}
}
haxeLanguageServer_features_haxe_EditList.__name__ = "haxeLanguageServer.features.haxe.EditList";
Object.assign(haxeLanguageServer_features_haxe_EditList.prototype, {
	__class__: haxeLanguageServer_features_haxe_EditList
});
class refactor_edits_IEditableDocument {
}
refactor_edits_IEditableDocument.__name__ = "refactor.edits.IEditableDocument";
refactor_edits_IEditableDocument.__isInterface__ = true;
Object.assign(refactor_edits_IEditableDocument.prototype, {
	__class__: refactor_edits_IEditableDocument
});
class haxeLanguageServer_features_haxe_EditDoc {
	constructor(filePath,list,context,converter) {
		this.filePath = filePath;
		this.list = list;
		this.context = context;
		this.converter = converter;
		this.edits = [];
		this.renames = [];
	}
	addChange(edit) {
		switch(edit._hx_index) {
		case 0:
			this.renames.push({ kind : "rename", oldUri : haxeLanguageServer_extensions_FsPathExtensions_toUri(this.filePath), newUri : haxeLanguageServer_extensions_FsPathExtensions_toUri(edit.newFileName), options : { overwrite : false, ignoreIfExists : false}});
			break;
		case 1:
			this.edits.push({ range : this.posToRange(edit.pos), newText : edit.text});
			break;
		case 2:
			this.edits.push({ range : this.posToRange(edit.pos), newText : edit.text});
			break;
		case 3:
			this.edits.push({ range : this.posToRange(edit.pos), newText : ""});
			break;
		}
	}
	posToRange(pos) {
		let _this = this.context.documents;
		let uri = haxeLanguageServer_extensions_FsPathExtensions_toUri(this.filePath);
		let value = _this.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null) {
			let content = js_node_Fs.readFileSync(this.filePath,{ encoding : "utf8"});
			let lineSeparator = this.detectLineSeparator(content);
			let separatorLength = lineSeparator.length;
			let lines = content.split(lineSeparator);
			let startPos = null;
			let endPos = null;
			let curLineStart = 0;
			let curLine = 0;
			let startOffset = this.converter.byteOffsetToCharacterOffset(content,pos.start);
			let endOffset = this.converter.byteOffsetToCharacterOffset(content,pos.end);
			let _g = 0;
			while(_g < lines.length) {
				let length = lines[_g++].length + separatorLength;
				if(startOffset > curLineStart + length) {
					curLineStart += length;
					++curLine;
					continue;
				}
				if(startOffset >= curLineStart && startOffset < curLineStart + length) {
					startPos = { line : curLine, character : startOffset - curLineStart};
				}
				if(endOffset >= curLineStart && endOffset < curLineStart + length) {
					endPos = { line : curLine, character : endOffset - curLineStart};
					break;
				}
				curLineStart += length;
				++curLine;
			}
			if(startPos == null || endPos == null) {
				throw haxe_Exception.thrown("" + (this.filePath == null ? "null" : this.filePath) + " not found");
			}
			return { start : startPos, end : endPos};
		}
		let startOffset = this.converter.byteOffsetToCharacterOffset(doc1.content,pos.start);
		let endOffset = this.converter.byteOffsetToCharacterOffset(doc1.content,pos.end);
		return { start : doc1.positionAt(startOffset,1), end : doc1.positionAt(endOffset,1)};
	}
	detectLineSeparator(code) {
		let lineSeparator;
		let _g = 0;
		let _g1 = code.length;
		while(_g < _g1) {
			let i = _g++;
			let char = code.charAt(i);
			if(char == "\r" || char == "\n") {
				lineSeparator = char;
				if(char == "\r" && i + 1 < code.length) {
					char = code.charAt(i + 1);
					if(char == "\n") {
						lineSeparator += char;
					}
				}
				return lineSeparator;
			}
		}
		return "\n";
	}
	endEdits() {
		this.list.addEdit({ textDocument : { uri : haxeLanguageServer_extensions_FsPathExtensions_toUri(this.filePath), version : null}, edits : this.edits});
		let _g = 0;
		let _g1 = this.renames;
		while(_g < _g1.length) this.list.addEdit(_g1[_g++]);
	}
}
haxeLanguageServer_features_haxe_EditDoc.__name__ = "haxeLanguageServer.features.haxe.EditDoc";
haxeLanguageServer_features_haxe_EditDoc.__interfaces__ = [refactor_edits_IEditableDocument];
Object.assign(haxeLanguageServer_features_haxe_EditDoc.prototype, {
	__class__: haxeLanguageServer_features_haxe_EditDoc
});
class refactor_ITyper {
}
refactor_ITyper.__name__ = "refactor.ITyper";
refactor_ITyper.__isInterface__ = true;
Object.assign(refactor_ITyper.prototype, {
	__class__: refactor_ITyper
});
class haxeLanguageServer_features_haxe_LanguageServerTyper {
	constructor(context) {
		this.context = context;
	}
	resolveType(filePath,pos) {
		let params = { file : filePath, offset : pos, wasAutoTriggered : true};
		haxe_Log.trace("[rename] requesting type info for " + filePath + "@" + pos,{ fileName : "src/haxeLanguageServer/features/haxe/RenameFeature.hx", lineNumber : 321, className : "haxeLanguageServer.features.haxe.LanguageServerTyper", methodName : "resolveType"});
		let _gthis = this;
		return new Promise(function(resolve,reject) {
			_gthis.context.callHaxeMethod("display/hover",params,null,function(hover) {
				if(hover == null) {
					haxe_Log.trace("[rename] received no type info for " + filePath + "@" + pos,{ fileName : "src/haxeLanguageServer/features/haxe/RenameFeature.hx", lineNumber : 327, className : "haxeLanguageServer.features.haxe.LanguageServerTyper", methodName : "resolveType"});
					resolve(null);
				} else {
					resolve(_gthis.buildTypeHint(hover,"" + filePath + "@" + pos));
				}
				return null;
			},haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject));
		});
	}
	buildTypeHint(item,location) {
		if(this.typeList == null) {
			return null;
		}
		let reg = new EReg("Class<(.*)>","");
		let _v_ = item == null ? null : item.item;
		let type = _v_ == null ? null : _v_.type;
		if(type == null) {
			return null;
		}
		let _v_1 = type;
		let _v_2 = _v_1 == null ? null : _v_1.args;
		let path = _v_2 == null ? null : _v_2.path;
		if(path == null) {
			return null;
		}
		if(path.moduleName == "StdTypes" && path.typeName == "Null") {
			let _v_ = type;
			let _v_1 = _v_ == null ? null : _v_.args;
			let params = _v_1 == null ? null : _v_1.params;
			if(params == null) {
				return null;
			}
			type = params[0];
			if(type == null) {
				return null;
			}
			let _v_2 = type;
			let _v_3 = _v_2 == null ? null : _v_2.args;
			path = _v_3 == null ? null : _v_3.path;
			if(path == null) {
				return null;
			}
		}
		if(reg.match(path.typeName)) {
			let parts = reg.matched(1).split(".");
			if(parts.length <= 0) {
				return null;
			}
			path.typeName = parts.pop();
			path.pack = parts;
		}
		let fullPath = "" + haxeLanguageServer_protocol_DotPath_getDotPath(type);
		haxe_Log.trace("[rename] received type " + fullPath + " for " + location,{ fileName : "src/haxeLanguageServer/features/haxe/RenameFeature.hx", lineNumber : 379, className : "haxeLanguageServer.features.haxe.LanguageServerTyper", methodName : "buildTypeHint"});
		return this.typeList.makeTypeHintType(fullPath);
	}
}
haxeLanguageServer_features_haxe_LanguageServerTyper.__name__ = "haxeLanguageServer.features.haxe.LanguageServerTyper";
haxeLanguageServer_features_haxe_LanguageServerTyper.__interfaces__ = [refactor_ITyper];
Object.assign(haxeLanguageServer_features_haxe_LanguageServerTyper.prototype, {
	__class__: haxeLanguageServer_features_haxe_LanguageServerTyper
});
class haxeLanguageServer_features_haxe_SignatureHelpFeature {
	constructor(context) {
		this.context = context;
		let _v_ = context.capabilities.textDocument;
		let _v_1 = _v_ == null ? null : _v_.signatureHelp;
		let _v_2 = _v_1 == null ? null : _v_1.signatureInformation;
		let _v_3 = _v_2 == null ? null : _v_2.parameterInformation;
		this.labelOffsetSupport = (_v_3 == null ? null : _v_3.labelOffsetSupport) == true;
		context.languageServerProtocol.onRequest("textDocument/signatureHelp",$bind(this,this.onSignatureHelp));
	}
	onSignatureHelp(params,token,resolve,reject) {
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null || !haxeLanguageServer_extensions_DocumentUriExtensions_isFile(uri)) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		(this.context.haxeServer.supports("display/signatureHelp") ? $bind(this,this.handleJsonRpc) : $bind(this,this.handleLegacy))(params,token,resolve,reject,doc1);
	}
	handleJsonRpc(params,token,resolve,reject,doc) {
		let wasAutoTriggered = true;
		if(haxeLanguageServer_helper_SemVer.isEqualOrGreaterThan(this.context.haxeServer.haxeVersion,{ major : 4, minor : 1, patch : 0, pre : null, build : null})) {
			let _v_ = params == null ? null : params.context;
			let triggerKind = _v_ == null ? null : _v_.triggerKind;
			if(triggerKind == null) {
				wasAutoTriggered = false;
			} else {
				switch(triggerKind) {
				case 1:case 3:
					wasAutoTriggered = false;
					break;
				case 2:
					wasAutoTriggered = true;
					break;
				}
			}
		}
		let params1 = { file : haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc.uri), contents : doc.content, offset : this.context.displayOffsetConverter.characterOffsetToByteOffset(doc.content,doc.offsetAt(params.position)), wasAutoTriggered : wasAutoTriggered};
		let _gthis = this;
		this.context.callHaxeMethod("display/signatureHelp",params1,token,function(result) {
			if(result == null) {
				resolve(null);
			} else {
				resolve(_gthis.createSignatureHelp(result));
			}
			return null;
		},haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject));
	}
	createSignatureHelp(item) {
		let printer = new haxeLanguageServer_protocol_DisplayPrinter();
		let labelOffset = 1;
		let _gthis = this;
		let createSignatureParameter = function(arg) {
			let printed = printer.printFunctionArgument(arg);
			let createSignatureParameter;
			if(_gthis.labelOffsetSupport) {
				let range = [labelOffset,labelOffset + printed.length];
				labelOffset += printed.length;
				labelOffset += 2;
				createSignatureParameter = range;
			} else {
				createSignatureParameter = printed;
			}
			return { label : createSignatureParameter};
		};
		let createSignatureInformation = function(info) {
			let label = item.kind == 1 ? printer.printArrayAccess(info) : printer.printType({ kind : "TFun", args : { args : info.args, ret : info.ret}});
			let createSignatureInformation = _gthis.getSignatureDocumentation(info.documentation);
			let _this = info.args;
			let f = createSignatureParameter;
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = f(_this[i]);
			}
			return { label : label, documentation : createSignatureInformation, parameters : result};
		};
		let item1 = item.activeSignature;
		let item2 = item.activeParameter;
		let _this = item.signatures;
		let f = createSignatureInformation;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = f(_this[i]);
		}
		return { activeSignature : item1, activeParameter : item2, signatures : result};
	}
	handleLegacy(params,token,resolve,reject,doc) {
		let bytePos = this.context.displayOffsetConverter.characterOffsetToByteOffset(doc.content,doc.offsetAt(params.position));
		let tmp = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc.uri);
		let _gthis = this;
		this.context.callDisplay("@signature",["" + (tmp == null ? "null" : tmp) + "@" + bytePos + "@signature"],doc.content,token,function(result) {
			switch(result._hx_index) {
			case 0:
				resolve(null);
				break;
			case 1:
				let help = JSON.parse(result.msg);
				let _g = 0;
				let _g1 = help.signatures;
				while(_g < _g1.length) {
					let signature = _g1[_g];
					++_g;
					signature.documentation = _gthis.getSignatureDocumentation(signature.documentation);
					let parameters = signature.parameters;
					if(parameters != null) {
						let _g = 0;
						let _g1 = parameters.length;
						while(_g < _g1) {
							let i = _g++;
							parameters[i].label = haxeLanguageServer_helper_IdentifierHelper.addNamesToSignatureType(parameters[i].label,i);
						}
					}
					signature.label = haxeLanguageServer_helper_IdentifierHelper.addNamesToSignatureType(signature.label);
				}
				resolve(help);
				break;
			}
		},haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject));
	}
	getSignatureDocumentation(documentation) {
		if(documentation != null && this.context.config.user.enableSignatureHelpDocumentation) {
			return { kind : "markdown", value : haxeLanguageServer_helper_DocHelper.markdownFormat(documentation)};
		}
		return undefined;
	}
}
haxeLanguageServer_features_haxe_SignatureHelpFeature.__name__ = "haxeLanguageServer.features.haxe.SignatureHelpFeature";
Object.assign(haxeLanguageServer_features_haxe_SignatureHelpFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_SignatureHelpFeature
});
class haxeLanguageServer_features_haxe_WorkspaceSymbolsFeature {
	constructor(context) {
		this.context = context;
		context.languageServerProtocol.onRequest("workspace/symbol",$bind(this,this.onWorkspaceSymbols));
	}
	processSymbolsReply(data,reject) {
		let result = [];
		let _g = 0;
		while(_g < data.length) {
			let file = data[_g];
			++_g;
			let uri = haxeLanguageServer_extensions_FsPathExtensions_toUri(haxeLanguageServer_helper_HaxePosition.getProperFileNameCase(file.file));
			let _g1 = 0;
			let _g2 = file.symbols;
			while(_g1 < _g2.length) {
				let symbol = _g2[_g1];
				++_g1;
				if(symbol.range == null) {
					let _this = this.context;
					let message = "Unknown location for " + JSON.stringify(symbol);
					let _this1 = _this.languageServerProtocol;
					let params = { type : 1, message : message};
					let message1 = { jsonrpc : "2.0", method : "window/showMessage"};
					if(params != null) {
						message1.params = params;
					}
					_this1.writeMessage(message1,null);
					if(_this1.didSendNotification != null) {
						_this1.didSendNotification(message1);
					}
					continue;
				}
				result.push(this.moduleSymbolEntryToSymbolInformation(symbol,uri));
			}
		}
		return result;
	}
	makeRequest(label,args,doc,token,resolve,reject) {
		let onResolve = this.context.startTimer("@workspace-symbols");
		let _gthis = this;
		this.context.callDisplay(label,args,doc == null ? null : doc.content,token,function(r) {
			switch(r._hx_index) {
			case 0:
				resolve([]);
				break;
			case 1:
				let _gmsg = r.msg;
				let data;
				try {
					data = JSON.parse(_gmsg);
				} catch( _g ) {
					let _g1 = haxe_Exception.caught(_g);
					let reject1 = reject;
					let data = null;
					let this1 = { code : -32603, message : "Error parsing document symbol response: " + Std.string(_g1)};
					if(data != null) {
						this1.data = data;
					}
					reject1(this1);
					return;
				}
				let result = _gthis.processSymbolsReply(data,reject);
				resolve(result);
				onResolve(data,data.length + " symbols");
				break;
			}
		},haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject));
	}
	onWorkspaceSymbols(params,token,resolve,reject) {
		this.makeRequest("@workspace-symbols",["?@0@workspace-symbols@" + params.query],null,token,resolve,reject);
	}
	moduleSymbolEntryToSymbolInformation(entry,uri) {
		let result;
		switch(entry.kind) {
		case 3:
			result = 10;
			break;
		case 2:case 4:
			result = 11;
			break;
		case 1:case 5:
			result = 5;
			break;
		case 6:
			result = 8;
			break;
		case 7:
			result = 7;
			break;
		case 8:
			result = 6;
			break;
		case 9:
			result = 9;
			break;
		case 10:
			result = 12;
			break;
		case 11:
			result = 13;
			break;
		case 12:
			result = 23;
			break;
		case 13:
			result = 10;
			break;
		case 14:
			result = 25;
			break;
		case 15:
			result = 22;
			break;
		case 16:
			result = 14;
			break;
		case 17:
			result = 2;
			break;
		}
		let result1 = { name : entry.name, kind : result, location : { uri : uri, range : entry.range}};
		if(entry.containerName != null) {
			result1.containerName = entry.containerName;
		}
		if(entry.isDeprecated != null && entry.isDeprecated) {
			result1.tags = [1];
		}
		return result1;
	}
}
haxeLanguageServer_features_haxe_WorkspaceSymbolsFeature.__name__ = "haxeLanguageServer.features.haxe.WorkspaceSymbolsFeature";
Object.assign(haxeLanguageServer_features_haxe_WorkspaceSymbolsFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_WorkspaceSymbolsFeature
});
class haxeLanguageServer_features_haxe_codeAction_CodeActionContributor {
}
haxeLanguageServer_features_haxe_codeAction_CodeActionContributor.__name__ = "haxeLanguageServer.features.haxe.codeAction.CodeActionContributor";
haxeLanguageServer_features_haxe_codeAction_CodeActionContributor.__isInterface__ = true;
Object.assign(haxeLanguageServer_features_haxe_codeAction_CodeActionContributor.prototype, {
	__class__: haxeLanguageServer_features_haxe_codeAction_CodeActionContributor
});
var haxeLanguageServer_features_haxe_codeAction_CodeActionResolveType = $hxEnums["haxeLanguageServer.features.haxe.codeAction.CodeActionResolveType"] = { __ename__:true,__constructs__:null
	,MissingArg: {_hx_name:"MissingArg",_hx_index:0,__enum__:"haxeLanguageServer.features.haxe.codeAction.CodeActionResolveType",toString:$estr}
	,ChangeFinalToVar: {_hx_name:"ChangeFinalToVar",_hx_index:1,__enum__:"haxeLanguageServer.features.haxe.codeAction.CodeActionResolveType",toString:$estr}
	,AddTypeHint: {_hx_name:"AddTypeHint",_hx_index:2,__enum__:"haxeLanguageServer.features.haxe.codeAction.CodeActionResolveType",toString:$estr}
};
haxeLanguageServer_features_haxe_codeAction_CodeActionResolveType.__constructs__ = [haxeLanguageServer_features_haxe_codeAction_CodeActionResolveType.MissingArg,haxeLanguageServer_features_haxe_codeAction_CodeActionResolveType.ChangeFinalToVar,haxeLanguageServer_features_haxe_codeAction_CodeActionResolveType.AddTypeHint];
class haxeLanguageServer_features_haxe_codeAction_CodeActionFeature {
	constructor(context) {
		this.contributors = [];
		this.context = context;
		context.registerCapability("textDocument/codeAction",null,{ documentSelector : haxeLanguageServer_Context.haxeSelector, codeActionKinds : ["quickfix","source.organizeImports","source.sortImports","refactor.extract","refactor.rewrite","source.fixAll"], resolveProvider : true});
		let _v_ = context.capabilities.textDocument;
		let _v_1 = _v_ == null ? null : _v_.codeAction;
		let _v_2 = _v_1 == null ? null : _v_1.resolveSupport;
		this.hasCommandResolveSupport = (_v_2 == null ? null : _v_2.properties).includes("command");
		context.languageServerProtocol.onRequest("textDocument/codeAction",$bind(this,this.onCodeAction));
		context.languageServerProtocol.onRequest("codeAction/resolve",$bind(this,this.onCodeActionResolve));
		this.registerContributor(new haxeLanguageServer_features_haxe_codeAction_ExtractVarFeature(context));
		this.registerContributor(new haxeLanguageServer_features_haxe_codeAction_ExtractConstantFeature(context));
		this.registerContributor(new haxeLanguageServer_features_haxe_codeAction_DiagnosticsCodeActionFeature(context));
		this.registerContributor(new haxeLanguageServer_features_haxe_codeAction_ExtractTypeFeature(context));
		this.registerContributor(new haxeLanguageServer_features_haxe_codeAction_ExtractFunctionFeature(context));
	}
	registerContributor(contributor) {
		this.contributors.push(contributor);
	}
	onCodeAction(params,token,resolve,reject) {
		let codeActions = [];
		let _g = 0;
		let _g1 = this.contributors;
		while(_g < _g1.length) codeActions = codeActions.concat(_g1[_g++].createCodeActions(params));
		resolve(codeActions);
	}
	onCodeActionResolve(action,token,resolve,reject) {
		let data = action.data;
		let type = data == null ? null : data.type;
		let params = data == null ? null : data.params;
		let diagnostic = data == null ? null : data.diagnostic;
		if(type == null || params == null) {
			resolve(action);
			return;
		}
		switch(type._hx_index) {
		case 0:case 1:
			if(diagnostic == null) {
				resolve(action);
				return;
			}
			break;
		case 2:
			break;
		}
		let _gthis = this;
		switch(type._hx_index) {
		case 0:case 1:case 2:
			let promise;
			if(type == null) {
				promise = null;
			} else {
				switch(type._hx_index) {
				case 0:
					promise = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.createMissingArgumentsAction(this.context,action,params,diagnostic);
					break;
				case 1:
					promise = haxeLanguageServer_features_haxe_codeAction_diagnostics_ChangeFinalToVarAction.createChangeFinalToVarAction(this.context,action,params,diagnostic);
					break;
				case 2:
					promise = haxeLanguageServer_features_haxe_codeAction_diagnostics_AddTypeHintActions.createAddTypeHintAction(this.context,action,params);
					break;
				}
			}
			if(promise == null) {
				let reject1 = reject;
				let data = null;
				let this1 = { code : -32603, message : "failed to resolve missing arguments action"};
				if(data != null) {
					this1.data = data;
				}
				reject1(this1);
				return;
			}
			promise.then(function(action) {
				resolve(action);
				let command = action.command;
				if(command == null || _gthis.hasCommandResolveSupport) {
					return;
				}
				let _this = _gthis.context.languageServerProtocol;
				let tmp = command.arguments;
				let params = { command : command.command, 'arguments' : tmp != null ? tmp : []};
				let message = { jsonrpc : "2.0", method : "haxe/executeClientCommand"};
				if(params != null) {
					message.params = params;
				}
				_this.writeMessage(message,null);
				if(_this.didSendNotification != null) {
					_this.didSendNotification(message);
				}
			}).catch(function(e) {
				reject(e);
			});
			break;
		}
	}
}
haxeLanguageServer_features_haxe_codeAction_CodeActionFeature.__name__ = "haxeLanguageServer.features.haxe.codeAction.CodeActionFeature";
Object.assign(haxeLanguageServer_features_haxe_codeAction_CodeActionFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_codeAction_CodeActionFeature
});
class haxeLanguageServer_features_haxe_codeAction_DiagnosticsCodeActionFeature {
	constructor(context) {
		this.context = context;
	}
	createCodeActions(params) {
		if(!haxeLanguageServer_extensions_DocumentUriExtensions_isFile(params.textDocument.uri)) {
			return [];
		}
		let actions = [];
		let _g = 0;
		let _g1 = params.context.diagnostics;
		while(_g < _g1.length) {
			let diagnostic = _g1[_g];
			++_g;
			let tmp = diagnostic.data;
			let kind = tmp != null ? tmp.kind : null;
			if(kind == null || !(typeof(kind) == "number" && ((kind | 0) === kind))) {
				continue;
			}
			let actions1;
			switch(kind) {
			case 0:
				actions1 = haxeLanguageServer_features_haxe_codeAction_diagnostics_UnusedImportActions.createUnusedImportActions(this.context,params,diagnostic);
				break;
			case 1:
				actions1 = haxeLanguageServer_features_haxe_codeAction_diagnostics_UnresolvedIdentifierActions.createUnresolvedIdentifierActions(this.context,params,diagnostic);
				break;
			case 2:
				actions1 = haxeLanguageServer_features_haxe_codeAction_diagnostics_CompilerErrorActions.createCompilerErrorActions(this.context,params,diagnostic);
				break;
			case 3:
				actions1 = haxeLanguageServer_features_haxe_codeAction_diagnostics_RemovableCodeActions.createRemovableCodeActions(this.context,params,diagnostic);
				break;
			case 4:
				actions1 = haxeLanguageServer_features_haxe_codeAction_diagnostics_ParserErrorActions.createParserErrorActions(this.context,params,diagnostic);
				break;
			case 7:
				actions1 = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingFieldsActions.createMissingFieldsActions(this.context,params,diagnostic);
				break;
			default:
				actions1 = [];
			}
			actions = actions.concat(actions1);
		}
		actions = haxeLanguageServer_features_haxe_codeAction_diagnostics_OrganizeImportActions.createOrganizeImportActions(this.context,params,actions).concat(actions);
		actions = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.createUpdateSyntaxActions(this.context,params,actions).concat(actions);
		actions = haxeLanguageServer_features_haxe_codeAction_diagnostics_AddTypeHintActions.createAddTypeHintActions(this.context,params,actions).concat(actions);
		actions = haxeLanguageServer_features_haxe_codeAction_diagnostics_FixAllAction.createFixAllAction(this.context,params,actions).concat(actions);
		actions = haxeLanguageServer_extensions_ArrayExtensions_filterDuplicates(actions,function(a,b) {
			return a.title == b.title;
		});
		return actions;
	}
}
haxeLanguageServer_features_haxe_codeAction_DiagnosticsCodeActionFeature.__name__ = "haxeLanguageServer.features.haxe.codeAction.DiagnosticsCodeActionFeature";
haxeLanguageServer_features_haxe_codeAction_DiagnosticsCodeActionFeature.__interfaces__ = [haxeLanguageServer_features_haxe_codeAction_CodeActionContributor];
Object.assign(haxeLanguageServer_features_haxe_codeAction_DiagnosticsCodeActionFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_codeAction_DiagnosticsCodeActionFeature
});
class haxeLanguageServer_features_haxe_codeAction_ExtractConstantFeature {
	constructor(context) {
		this.context = context;
	}
	createCodeActions(params) {
		if(params.context.only != null && !params.context.only.includes("refactor.extract")) {
			return [];
		}
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		return this.extractConstant(doc,uri,params.range);
	}
	extractConstant(doc,uri,range) {
		if(doc == null) {
			return [];
		}
		let tokens = doc.get_tokens();
		if(tokens == null) {
			return [];
		}
		try {
			let token = tokens.getTokenAtOffset(doc.offsetAt(range.start));
			if(token == null) {
				return [];
			}
			let _g = token.tok;
			if(_g._hx_index == 2) {
				let _gc = _g.c;
				if(_gc._hx_index == 2) {
					let action = this.makeExtractConstAction(doc,tokens,uri,token,_gc.s);
					if(action == null) {
						return [];
					} else {
						return [action];
					}
				} else {
					return [];
				}
			} else {
				return [];
			}
		} catch( _g ) {
			return [];
		}
	}
	makeExtractConstAction(doc,tokens,uri,token,text) {
		if(text == null || text == "") {
			return null;
		}
		if(this.shouldSkipToken(token)) {
			return null;
		}
		let pos = tokens.getPos(token);
		let endOffset = pos.max;
		let offsetKind = 1;
		let fullText = doc.getText({ start : doc.positionAt(pos.min,offsetKind), end : doc.positionAt(endOffset,offsetKind)});
		if(fullText.startsWith("'") && new EReg("[$]","g").match(text)) {
			return null;
		}
		let _this_r = new RegExp("[^A-Za-z0-9]","g".split("u").join(""));
		let name = text.replace(_this_r,"_");
		let _this_r1 = new RegExp("^[0-9]","g".split("u").join(""));
		name = name.replace(_this_r1,"_");
		let _this_r2 = new RegExp("_+","g".split("u").join(""));
		name = name.replace(_this_r2,"_");
		let _this_r3 = new RegExp("(^_|_$)","g".split("u").join(""));
		name = name.replace(_this_r3,"");
		name = name.toUpperCase();
		if(name.length <= 0) {
			return null;
		}
		let type = this.findParentType(token);
		if(type == null) {
			return null;
		}
		let this1 = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(type)),tokentree_TokenTreeDef.BrOpen));
		if(this1 == null) {
			return null;
		}
		let constInsertPos = doc.positionAt(tokens.getTreePos(this1).min);
		let occurrences = type.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 2) {
				let _gc = _g.c;
				if(_gc._hx_index == 2) {
					if(_gc.s == text) {
						return tokentree_FilterResult.FoundSkipSubtree;
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let edits = [];
		let prefix = doc.getText({ start : { line : constInsertPos.line, character : 0}, end : constInsertPos});
		edits.push(haxeLanguageServer_helper_WorkspaceEditHelper.insertText(constInsertPos,haxeLanguageServer_helper_FormatterHelper.formatText(doc,this.context,"static inline final " + name + " = " + fullText + ";",tokentree_TokenTreeEntryPoint.FieldLevel) + ("\n" + prefix)));
		let _g = 0;
		while(_g < occurrences.length) {
			let pos = tokens.getPos(occurrences[_g++]);
			let endOffset = pos.max;
			let offsetKind = 1;
			edits.push(haxeLanguageServer_helper_WorkspaceEditHelper.replaceText({ start : doc.positionAt(pos.min,offsetKind), end : doc.positionAt(endOffset,offsetKind)},name));
		}
		return { title : "Extract constant", kind : "refactor.extract", edit : { documentChanges : [haxeLanguageServer_helper_WorkspaceEditHelper.textDocumentEdit(uri,edits)]}};
	}
	shouldSkipToken(token) {
		let parent = token.parent;
		if(parent == null || parent.tok == null) {
			return true;
		}
		let _g = parent.tok;
		switch(_g._hx_index) {
		case 6:
			switch(_g.op._hx_index) {
			case 4:
				let this1 = tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.parent(parent)));
				if(this1 != null) {
					let _g = this1.tok;
					if(_g._hx_index == 1) {
						switch(_g.k._hx_index) {
						case 2:case 42:
							let this2 = tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(this1),tokentree_TokenTreeDef.BrOpen))));
							if(this2 == null) {
								return false;
							}
							let _g1 = this2.tok;
							if(_g1._hx_index == 1) {
								switch(_g1.k._hx_index) {
								case 1:case 40:
									return true;
								default:
									return false;
								}
							} else {
								return false;
							}
							break;
						default:
						}
					}
				}
				break;
			case 9:
				return true;
			default:
			}
			break;
		case 18:
			return true;
		case 20:
			let this2 = tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.parent(parent)));
			if(this2 == null) {
				return false;
			}
			switch(this2.tok._hx_index) {
			case 12:
				return tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(this2),tokentree_TokenTreeDef.At) != null;
			case 23:
				return true;
			default:
				return false;
			}
			break;
		default:
		}
		return false;
	}
	findParentType(token) {
		let parent = token.parent;
		while(parent != null && parent.tok != null) {
			let _g = parent.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 1:case 40:
					return parent;
				default:
				}
			}
			parent = parent.parent;
		}
		return null;
	}
}
haxeLanguageServer_features_haxe_codeAction_ExtractConstantFeature.__name__ = "haxeLanguageServer.features.haxe.codeAction.ExtractConstantFeature";
haxeLanguageServer_features_haxe_codeAction_ExtractConstantFeature.__interfaces__ = [haxeLanguageServer_features_haxe_codeAction_CodeActionContributor];
Object.assign(haxeLanguageServer_features_haxe_codeAction_ExtractConstantFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_codeAction_ExtractConstantFeature
});
class haxeLanguageServer_features_haxe_codeAction_ExtractFunctionFeature {
	constructor(context) {
		this.context = context;
	}
	createCodeActions(params) {
		if(params.context.only != null && !params.context.only.includes("refactor.extract")) {
			return [];
		}
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null) {
			return [];
		}
		let tokens = doc1.get_tokens();
		if(tokens == null) {
			return [];
		}
		try {
			let text = doc1.getText(params.range);
			let leftOffset = text.length - StringTools.ltrim(text).length;
			let rightOffset = text.length - StringTools.rtrim(text).length;
			text = StringTools.trim(text);
			let tokenStart = tokens.getTokenAtOffset(doc1.offsetAt(params.range.start) + leftOffset);
			let tokenEnd = tokens.getTokenAtOffset(doc1.offsetAt(params.range.end) - rightOffset);
			if(tokenStart == null || tokenEnd == null) {
				return [];
			}
			if(tokenStart.index == tokenEnd.index) {
				return [];
			}
			if(tokenStart.index + 10 > tokenEnd.index) {
				return [];
			}
			let parentOfStart = this.findParentFunction(tokenStart);
			let parentOfEnd = this.findParentFunction(tokenEnd);
			if(parentOfStart == null || parentOfEnd == null) {
				return [];
			}
			if(parentOfStart.index != parentOfEnd.index) {
				return [];
			}
			let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(parentOfStart);
			let rangeIdents = [];
			let varTokens = [];
			let hasReturn = false;
			parentOfStart.filterCallback(function(token,index) {
				if(lastToken == null || token.index > lastToken.index) {
					return tokentree_FilterResult.SkipSubtree;
				}
				let _g = token.tok;
				switch(_g._hx_index) {
				case 1:
					switch(_g.k._hx_index) {
					case 2:
						if(token.index >= tokenStart.index) {
							return tokentree_FilterResult.GoDeeper;
						}
						if(token.index >= parentOfStart.index && token.index <= lastToken.index) {
							varTokens.push(token);
						}
						break;
					case 10:
						if(token.index >= tokenStart.index && token.index <= tokenEnd.index) {
							hasReturn = true;
						}
						break;
					default:
					}
					break;
				case 2:
					let _gc = _g.c;
					if(_gc._hx_index == 3) {
						let _gs = _gc.s;
						if(token.index >= tokenStart.index && token.index <= tokenEnd.index && !rangeIdents.includes(_gs)) {
							rangeIdents.push(_gs);
						}
					}
					break;
				case 4:
					let _gs = _g.s;
					if(token.index >= tokenStart.index && token.index <= tokenEnd.index && !rangeIdents.includes(_gs)) {
						rangeIdents.push("$" + _gs);
					}
					break;
				default:
				}
				return tokentree_FilterResult.GoDeeper;
			});
			let returnSpec = "";
			if(hasReturn) {
				returnSpec = this.makeReturnSpec(parentOfStart);
			}
			let isStatic = this.isStaticFunction(parentOfStart);
			let indent = this.detectIndent(doc1,parentOfStart);
			let newParams = this.copyParentFunctionParameters(parentOfStart,text,rangeIdents);
			newParams = newParams.concat(this.localVarsToParameter(varTokens,text,rangeIdents));
			let action = this.makeExtractFunctionChanges(doc1,doc1.uri,params,text,isStatic,newParams,returnSpec,indent,doc1.positionAt(lastToken.pos.max + 1,0));
			if(action == null) {
				return [];
			}
			return [action];
		} catch( _g ) {
			return [];
		}
	}
	makeExtractFunctionChanges(doc,uri,params,text,isStatic,newParams,returnSpec,indent,newFuncPos) {
		let result = new Array(newParams.length);
		let _g = 0;
		let _g1 = newParams.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = newParams[i].call;
		}
		let callParams = result.join(", ");
		let result1 = new Array(newParams.length);
		let _g2 = 0;
		let _g3 = newParams.length;
		while(_g2 < _g3) {
			let i = _g2++;
			result1[i] = newParams[i].param;
		}
		let funcParams = result1.join(", ");
		let call = "newFunction" + "(" + callParams + ");\n";
		if(returnSpec.length > 0) {
			call = "return " + call;
		}
		let func = "function " + "newFunction" + "(" + funcParams + ")" + returnSpec + " {\n" + text + "\n}\n";
		if(isStatic) {
			func = "static " + func;
		}
		call = haxeLanguageServer_helper_FormatterHelper.formatText(doc,this.context,call,tokentree_TokenTreeEntryPoint.FieldLevel);
		func = haxeLanguageServer_helper_FormatterHelper.formatText(doc,this.context,func,tokentree_TokenTreeEntryPoint.FieldLevel);
		let _this = func.split("\n");
		let result2 = new Array(_this.length);
		let _g4 = 0;
		let _g5 = _this.length;
		while(_g4 < _g5) {
			let i = _g4++;
			result2[i] = indent + _this[i];
		}
		func = result2.join("\n");
		let edits = [];
		edits.push(haxeLanguageServer_helper_WorkspaceEditHelper.insertText(newFuncPos,func));
		edits.push(haxeLanguageServer_helper_WorkspaceEditHelper.replaceText(params.range,call));
		return { title : "Extract function", kind : "refactor.extract", edit : { documentChanges : [haxeLanguageServer_helper_WorkspaceEditHelper.textDocumentEdit(uri,edits)]}};
	}
	findParentFunction(token) {
		let parent = token.parent;
		while(parent != null && parent.tok != null) {
			let _g = parent.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 0) {
					return parent;
				}
			}
			parent = parent.parent;
		}
		return null;
	}
	makeReturnSpec(functionToken) {
		let this1 = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(functionToken)),tokentree_TokenTreeDef.DblDot);
		let returnHint = this1;
		if(this1 == null) {
			returnHint = tokentree_TokenTreeAccessHelper.firstOf(functionToken,tokentree_TokenTreeDef.DblDot);
		}
		if(returnHint == null || returnHint.children == null) {
			return "";
		}
		return this.varToString(returnHint);
	}
	isStaticFunction(functionToken) {
		if(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(functionToken)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdStatic)) != null) {
			return true;
		}
		return false;
	}
	detectIndent(doc,functionToken) {
		let pos = functionToken.pos;
		let endOffset = pos.max;
		let offsetKind = 0;
		let functionRange = { start : doc.positionAt(pos.min,offsetKind), end : doc.positionAt(endOffset,offsetKind)};
		functionRange.start.character = 0;
		let text = doc.getText(functionRange);
		let whitespace = new EReg("^([ \t]+)","");
		if(!whitespace.match(text)) {
			return "";
		}
		return whitespace.matched(1);
	}
	copyParentFunctionParameters(functionToken,text,rangeIdents) {
		let this1 = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(functionToken)),tokentree_TokenTreeDef.POpen);
		let paramterList = this1;
		if(this1 == null) {
			paramterList = tokentree_TokenTreeAccessHelper.firstOf(functionToken,tokentree_TokenTreeDef.POpen);
		}
		if(paramterList == null || paramterList.children == null) {
			return [];
		}
		let newFuncParameter = [];
		let _g = 0;
		let _g1 = paramterList.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 2:
				let _gc = _g2.c;
				if(_gc._hx_index == 3) {
					this.checkAndAddIdentifier(child,_gc.s,text,rangeIdents,newFuncParameter);
				}
				break;
			case 4:
				let _gs = _g2.s;
				if(!rangeIdents.includes("$" + _gs)) {
					continue;
				}
				newFuncParameter.push({ call : _gs, param : this.varToString(child)});
				break;
			case 21:
				return newFuncParameter;
			case 22:
				let firstChild = child.getFirstChild();
				if(firstChild == null) {
					continue;
				}
				let _g3 = firstChild.tok;
				if(_g3._hx_index == 2) {
					let _gc = _g3.c;
					if(_gc._hx_index == 2) {
						this.checkAndAddIdentifier(child,_gc.s,text,rangeIdents,newFuncParameter);
					}
				}
				break;
			default:
			}
		}
		return newFuncParameter;
	}
	checkAndAddIdentifier(token,identifier,text,rangeIdents,newFuncParameter) {
		if(rangeIdents.includes(identifier)) {
			newFuncParameter.push({ call : identifier, param : this.varToString(token)});
		}
		if(text.includes("$" + identifier)) {
			newFuncParameter.push({ call : identifier, param : this.varToString(token)});
		}
	}
	localVarsToParameter(varTokens,text,rangeIdents) {
		let newFuncParameter = [];
		let _g = 0;
		while(_g < varTokens.length) {
			let varToken = varTokens[_g];
			++_g;
			if(varToken.children == null) {
				continue;
			}
			let _g1 = 0;
			let _g2 = varToken.children;
			while(_g1 < _g2.length) {
				let child = _g2[_g1];
				++_g1;
				let _g = child.tok;
				switch(_g._hx_index) {
				case 2:
					let _gc = _g.c;
					if(_gc._hx_index == 3) {
						this.checkAndAddIdentifier(child,_gc.s,text,rangeIdents,newFuncParameter);
					} else {
						continue;
					}
					break;
				case 4:
					let _gs = _g.s;
					if(!rangeIdents.includes("$" + _gs)) {
						continue;
					}
					newFuncParameter.push({ call : _gs, param : this.varToString(child)});
					break;
				default:
					continue;
				}
			}
		}
		return newFuncParameter;
	}
	varToString(token) {
		let result = token.toString();
		if(token.children == null) {
			return result;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 1:
				result += this.varToString(child);
				break;
			case 2:
				result += this.varToString(child);
				break;
			case 4:
				result += this.varToString(child);
				break;
			case 6:
				if(_g2.op._hx_index == 9) {
					result += this.ltGtToString(child);
				} else {
					return result;
				}
				break;
			case 11:
				result += this.varToString(child);
				break;
			case 12:
				result += this.varToString(child);
				break;
			case 14:
				result += this.varToString(child);
				break;
			default:
				return result;
			}
		}
		return result;
	}
	ltGtToString(token) {
		let result = token.toString();
		if(token.children == null) {
			return result;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			if(_g2._hx_index == 6) {
				if(_g2.op._hx_index == 7) {
					result += child.toString();
					break;
				} else {
					result += this.ltGtToString(child);
				}
			} else {
				result += this.ltGtToString(child);
			}
		}
		return result;
	}
}
haxeLanguageServer_features_haxe_codeAction_ExtractFunctionFeature.__name__ = "haxeLanguageServer.features.haxe.codeAction.ExtractFunctionFeature";
haxeLanguageServer_features_haxe_codeAction_ExtractFunctionFeature.__interfaces__ = [haxeLanguageServer_features_haxe_codeAction_CodeActionContributor];
Object.assign(haxeLanguageServer_features_haxe_codeAction_ExtractFunctionFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_codeAction_ExtractFunctionFeature
});
class haxeLanguageServer_features_haxe_codeAction_ExtractTypeFeature {
	constructor(context) {
		this.context = context;
	}
	createCodeActions(params) {
		if(params.context.only != null && !params.context.only.includes("refactor.extract")) {
			return [];
		}
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null) {
			return [];
		}
		let tokens = doc1.get_tokens();
		if(tokens == null) {
			return [];
		}
		try {
			let path = new haxe_io_Path(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri));
			let types = tokens.tree.filterCallback(function(token,index) {
				let _g = token.tok;
				if(_g._hx_index == 1) {
					switch(_g.k._hx_index) {
					case 1:case 26:case 28:case 32:case 40:
						return tokentree_FilterResult.FoundSkipSubtree;
					default:
					}
				}
				return tokentree_FilterResult.GoDeeper;
			});
			let lastImport = this.getLastImportToken(tokens.tree);
			if(this.isInsideConditional(lastImport)) {
				return [];
			}
			let fileHeader = this.copyImports(doc1,tokens,path.file,lastImport);
			let actions = [];
			let _g = 0;
			while(_g < types.length) {
				let type = types[_g];
				++_g;
				if(this.isInsideConditional(type)) {
					continue;
				}
				let this1 = tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(type));
				if(this1 == null) {
					continue;
				}
				let name = this1.toString();
				if(name == path.file || path.dir == null) {
					continue;
				}
				let newFileName = haxe_io_Path.join([path.dir,name + ".hx"]);
				if(sys_FileSystem.exists(newFileName)) {
					continue;
				}
				let pos = tokens.getTreePos(type);
				let docComment = tokentree_utils_TokenTreeCheckUtils.getDocComment(type);
				if(docComment != null) {
					pos.min = tokens.getPos(docComment).min;
				}
				let endOffset = pos.max;
				let offsetKind = 0;
				let typeRange = { start : doc1.positionAt(pos.min,offsetKind), end : doc1.positionAt(endOffset,offsetKind)};
				if(haxeLanguageServer_extensions_RangeExtensions_intersection(params.range,typeRange) == null) {
					continue;
				}
				let removeOld = haxeLanguageServer_helper_WorkspaceEditHelper.textDocumentEdit(uri,[haxeLanguageServer_helper_WorkspaceEditHelper.removeText(typeRange)]);
				let newUri = haxeLanguageServer_extensions_FsPathExtensions_toUri(newFileName);
				actions.push({ title : "Extract " + name + " to a new file", kind : "refactor.extract", edit : { documentChanges : [removeOld,haxeLanguageServer_helper_WorkspaceEditHelper.createNewFile(newUri,false,true),haxeLanguageServer_helper_WorkspaceEditHelper.textDocumentEdit(newUri,[haxeLanguageServer_helper_WorkspaceEditHelper.insertText(doc1.positionAt(0),fileHeader + doc1.getText(typeRange))])]}});
			}
			return actions;
		} catch( _g ) {
			return [];
		}
	}
	copyImports(doc,tokens,fileName,lastImport) {
		if(lastImport == null) {
			return "";
		}
		let pos = tokens.getTreePos(lastImport);
		pos.min = 0;
		let endOffset = pos.max;
		let offsetKind = 0;
		let range = { start : doc.positionAt(pos.min,offsetKind), end : doc.positionAt(endOffset,offsetKind)};
		range.end.line++;
		range.end.character = 0;
		let fileHeader = doc.getText(range);
		let pack = null;
		tokens.tree.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 34) {
					pack = token;
					return tokentree_FilterResult.SkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.SkipSubtree;
			}
		});
		if(pack == null) {
			return fileHeader + "\n";
		}
		let pos1 = tokens.getTreePos(pack);
		let endOffset1 = pos1.max;
		let offsetKind1 = 0;
		let packText = doc.getText({ start : doc.positionAt(pos1.min,offsetKind1), end : doc.positionAt(endOffset1,offsetKind1)});
		packText = StringTools.replace(packText,"package ","");
		packText = StringTools.trim(StringTools.replace(packText,";",""));
		if(packText.length <= 0) {
			packText = "" + fileName;
		} else {
			packText += "." + fileName;
		}
		return fileHeader + ("import " + packText + ";\n\n");
	}
	getLastImportToken(tree) {
		return tree.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 13:case 36:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
				}
			}
			return tokentree_FilterResult.GoDeeper;
		}).pop();
	}
	isInsideConditional(token) {
		if(token == null) {
			return false;
		}
		let parent = token.parent;
		while(parent != null && parent.tok != null) {
			if(parent.tok._hx_index == 3) {
				return true;
			}
			parent = parent.parent;
		}
		return false;
	}
}
haxeLanguageServer_features_haxe_codeAction_ExtractTypeFeature.__name__ = "haxeLanguageServer.features.haxe.codeAction.ExtractTypeFeature";
haxeLanguageServer_features_haxe_codeAction_ExtractTypeFeature.__interfaces__ = [haxeLanguageServer_features_haxe_codeAction_CodeActionContributor];
Object.assign(haxeLanguageServer_features_haxe_codeAction_ExtractTypeFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_codeAction_ExtractTypeFeature
});
class haxeLanguageServer_features_haxe_codeAction_ExtractVarFeature {
	constructor(context) {
		this.context = context;
	}
	createCodeActions(params) {
		if(params.context.only != null && !params.context.only.includes("refactor.extract")) {
			return [];
		}
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let tmp = doc;
		if(tmp == null) {
			return [];
		}
		return this.extractVar(tmp,uri,params.range);
	}
	extractVar(doc,uri,range) {
		let tmp = doc.get_tokens();
		if(tmp == null) {
			return [];
		}
		let tmp1 = tmp.getTokenAtOffset(doc.offsetAt(range.start));
		if(tmp1 == null) {
			return [];
		}
		switch(tmp1.tok._hx_index) {
		case 2:
			let token = this.preDotToken(tmp1);
			if(haxeLanguageServer_features_haxe_codeAction_TokenTreeUtils.isInFunctionScope(token)) {
				return [];
			}
			if(this.isTypeHint(token)) {
				return [];
			}
			if(haxeLanguageServer_features_haxe_codeAction_TokenTreeUtils.isAnonStructureField(token)) {
				return [];
			}
			if(this.isFieldAssign(token)) {
				return [];
			}
			let action = this.makeExtractVarAction(doc,tmp,uri,token,range);
			if(action == null) {
				return [];
			} else {
				return [action];
			}
			break;
		case 16:case 17:
			let action1 = this.makeExtractVarAction(doc,tmp,uri,tmp1,range);
			if(action1 == null) {
				return [];
			} else {
				return [action1];
			}
			break;
		case 18:case 19:
			if(haxeLanguageServer_features_haxe_codeAction_TokenTreeUtils.isAnonStructure(tmp1)) {
				let action = this.makeExtractVarAction(doc,tmp,uri,tmp1,range);
				if(action == null) {
					return [];
				} else {
					return [action];
				}
			} else {
				return [];
			}
			break;
		default:
			return [];
		}
	}
	isFieldAssign(token) {
		let _g = token.tok;
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 4:
				return true;
			case 20:
				return true;
			default:
				let tmp = token.getFirstChild();
				if(tmp == null) {
					return false;
				}
				return this.isFieldAssign(tmp);
			}
		} else {
			let tmp = token.getFirstChild();
			if(tmp == null) {
				return false;
			}
			return this.isFieldAssign(tmp);
		}
	}
	isTypeHint(token) {
		let parent = token.parent;
		while(parent != null) {
			if(parent.tok._hx_index == 12) {
				let _v_ = parent.parent;
				let _v_1 = _v_ == null ? null : _v_.parent;
				return (_v_1 == null ? null : _v_1.tok) != tokentree_TokenTreeDef.BrOpen;
			}
			token = parent;
			parent = parent.parent;
		}
		return false;
	}
	makeExtractVarAction(doc,tokens,uri,token,range) {
		let tmp = tokens.getTokenAtOffset(doc.offsetAt(range.end));
		let text;
		let _g = (tmp != null ? tmp : token).tok;
		switch(_g._hx_index) {
		case 2:
			let _gc = _g.c;
			switch(_gc._hx_index) {
			case 0:
				let _gs = _gc.s;
				text = _gs != null ? _gs : "value";
				break;
			case 1:
				let _gs1 = _gc.s;
				text = _gs1 != null ? _gs1 : "value";
				break;
			case 2:
				text = _gc.s;
				break;
			case 3:
				let _gs2 = _gc.s;
				text = _gs2 != null ? _gs2 : "value";
				break;
			default:
				text = "value";
			}
			break;
		case 16:case 17:
			text = "arr";
			break;
		case 18:case 19:
			text = "obj";
			break;
		default:
			text = "value";
		}
		let _this_r = new RegExp("[^A-Za-z0-9]","g".split("u").join(""));
		let name = text.replace(_this_r,"_");
		let _this_r1 = new RegExp("^[0-9]","g".split("u").join(""));
		name = name.replace(_this_r1,"_");
		let _this_r2 = new RegExp("_+","g".split("u").join(""));
		name = name.replace(_this_r2,"_");
		let _this_r3 = new RegExp("(^_|_$)","g".split("u").join(""));
		name = name.replace(_this_r3,"");
		if(name.length > 1 && name.charAt(1).toLowerCase() == name.charAt(1)) {
			name = name.charAt(0).toLowerCase() + HxOverrides.substr(name,1,null);
		} else {
			name = name.toLowerCase();
		}
		if(name.length <= 0) {
			return null;
		}
		let parent = this.findParentInLocalScope(token);
		if(parent == null) {
			return null;
		}
		let extractionRange = haxeLanguageServer_extensions_RangeExtensions_isEmpty(range) ? this.getExtractionRange(doc,token) : range;
		if(extractionRange == null) {
			return null;
		}
		let fullText = doc.getText(extractionRange);
		let varInsertPos = doc.positionAt(tokens.getTreePos(parent).min);
		let isSnippet = this.context.hasClientCommandSupport("haxe.codeAction.insertSnippet");
		if(isSnippet) {
			name = "$" + "{1:" + name + "}";
		}
		let prefix = doc.getText({ start : { line : varInsertPos.line, character : 0}, end : varInsertPos});
		let exprText = haxeLanguageServer_helper_FormatterHelper.formatText(doc,this.context,"" + fullText + ";",tokentree_TokenTreeEntryPoint.ExpressionLevel);
		let i = 0;
		let _g1 = [];
		let x = $getIterator(exprText.split("\n"));
		while(x.hasNext()) {
			let x1 = x.next();
			_g1.push(i++ == 0 ? x1 : "" + prefix + x1);
		}
		exprText = _g1.join("\n");
		let newConstText = "final " + name + " = " + exprText;
		let fullText1 = newConstText;
		fullText1 = newConstText + doc.getText({ start : doc.positionAt(doc.offsetAt(varInsertPos)), end : doc.positionAt(doc.offsetAt(extractionRange.start))});
		fullText1 += name;
		if(isSnippet) {
			fullText1 += "$0";
		}
		let editRange = haxeLanguageServer_extensions_RangeExtensions_union({ start : varInsertPos, end : varInsertPos},extractionRange);
		let action = { title : "Extract to var in enclosing scope", kind : "refactor.extract"};
		if(isSnippet) {
			action.command = { title : "Insert Snippet", command : "haxe.codeAction.insertSnippet", 'arguments' : [uri,editRange,fullText1]};
		} else {
			let changes = { };
			if(doc != null) {
				changes[doc.uri] = [haxeLanguageServer_helper_WorkspaceEditHelper.replaceText(editRange,fullText1)];
			}
			action.edit = { changes : changes};
		}
		return action;
	}
	findParentInLocalScope(token) {
		let parent = token.parent;
		while(parent != null) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 7:case 15:
					return null;
				default:
				}
				break;
			case 18:
				if(!haxeLanguageServer_features_haxe_codeAction_TokenTreeUtils.isAnonStructure(parent)) {
					return token;
				}
				break;
			default:
			}
			token = parent;
			parent = parent.parent;
		}
		return null;
	}
	getExtractionRange(doc,token) {
		let tokens = this.findExtractionRangeTokens(token);
		let fullRange = null;
		let _g = 0;
		while(_g < tokens.length) {
			let token = tokens[_g];
			++_g;
			if(token == null) {
				continue;
			}
			let endOffset = token.pos.max;
			let offsetKind = 0;
			let range = { start : doc.positionAt(token.pos.min,offsetKind), end : doc.positionAt(endOffset,offsetKind)};
			if(fullRange == null) {
				fullRange = range;
				continue;
			}
			fullRange = haxeLanguageServer_extensions_RangeExtensions_union(fullRange,range);
		}
		return fullRange;
	}
	preDotToken(token) {
		let tmp = token.parent;
		if(tmp == null) {
			return token;
		}
		let _g = tmp.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 22) {
				return tmp;
			}
			break;
		case 11:case 13:
			let tmp1 = tmp.parent;
			if(tmp1 == null) {
				return token;
			}
			if(!token.isCIdent()) {
				return token;
			}
			return this.preDotToken(tmp1);
		default:
		}
		return token;
	}
	findExtractionRangeTokens(token) {
		if(token.tok == tokentree_TokenTreeDef.BrClose || token.tok == tokentree_TokenTreeDef.BkClose) {
			let tmp = token.parent;
			if(tmp != null) {
				token = tmp;
			} else {
				return [];
			}
		}
		switch(token.tok._hx_index) {
		case 16:case 18:
			return [token,this.getLastNonCommaToken(token)];
		default:
		}
		let parent = token.parent;
		while(parent != null) {
			switch(parent.tok._hx_index) {
			case 1:
				let _g = parent.tok;
				if(_g._hx_index == 1) {
					switch(_g.k._hx_index) {
					case 2:case 22:case 42:
						return [];
					default:
						let first = token.getFirstChild();
						return [token,this.getLastNonCommaToken((first == null ? null : first.tok) == tokentree_TokenTreeDef.Dot || (first == null ? null : first.tok) == tokentree_TokenTreeDef.QuestionDot ? first : token)];
					}
				} else {
					let first = token.getFirstChild();
					return [token,this.getLastNonCommaToken((first == null ? null : first.tok) == tokentree_TokenTreeDef.Dot || (first == null ? null : first.tok) == tokentree_TokenTreeDef.QuestionDot ? first : token)];
				}
				break;
			case 6:
				let _g1 = parent.tok;
				if(_g1._hx_index == 1) {
					switch(_g1.k._hx_index) {
					case 2:case 22:case 42:
						return [];
					default:
						let first1 = token.getFirstChild();
						return [token,this.getLastNonCommaToken((first1 == null ? null : first1.tok) == tokentree_TokenTreeDef.Dot || (first1 == null ? null : first1.tok) == tokentree_TokenTreeDef.QuestionDot ? first1 : token)];
					}
				} else {
					let first = token.getFirstChild();
					return [token,this.getLastNonCommaToken((first == null ? null : first.tok) == tokentree_TokenTreeDef.Dot || (first == null ? null : first.tok) == tokentree_TokenTreeDef.QuestionDot ? first : token)];
				}
				break;
			case 12:
				let _g2 = parent.tok;
				if(_g2._hx_index == 1) {
					switch(_g2.k._hx_index) {
					case 2:case 22:case 42:
						return [];
					default:
						let first2 = token.getFirstChild();
						return [token,this.getLastNonCommaToken((first2 == null ? null : first2.tok) == tokentree_TokenTreeDef.Dot || (first2 == null ? null : first2.tok) == tokentree_TokenTreeDef.QuestionDot ? first2 : token)];
					}
				} else {
					let first = token.getFirstChild();
					return [token,this.getLastNonCommaToken((first == null ? null : first.tok) == tokentree_TokenTreeDef.Dot || (first == null ? null : first.tok) == tokentree_TokenTreeDef.QuestionDot ? first : token)];
				}
				break;
			case 11:case 13:
				let _v_ = parent.parent;
				if((_v_ == null ? null : _v_.isCIdent()) == true) {
					let tmp = parent.parent;
					if(tmp != null) {
						parent = tmp;
					} else {
						return [];
					}
				}
				break;
			case 16:case 20:
				switch(parent.tok._hx_index) {
				case 16:
					break;
				case 20:
					break;
				default:
					return [];
				}
				let tokens = [token];
				let firstChild = token.getFirstChild();
				if((firstChild == null ? null : firstChild.tok) == tokentree_TokenTreeDef.Arrow || tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.Arrow) != null) {
					return [];
				}
				if(firstChild == null) {
					return tokens;
				}
				let _g3 = token.tok;
				let last;
				let tmp = this.getLastToken(firstChild.tok == tokentree_TokenTreeDef.Dot || firstChild.tok == tokentree_TokenTreeDef.QuestionDot || firstChild.tok == tokentree_TokenTreeDef.POpen || _g3._hx_index == 1 && _g3.k._hx_index == 22 ? firstChild : token);
				if(tmp != null) {
					last = tmp;
				} else {
					return tokens;
				}
				let tmp1;
				switch(tmp.tok._hx_index) {
				case 6:
					tmp1 = true;
					break;
				case 15:
					tmp1 = true;
					break;
				default:
					tmp1 = false;
				}
				if(tmp1) {
					let tmp1 = tmp.parent;
					if(tmp1 != null) {
						last = tmp1;
					} else {
						return tokens;
					}
				}
				tokens.push(last);
				return tokens;
			default:
			}
			token = parent;
			parent = parent.parent;
		}
		return [];
	}
	getLastToken(token) {
		if(token == null) {
			return null;
		}
		return tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
	}
	getLastNonCommaToken(token) {
		let last = this.getLastToken(token);
		if(last == null) {
			return last;
		}
		if(last.tok == tokentree_TokenTreeDef.Comma || last.tok == tokentree_TokenTreeDef.Semicolon) {
			let tmp = last.previousSibling;
			if(tmp == null) {
				return last.parent;
			}
			return this.getLastNonCommaToken(tmp);
		}
		return last;
	}
}
haxeLanguageServer_features_haxe_codeAction_ExtractVarFeature.__name__ = "haxeLanguageServer.features.haxe.codeAction.ExtractVarFeature";
haxeLanguageServer_features_haxe_codeAction_ExtractVarFeature.__interfaces__ = [haxeLanguageServer_features_haxe_codeAction_CodeActionContributor];
Object.assign(haxeLanguageServer_features_haxe_codeAction_ExtractVarFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_codeAction_ExtractVarFeature
});
class haxeLanguageServer_features_haxe_codeAction_OrganizeImportsFeature {
	static organizeImports(doc,context,unusedRanges) {
		let tokens = doc.get_tokens();
		if(tokens == null) {
			return [];
		}
		try {
			let packageName = null;
			let imports = tokens.tree.filterCallback(function(token,index) {
				let _g = token.tok;
				switch(_g._hx_index) {
				case 1:
					switch(_g.k._hx_index) {
					case 34:
						let child = token.getFirstChild();
						if(child == null) {
							return tokentree_FilterResult.SkipSubtree;
						}
						let _g1 = child.tok;
						switch(_g1._hx_index) {
						case 1:
							packageName = "" + Std.string(child);
							break;
						case 2:
							let _gc = _g1.c;
							if(_gc._hx_index == 3) {
								packageName = _gc.s;
							}
							break;
						default:
						}
						return tokentree_FilterResult.SkipSubtree;
					case 13:case 36:
						return tokentree_FilterResult.FoundSkipSubtree;
					default:
						return tokentree_FilterResult.SkipSubtree;
					}
					break;
				case 3:
					return tokentree_FilterResult.GoDeeper;
				case 8:
					let _gs = _g.s;
					let s = _gs;
					s = StringTools.ltrim(_gs);
					if(s.startsWith("import ") || s.startsWith("using ")) {
						return tokentree_FilterResult.FoundSkipSubtree;
					}
					return tokentree_FilterResult.SkipSubtree;
				default:
					return tokentree_FilterResult.SkipSubtree;
				}
			});
			let importGroups = new haxe_ds_IntMap();
			let _g = 0;
			while(_g < imports.length) {
				let i = imports[_g];
				++_g;
				let id = -1;
				if(i.parent != null) {
					id = i.parent.index;
				}
				let group = importGroups.h[id];
				if(group == null) {
					group = { id : id, startOffset : tokens.getPos(i).min, imports : [], usings : [], lastIndex : i.index};
					importGroups.h[id] = group;
				}
				let range = doc.lineRangeAt(tokens.getTreePos(i).min);
				let isUnused = false;
				let _g1 = 0;
				while(_g1 < unusedRanges.length) {
					let r = unusedRanges[_g1];
					++_g1;
					if(haxeLanguageServer_extensions_RangeExtensions_containsPos(r,range.start) && haxeLanguageServer_extensions_RangeExtensions_containsPos(r,range.end)) {
						isUnused = true;
						break;
					}
				}
				if(isUnused) {
					continue;
				}
				let type = haxeLanguageServer_features_haxe_codeAction_OrganizeImportsFeature.determineImportType(i,packageName);
				let text = doc.getText(range);
				let _g2 = i.tok;
				switch(_g2._hx_index) {
				case 1:
					switch(_g2.k._hx_index) {
					case 13:
						group.imports.push({ token : i, text : text, sortText : text, type : type, range : range});
						group.lastIndex = i.index;
						break;
					case 36:
						group.usings.push({ token : i, text : text, sortText : text, type : type, range : range});
						group.lastIndex = i.index;
						break;
					default:
					}
					break;
				case 8:
					let _gs = _g2.s;
					let s = _gs;
					s = StringTools.ltrim(_gs);
					if(s.startsWith("import ")) {
						group.imports.push({ token : i, text : text, sortText : s, type : type, range : range});
						group.lastIndex = i.index;
					}
					if(s.startsWith("using ")) {
						group.usings.push({ token : i, text : text, sortText : s, type : type, range : range});
						group.lastIndex = i.index;
					}
					break;
				default:
				}
			}
			return haxeLanguageServer_features_haxe_codeAction_OrganizeImportsFeature.organizeImportGroups(doc,context,importGroups);
		} catch( _g ) {
			return [];
		}
	}
	static determineImportType(token,packageName) {
		let topLevelPack;
		let _g = token.tok;
		if(_g._hx_index == 8) {
			let _gs = _g.s;
			let s = _gs;
			s = StringTools.ltrim(_gs);
			if(s.startsWith("import ")) {
				s = HxOverrides.substr(s,7,null);
			}
			if(s.startsWith("using ")) {
				s = HxOverrides.substr(s,6,null);
			}
			let index = s.indexOf(".");
			if(index < 0) {
				index = s.indexOf(";");
				topLevelPack = s;
				if(index > 0) {
					topLevelPack = s.substring(0,index);
				}
			} else {
				topLevelPack = s.substring(0,index);
			}
		} else {
			let child = token.getFirstChild();
			if(child == null) {
				return 2;
			}
			let _g = child.tok;
			switch(_g._hx_index) {
			case 1:
				topLevelPack = "" + Std.string(child);
				break;
			case 2:
				let _gc = _g.c;
				if(_gc._hx_index == 3) {
					topLevelPack = _gc.s;
				} else {
					return 2;
				}
				break;
			default:
				return 2;
			}
		}
		if(haxeLanguageServer_features_haxe_codeAction_OrganizeImportsFeature.stdLibPackages.includes(topLevelPack)) {
			return 0;
		}
		if(packageName == null) {
			return 2;
		}
		if(topLevelPack == packageName) {
			return 2;
		}
		return 1;
	}
	static organizeImportGroups(doc,context,importGroups) {
		let edits = [];
		let group = importGroups.iterator();
		while(group.hasNext()) edits = edits.concat(haxeLanguageServer_features_haxe_codeAction_OrganizeImportsFeature.organizeImportGroup(doc,context,group.next()));
		return edits;
	}
	static organizeImportGroup(doc,context,importGroup) {
		let sortFunc = haxeLanguageServer_features_haxe_codeAction_OrganizeImportsFeature.determineSortFunction(context);
		if(sortFunc == null) {
			return [];
		}
		haxe_ds_ArraySort.sort(importGroup.imports,sortFunc);
		let _this = importGroup.imports;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _this[i].text;
		}
		let newImports = result.join("\n");
		haxe_ds_ArraySort.sort(importGroup.usings,sortFunc);
		let _this1 = importGroup.usings;
		let result1 = new Array(_this1.length);
		let _g2 = 0;
		let _g3 = _this1.length;
		while(_g2 < _g3) {
			let i = _g2++;
			result1[i] = _this1[i].text;
		}
		let newUsings = result1.join("\n");
		let newText = haxeLanguageServer_helper_FormatterHelper.formatText(doc,context,newImports + (importGroup.imports.length > 0 ? "\n" : "") + newUsings + (importGroup.usings.length > 0 ? "\n" : ""),tokentree_TokenTreeEntryPoint.TypeLevel);
		if(HxOverrides.cca(newText,newText.length - 1) != 10) {
			newText += "\n";
		}
		let edits = [];
		let _g4 = 0;
		let _g5 = importGroup.imports;
		while(_g4 < _g5.length) {
			let i = _g5[_g4];
			++_g4;
			edits.push(haxeLanguageServer_features_haxe_codeAction_OrganizeImportsFeature.makeImportEdit(doc,i.range,i.token.index == importGroup.lastIndex));
		}
		let _g6 = 0;
		let _g7 = importGroup.usings;
		while(_g6 < _g7.length) {
			let i = _g7[_g6];
			++_g6;
			edits.push(haxeLanguageServer_features_haxe_codeAction_OrganizeImportsFeature.makeImportEdit(doc,i.range,i.token.index == importGroup.lastIndex));
		}
		edits.push(haxeLanguageServer_helper_WorkspaceEditHelper.insertText(doc.positionAt(importGroup.startOffset),newText));
		return edits;
	}
	static determineSortFunction(context) {
		switch(context.config.user.importsSortOrder) {
		case "all-alphabetical":
			return haxeLanguageServer_features_haxe_codeAction_OrganizeImportsFeature.sortImportsAllAlpha;
		case "non-project -> project":
			return haxeLanguageServer_features_haxe_codeAction_OrganizeImportsFeature.sortImportsNonProjectThenProject;
		case "stdlib -> libs -> project":
			return haxeLanguageServer_features_haxe_codeAction_OrganizeImportsFeature.sortImportsStdlibThenLibsThenProject;
		}
	}
	static makeImportEdit(doc,range,isLast) {
		range.end.line++;
		range.end.character = 0;
		if(StringTools.trim(doc.getText({ start : range.end, end : { line : range.end.line + 1, character : 0}})).length <= 0 && !isLast) {
			range.end.line++;
		}
		return haxeLanguageServer_helper_WorkspaceEditHelper.removeText(range);
	}
	static sortImportsAllAlpha(a,b) {
		if(a.sortText < b.sortText) {
			return -1;
		}
		if(a.sortText > b.sortText) {
			return 1;
		}
		return 0;
	}
	static sortImportsStdlibThenLibsThenProject(a,b) {
		if(a.type < b.type) {
			return -1;
		}
		if(a.type > b.type) {
			return 1;
		}
		if(a.sortText < b.sortText) {
			return -1;
		}
		if(a.sortText > b.sortText) {
			return 1;
		}
		return 0;
	}
	static sortImportsNonProjectThenProject(a,b) {
		if(a.type == 0) {
			a.type = 1;
		}
		if(b.type == 0) {
			b.type = 1;
		}
		return haxeLanguageServer_features_haxe_codeAction_OrganizeImportsFeature.sortImportsStdlibThenLibsThenProject(a,b);
	}
}
haxeLanguageServer_features_haxe_codeAction_OrganizeImportsFeature.__name__ = "haxeLanguageServer.features.haxe.codeAction.OrganizeImportsFeature";
class haxeLanguageServer_features_haxe_codeAction_TokenTreeUtils {
	static isInFunctionScope(token) {
		let tmp = token.parent;
		if(tmp == null) {
			return false;
		}
		if(tmp.tok != tokentree_TokenTreeDef.BrOpen) {
			return false;
		}
		let tmp1 = tmp.parent;
		if(tmp1 == null) {
			return false;
		}
		let _g = tmp1.tok;
		let tmp2;
		switch(_g._hx_index) {
		case 1:
			tmp2 = _g.k._hx_index == 0;
			break;
		case 14:
			tmp2 = true;
			break;
		default:
			tmp2 = false;
		}
		if(tmp2) {
			return true;
		}
		let tmp3 = tmp1.parent;
		if(tmp3 == null) {
			return false;
		}
		let _g1 = tmp3.tok;
		if(_g1._hx_index == 1) {
			if(_g1.k._hx_index == 0) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	static isFunctionArg(token) {
		let tmp = token.parent;
		if(tmp == null) {
			return false;
		}
		if(tmp.tok != tokentree_TokenTreeDef.POpen) {
			return false;
		}
		let tmp1 = tmp.parent;
		if(tmp1 == null) {
			return false;
		}
		let _g = tmp1.tok;
		let tmp2;
		switch(_g._hx_index) {
		case 1:
			tmp2 = _g.k._hx_index == 0;
			break;
		case 14:
			tmp2 = true;
			break;
		default:
			tmp2 = false;
		}
		if(tmp2) {
			return true;
		}
		let tmp3 = tmp1.parent;
		if(tmp3 == null) {
			return false;
		}
		let _g1 = tmp3.tok;
		if(_g1._hx_index == 1) {
			if(_g1.k._hx_index == 0) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	static isInLoopScope(token) {
		let kwd;
		let tmp = token.parent;
		if(tmp != null) {
			kwd = tmp;
		} else {
			return false;
		}
		if(tmp.tok == tokentree_TokenTreeDef.BrOpen) {
			let tmp1 = tmp.parent;
			if(tmp1 != null) {
				kwd = tmp1;
			} else {
				return false;
			}
		}
		let _g = kwd.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 5:case 6:case 7:
				return true;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	static isAnonStructure(brToken) {
		if(brToken.tok == tokentree_TokenTreeDef.BrClose) {
			let tmp = brToken.parent;
			if(tmp != null) {
				brToken = tmp;
			} else {
				return false;
			}
		}
		let first;
		let _v_ = brToken;
		let tmp = _v_ == null ? null : _v_.getFirstChild();
		if(tmp != null) {
			first = tmp;
		} else {
			return false;
		}
		let tmp1 = first.getFirstChild();
		if(tmp1 == null) {
			return false;
		}
		let tmp2;
		if(tmp1.tok._hx_index == 12) {
			let _v_ = tmp1.nextSibling;
			let _g = _v_ == null ? null : _v_.tok;
			tmp2 = !(_g == null ? false : _g._hx_index == 10);
		} else {
			tmp2 = false;
		}
		if(tmp2) {
			return true;
		}
		return false;
	}
	static isAnonStructureField(token) {
		let tmp = token.parent;
		if(tmp == null) {
			return false;
		}
		if(!haxeLanguageServer_features_haxe_codeAction_TokenTreeUtils.isAnonStructure(tmp)) {
			return false;
		}
		let tmp1 = token.getFirstChild();
		if(tmp1 == null) {
			return false;
		}
		if(tmp1.tok._hx_index == 12) {
			return true;
		} else {
			return false;
		}
	}
}
haxeLanguageServer_features_haxe_codeAction_TokenTreeUtils.__name__ = "haxeLanguageServer.features.haxe.codeAction.TokenTreeUtils";
class haxeLanguageServer_features_haxe_codeAction_diagnostics_AddTypeHintActions {
	static createAddTypeHintActions(context,params,existingActions) {
		let uri = params.textDocument.uri;
		let value = context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let tmp = doc;
		if(tmp == null) {
			return [];
		}
		let actions = [];
		let _v_ = tmp.get_tokens();
		let token = _v_ == null ? null : _v_.getTokenAtOffset(tmp.offsetAt(params.range.end));
		if(token == null) {
			return [];
		}
		if(token.isCIdent()) {
			let isFunName = haxeLanguageServer_features_haxe_codeAction_diagnostics_AddTypeHintActions.isFunctionName(token);
			if(haxeLanguageServer_features_haxe_codeAction_diagnostics_AddTypeHintActions.isVarDecl(token) || haxeLanguageServer_features_haxe_codeAction_TokenTreeUtils.isFunctionArg(token)) {
				let maybeColon = token.getFirstChild();
				if(maybeColon != null && maybeColon.matches(tokentree_TokenTreeDef.DblDot)) {
					return actions;
				}
			} else if(isFunName) {
				if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.DblDot) != null) {
					return actions;
				}
			} else {
				return actions;
			}
		} else {
			if(!haxeLanguageServer_features_haxe_codeAction_TokenTreeUtils.isInFunctionScope(token)) {
				return actions;
			}
			let _g = token.tok;
			if(!(_g._hx_index == 1 && _g.k._hx_index == 10)) {
				return actions;
			}
			let nameToken;
			let _v_ = token.parent;
			let tmp1 = _v_ == null ? null : _v_.parent;
			if(tmp1 != null) {
				nameToken = tmp1;
			} else {
				return actions;
			}
			if(tokentree_TokenTreeAccessHelper.firstOf(nameToken,tokentree_TokenTreeDef.DblDot) != null) {
				return actions;
			}
			let pos = nameToken.pos;
			let endOffset = pos.max;
			let offsetKind = 0;
			params.range = { start : tmp.positionAt(pos.min,offsetKind), end : tmp.positionAt(endOffset,offsetKind)};
		}
		actions.push({ title : "Add type hint", data : { type : haxeLanguageServer_features_haxe_codeAction_CodeActionResolveType.AddTypeHint, params : params}, kind : "refactor.rewrite", isPreferred : false});
		return actions;
	}
	static createAddTypeHintAction(context,action,params) {
		if(params.context.only != null && !params.context.only.includes("refactor.rewrite")) {
			return null;
		}
		let uri = params.textDocument.uri;
		let value = context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let document = doc;
		if(document == null) {
			return null;
		}
		let tokenSource = new jsonrpc__$CancellationToken_CancellationTokenImpl();
		let _v_ = document.get_tokens();
		let identToken = _v_ == null ? null : _v_.getTokenAtOffset(document.offsetAt(params.range.end));
		if(identToken == null) {
			return null;
		}
		let referencesPromise = new Promise(function(resolve,reject) {
			context.findReferences.onFindReferences({ textDocument : params.textDocument, position : document.positionAt(identToken.pos.min,0)},tokenSource,function(array) {
				resolve(array != null ? array : []);
			},function(error) {
				reject(error);
			});
		});
		let gotoPromise = new Promise(function(resolve,reject) {
			context.gotoDefinition.onGotoDefinition({ textDocument : params.textDocument, position : document.positionAt(identToken.pos.min,0)},tokenSource,function(array) {
				resolve(array);
			},function(error) {
				reject(error);
			});
		});
		let makeHoverPromise = function(loc) {
			let this1 = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(loc.uri);
			let uri = loc.uri;
			let value = context.documents.documents.h[uri];
			let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let tmp = doc;
			if(tmp == null) {
				return Promise.resolve();
			}
			let hoverPos = tmp.offsetAt(loc.range.end) - 1;
			return haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.makeHoverRequest(context,this1,hoverPos,tokenSource);
		};
		let gotoAndHoverPromise = Promise.all([gotoPromise,referencesPromise]).then(function(results) {
			let tmp = results[0][0];
			if(tmp == null) {
				return null;
			}
			let locations = results[1];
			let location;
			let tmp1 = locations[locations.length - 1];
			let tmp2 = tmp1 != null ? tmp1 : { uri : tmp.targetUri, range : tmp.targetSelectionRange};
			if(tmp2 != null) {
				location = tmp2;
			} else {
				return null;
			}
			let uri = location.uri;
			let value = context.documents.documents.h[uri];
			let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let tmp3 = doc;
			if(tmp3 == null) {
				return null;
			}
			let _v_ = tmp3.get_tokens();
			let locToken = _v_ == null ? null : _v_.getTokenAtOffset(tmp3.offsetAt(location.range.end));
			if(locToken == null) {
				return null;
			}
			let child = locToken.getFirstChild();
			if(child != null) {
				let gotoAndHoverPromise;
				if(!haxeLanguageServer_features_haxe_codeAction_diagnostics_AddTypeHintActions.isVarDecl(locToken)) {
					let _g = child.tok;
					if(_g._hx_index == 6) {
						switch(_g.op._hx_index) {
						case 4:
							gotoAndHoverPromise = true;
							break;
						case 20:
							gotoAndHoverPromise = true;
							break;
						default:
							gotoAndHoverPromise = false;
						}
					} else {
						gotoAndHoverPromise = false;
					}
				} else {
					gotoAndHoverPromise = false;
				}
				if(gotoAndHoverPromise) {
					let pos = child.pos;
					let endOffset = pos.max;
					let offsetKind = 0;
					location.range = { start : tmp3.positionAt(pos.min,offsetKind), end : tmp3.positionAt(endOffset,offsetKind)};
				}
			}
			let hoverPromise = makeHoverPromise(location);
			return Promise.all([Promise.resolve(gotoPromise),hoverPromise]);
		});
		let actionPromise = gotoAndHoverPromise.then(function(results) {
			let hover = results[1];
			let tmp = results[0][0];
			if(tmp == null) {
				return action;
			}
			let uri = tmp.targetUri;
			let value = context.documents.documents.h[uri];
			let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let tmp1 = doc;
			if(tmp1 == null) {
				return action;
			}
			let _v_ = tmp1.get_tokens();
			let defToken = _v_ == null ? null : _v_.getTokenAtOffset(tmp1.offsetAt(tmp.targetSelectionRange.end));
			if(defToken == null || !defToken.isCIdent()) {
				return action;
			}
			let maybeColon = defToken.getFirstChild();
			if(maybeColon != null && maybeColon.matches(tokentree_TokenTreeDef.DblDot)) {
				return action;
			}
			let isFunName = haxeLanguageServer_features_haxe_codeAction_diagnostics_AddTypeHintActions.isFunctionName(defToken);
			let typeHint;
			let tmp2 = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.printTypeHint(hover.item);
			if(tmp2 != null) {
				typeHint = tmp2;
			} else {
				return action;
			}
			if(isFunName) {
				typeHint = haxeLanguageServer_features_haxe_codeAction_diagnostics_AddTypeHintActions.extractReturnType(tmp2);
			}
			if(typeHint == "?") {
				return action;
			}
			let range;
			if(isFunName) {
				let this1 = tokentree_TokenTreeAccessHelper.firstOf(defToken,tokentree_TokenTreeDef.POpen);
				if(this1 == null) {
					return action;
				}
				let pos = this1.getPos();
				let endOffset = pos.max;
				let offsetKind = 0;
				range = { start : document.positionAt(pos.max,offsetKind), end : document.positionAt(endOffset,offsetKind)};
			} else {
				let endOffset = defToken.pos.max;
				let offsetKind = 0;
				range = { start : document.positionAt(defToken.pos.max,offsetKind), end : document.positionAt(endOffset,offsetKind)};
			}
			let changes = { };
			if(tmp1 != null) {
				changes[tmp1.uri] = [{ range : range, newText : ":" + typeHint}];
			}
			action.edit = { changes : changes};
			return action;
		});
		return actionPromise;
	}
	static isVarDecl(identToken) {
		let tmp = identToken.parent;
		if(tmp == null) {
			return false;
		}
		let _g = tmp.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 2:case 42:
				return true;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	static isFunctionName(nameToken) {
		let tmp = nameToken.parent;
		if(tmp == null) {
			return false;
		}
		let _g = tmp.tok;
		if(_g._hx_index == 1) {
			if(_g.k._hx_index == 0) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	static extractReturnType(hint) {
		if(hint.length == 0 || HxOverrides.cca(hint,0) != 40) {
			return hint;
		}
		let pOpens = 0;
		let _g_offset = 0;
		while(_g_offset < hint.length) {
			let _g_key = _g_offset;
			switch(hint.charCodeAt(_g_offset++)) {
			case 40:
				++pOpens;
				break;
			case 41:
				--pOpens;
				if(pOpens != 0) {
					continue;
				}
				let part = StringTools.trim(HxOverrides.substr(hint,_g_key + 1,null));
				if(part.startsWith("->")) {
					return StringTools.ltrim(HxOverrides.substr(part,2,null));
				} else {
					return hint;
				}
				break;
			}
		}
		return hint;
	}
}
haxeLanguageServer_features_haxe_codeAction_diagnostics_AddTypeHintActions.__name__ = "haxeLanguageServer.features.haxe.codeAction.diagnostics.AddTypeHintActions";
class haxeLanguageServer_features_haxe_codeAction_diagnostics_ChangeFinalToVarAction {
	static createChangeFinalToVarAction(context,action,params,diagnostic) {
		if(params.context.only != null && !params.context.only.includes("quickfix")) {
			return null;
		}
		let uri = params.textDocument.uri;
		let value = context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let document = doc;
		if(document == null) {
			return null;
		}
		let tokenSource = new jsonrpc__$CancellationToken_CancellationTokenImpl();
		let _v_ = document.get_tokens();
		let varToken = _v_ == null ? null : _v_.getTokenAtOffset(document.offsetAt(diagnostic.range.start));
		if(varToken == null) {
			return null;
		}
		let actionPromise = Promise.all([new Promise(function(resolve,reject) {
			context.gotoDefinition.onGotoDefinition({ textDocument : params.textDocument, position : document.positionAt(varToken.pos.min,0)},tokenSource,function(array) {
				resolve(array);
			},function(error) {
				reject(error);
			});
		})]).then(function(results) {
			let tmp = results[0][0];
			if(tmp == null) {
				return action;
			}
			let uri = tmp.targetUri;
			let value = context.documents.documents.h[uri];
			let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let definitionDoc = doc;
			if(definitionDoc == null) {
				return action;
			}
			let _v_ = definitionDoc.get_tokens();
			let tmp1 = haxeLanguageServer_features_haxe_codeAction_diagnostics_ChangeFinalToVarAction.getFinalKwd(_v_ == null ? null : _v_.getTokenAtOffset(definitionDoc.offsetAt(tmp.targetSelectionRange.start)));
			if(tmp1 == null) {
				return action;
			}
			let endOffset = tmp1.pos.max;
			let offsetKind = 0;
			let range = { start : document.positionAt(tmp1.pos.min,offsetKind), end : document.positionAt(endOffset,offsetKind)};
			let changes = { };
			if(definitionDoc != null) {
				changes[definitionDoc.uri] = [{ range : range, newText : "var"}];
			}
			action.edit = { changes : changes};
			return action;
		});
		return actionPromise;
	}
	static getFinalKwd(token) {
		let kwdFinal = token == null ? null : token.parent;
		if(kwdFinal == null) {
			return null;
		}
		let _g = kwdFinal.tok;
		if(!(_g._hx_index == 1 && _g.k._hx_index == 42)) {
			return null;
		}
		return kwdFinal;
	}
}
haxeLanguageServer_features_haxe_codeAction_diagnostics_ChangeFinalToVarAction.__name__ = "haxeLanguageServer.features.haxe.codeAction.diagnostics.ChangeFinalToVarAction";
class haxeLanguageServer_features_haxe_codeAction_diagnostics_CompilerErrorActions {
	static createCompilerErrorActions(context,params,diagnostic) {
		if(params.context.only != null && !params.context.only.includes("quickfix")) {
			return [];
		}
		let actions = [];
		let arg = context.diagnostics.getArguments(params.textDocument.uri,2,diagnostic.range);
		if(arg == null) {
			return actions;
		}
		let suggestionsRe = new EReg("\\(Suggestions?: (.*)\\)","");
		if(suggestionsRe.match(arg)) {
			let suggestions = suggestionsRe.matched(1).split(",");
			let range = diagnostic.range;
			let fieldRe = new EReg("has no field ([^ ]+) ","");
			if(fieldRe.match(arg)) {
				range.start.character = range.end.character - fieldRe.matched(1).length;
			}
			let _g = 0;
			while(_g < suggestions.length) {
				let suggestion = suggestions[_g];
				++_g;
				suggestion = StringTools.trim(suggestion);
				let uri = params.textDocument.uri;
				let value = context.documents.documents.h[uri];
				let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
				if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
					doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
				}
				let doc1 = doc;
				let changes = { };
				if(doc1 != null) {
					changes[doc1.uri] = [{ range : range, newText : suggestion}];
				}
				actions.push({ title : "Change to " + suggestion, kind : "quickfix", edit : { changes : changes}, diagnostics : [diagnostic]});
			}
			return actions;
		}
		let invalidPackageRe = new EReg("Invalid package : ([\\w.]*) should be ([\\w.]*)","");
		if(invalidPackageRe.match(arg)) {
			let is = invalidPackageRe.matched(1);
			let shouldBe = invalidPackageRe.matched(2);
			let uri = params.textDocument.uri;
			let value = context.documents.documents.h[uri];
			let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let document = doc;
			if(document != null) {
				let replacement = StringTools.replace(document.getText(diagnostic.range),is,shouldBe);
				let edits = [{ range : diagnostic.range, newText : replacement}];
				let uri = params.textDocument.uri;
				let value = context.documents.documents.h[uri];
				let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
				if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
					doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
				}
				let doc1 = doc;
				let changes = { };
				if(doc1 != null) {
					changes[doc1.uri] = edits;
				}
				actions.push({ title : "Change to " + replacement, kind : "quickfix" + ".auto", edit : { changes : changes}, diagnostics : [diagnostic], isPreferred : true});
			}
		}
		if(context.haxeServer.haxeVersion.major >= 4 && arg.includes("should be declared with 'override' since it is inherited from superclass")) {
			let pos = diagnostic.range.start;
			let uri = params.textDocument.uri;
			let value = context.documents.documents.h[uri];
			let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let document = doc;
			if(document.get_tokens() != null) {
				let _v_ = document.get_tokens();
				let _v_1 = _v_ == null ? null : _v_.getTokenAtOffset(document.offsetAt(diagnostic.range.start));
				let _v_2 = _v_1 == null ? null : _v_1.parent;
				let _v_3 = _v_2 == null ? null : _v_2.pos;
				let funPos = _v_3 == null ? null : _v_3.min;
				if(funPos != null) {
					pos = document.positionAt(funPos,0);
				}
			}
			let uri1 = params.textDocument.uri;
			let value1 = context.documents.documents.h[uri1];
			let doc1 = ((value1) instanceof haxeLanguageServer_documents_HaxeDocument) ? value1 : null;
			if(doc1 == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri1)) {
				doc1 = new haxeLanguageServer_documents_HaxeDocument(uri1,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri1),{ encoding : "utf8"}));
			}
			let doc2 = doc1;
			let changes = { };
			if(doc2 != null) {
				changes[doc2.uri] = [{ range : { start : pos, end : pos}, newText : "override "}];
			}
			actions.push({ title : "Add override keyword", kind : "quickfix" + ".auto", edit : { changes : changes}, diagnostics : [diagnostic], isPreferred : true});
		}
		if(new EReg("Too many arguments([\\w.]*)","").match(arg)) {
			actions.push({ title : "Add argument", data : { type : haxeLanguageServer_features_haxe_codeAction_CodeActionResolveType.MissingArg, params : params, diagnostic : diagnostic}, kind : "quickfix", diagnostics : [diagnostic], isPreferred : false});
		}
		if(arg.includes("Cannot assign to final") || arg.includes("This expression cannot be accessed for writing")) {
			actions.push({ title : "Change final to var", data : { type : haxeLanguageServer_features_haxe_codeAction_CodeActionResolveType.ChangeFinalToVar, params : params, diagnostic : diagnostic}, kind : "quickfix", diagnostics : [diagnostic], isPreferred : false});
		}
		return actions;
	}
}
haxeLanguageServer_features_haxe_codeAction_diagnostics_CompilerErrorActions.__name__ = "haxeLanguageServer.features.haxe.codeAction.diagnostics.CompilerErrorActions";
class haxeLanguageServer_features_haxe_codeAction_diagnostics_FixAllAction {
	static createFixAllAction(context,params,existingActions) {
		if(params.context.only != null && !params.context.only.includes("source.fixAll")) {
			return [];
		}
		let uri = params.textDocument.uri;
		let value = context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		if(doc == null) {
			return [];
		}
		return [{ title : "Fix All", kind : "source.fixAll", command : { title : "Fix All", command : "haxe.fixAll"}, isPreferred : true}];
	}
}
haxeLanguageServer_features_haxe_codeAction_diagnostics_FixAllAction.__name__ = "haxeLanguageServer.features.haxe.codeAction.diagnostics.FixAllAction";
class haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction {
	static createMissingArgumentsAction(context,action,params,diagnostic) {
		if(params.context.only != null && !params.context.only.includes("quickfix")) {
			return null;
		}
		let uri = params.textDocument.uri;
		let value = context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let document = doc;
		if(document == null) {
			return null;
		}
		let tokenSource = new jsonrpc__$CancellationToken_CancellationTokenImpl();
		let _v_ = document.get_tokens();
		let argToken = _v_ == null ? null : _v_.getTokenAtOffset(document.offsetAt(diagnostic.range.start) + 1);
		if(argToken == null) {
			return null;
		}
		let funPos = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.getCallNamePos(document,argToken);
		if(funPos == null) {
			return null;
		}
		let gotoPromise = new Promise(function(resolve,reject) {
			context.gotoDefinition.onGotoDefinition({ textDocument : params.textDocument, position : funPos.start},tokenSource,function(array) {
				resolve(array);
			},function(error) {
				reject(error);
			});
		});
		let this1 = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(document.uri);
		let hoverPos = document.offsetAt(diagnostic.range.end) - 1;
		if(haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.isFunctionInArg(argToken)) {
			if(haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.isSingleArgArrowFunction(argToken)) {
				let _v_ = argToken.getFirstChild();
				let _v_1 = _v_ == null ? null : _v_.pos;
				let tmp = _v_1 == null ? null : _v_1.min;
				if(tmp != null) {
					hoverPos = tmp;
				}
			} else {
				hoverPos = document.offsetAt(diagnostic.range.start);
			}
		} else if(argToken.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdNew))) {
			let _v_ = argToken.getFirstChild();
			let _v_1 = _v_ == null ? null : _v_.pos;
			let tmp = _v_1 == null ? null : _v_1.min;
			if(tmp != null) {
				hoverPos = tmp;
			}
		}
		let actionPromise = Promise.all([gotoPromise,haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.makeHoverRequest(context,this1,hoverPos,tokenSource)]).then(function(results) {
			let tmp = results[0][0];
			if(tmp == null) {
				return action;
			}
			let item = results[1].item;
			let tmp1 = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.printTypeHint(item);
			if(tmp1 == null) {
				return action;
			}
			let uri = tmp.targetUri;
			let value = context.documents.documents.h[uri];
			let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let definitionDoc = doc;
			if(definitionDoc == null) {
				return action;
			}
			let _v_ = definitionDoc.get_tokens();
			let definitonFunToken = _v_ == null ? null : _v_.getTokenAtOffset(definitionDoc.offsetAt(tmp.targetSelectionRange.start));
			let tmp2 = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.functionNewArgPos(definitionDoc,definitonFunToken);
			if(tmp2 == null) {
				return action;
			}
			let hadCommaAtEnd = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.functionArgsEndsWithComma(definitionDoc,definitonFunToken);
			let argName = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.generateArgName(item);
			let argNames = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.getArgsNames(context,definitionDoc,definitonFunToken);
			let _g = 1;
			while(_g < 10) {
				let i = _g++;
				let name = argName + (i == 1 ? "" : "" + i);
				if(!argNames.includes(name)) {
					argName = name;
					break;
				}
			}
			let isSnippet = context.hasClientCommandSupport("haxe.codeAction.insertSnippet");
			let arg = "" + argName;
			if(isSnippet) {
				arg = "$" + "{1:" + arg + "}";
			}
			if(tmp1 != "?") {
				arg += ":" + tmp1;
			}
			if(haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.functionArgsCount(definitionDoc,definitonFunToken) > 0) {
				arg = hadCommaAtEnd ? " " + arg : ", " + arg;
			}
			if(isSnippet) {
				action.command = { title : "Insert Snippet", command : "haxe.codeAction.insertSnippet", 'arguments' : [definitionDoc.uri,tmp2,arg]};
			} else {
				let changes = { };
				if(definitionDoc != null) {
					changes[definitionDoc.uri] = [{ range : tmp2, newText : arg}];
				}
				action.edit = { changes : changes};
				action.command = { title : "Highlight Insertion", command : "haxe.codeAction.highlightInsertion", 'arguments' : [definitionDoc.uri,tmp2]};
			}
			return action;
		});
		return actionPromise;
	}
	static printTypeHint(item) {
		let itemType = item.type;
		if(itemType == null) {
			return null;
		}
		let typeHint = new haxeLanguageServer_protocol_DisplayPrinter(true,haxeLanguageServer_protocol_PathPrinting.Qualified,{ argumentTypeHints : true, returnTypeHint : "always", useArrowSyntax : true, placeOpenBraceOnNewLine : false, explicitPublic : true, explicitPrivate : true, explicitNull : true}).printType(haxeLanguageServer_protocol_Extensions_removeNulls(itemType).type);
		let _this_r = new RegExp("Null<Null<(.+?)>>","g".split("u").join(""));
		typeHint = typeHint.replace(_this_r,"Null<$1>");
		return typeHint;
	}
	static isFunctionInArg(argToken) {
		if(argToken.tok == tokentree_TokenTreeDef.POpen) {
			return tokentree_utils_TokenTreeCheckUtils.getPOpenType(argToken) == tokentree_utils_POpenType.Parameter;
		}
		if(haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.isSingleArgArrowFunction(argToken)) {
			return true;
		}
		return argToken.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction));
	}
	static isSingleArgArrowFunction(argToken) {
		if(argToken.isCIdent()) {
			let _v_ = argToken.getFirstChild();
			return (_v_ == null ? null : _v_.tok) == tokentree_TokenTreeDef.Arrow;
		} else {
			return false;
		}
	}
	static generateArgName(item) {
		switch(item.kind) {
		case "AnonymousStructure":
			return "obj";
		case "ClassField":
			let _v_ = item.args;
			let _v_1 = _v_ == null ? null : _v_.field;
			let tmp = _v_1 == null ? null : _v_1.name;
			if(tmp != null) {
				return tmp;
			} else {
				return "arg";
			}
			break;
		case "Expression":
			let _v_2 = item.type;
			if((_v_2 == null ? null : _v_2.kind) == "TFun") {
				return "callback";
			}
			break;
		case "Literal":
			break;
		default:
			let _v_3 = item.args;
			let tmp1 = _v_3 == null ? null : _v_3.name;
			if(tmp1 != null) {
				return tmp1;
			} else {
				return "arg";
			}
		}
		return haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.genArgNameFromJsonType(item.type);
	}
	static genArgNameFromJsonType(type) {
		let dotPath;
		let tmp = type == null ? null : haxeLanguageServer_protocol_DotPath_getDotPath(type);
		if(tmp != null) {
			dotPath = tmp;
		} else {
			return "arg";
		}
		if(dotPath == null) {
			return "arg";
		} else {
			switch(dotPath) {
			case "Dynamic":
				return "value";
			case "EReg":
				return "regExp";
			case "StdTypes.Bool":
				return "bool";
			case "StdTypes.Float":
				return "f";
			case "String":
				return "s";
			case "StdTypes.Int":case "UInt":
				return "i";
			case "haxe.ds.Map":
				return "map";
			case "Array":case "haxe.ds.ReadOnlyArray":
				return "arr";
			default:
				return "arg";
			}
		}
	}
	static getArgsNames(context,document,funIdent) {
		let tmp = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.getFunctionPOpen(funIdent);
		if(tmp == null) {
			return [];
		}
		let args = tmp.filterCallback(function(tree,depth) {
			if(depth == 0) {
				return tokentree_FilterResult.GoDeeper;
			} else if(tree.isCIdent()) {
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.SkipSubtree;
			}
		});
		let result = new Array(args.length);
		let _g = 0;
		let _g1 = args.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = args[i].toString();
		}
		return result;
	}
	static makeHoverRequest(context,fileName,pos,token) {
		let request_resolve = null;
		let promise = new Promise(function(resolve,reject) {
			request_resolve = resolve;
		});
		context.callHaxeMethod("display/hover",{ file : fileName, offset : pos},token,function(hover) {
			if(request_resolve != null) {
				if(hover == null) {
					request_resolve(null);
				} else {
					request_resolve(hover);
				}
			}
			return null;
		},function(msg) {
			if(request_resolve != null) {
				request_resolve(null);
			}
		});
		return promise;
	}
	static getCallNamePos(document,argToken) {
		let parent = tokentree_TokenTreeAccessHelper.findParent(argToken,function(helper) {
			let _v_ = helper == null ? null : helper;
			let _g = _v_ == null ? null : _v_.tok;
			if(_g == null) {
				return false;
			} else if(_g._hx_index == 2) {
				if(_g.c._hx_index == 3) {
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
		});
		if(parent == null) {
			return null;
		}
		let tokenPos = parent.pos;
		let endOffset = tokenPos.max;
		let offsetKind = 0;
		return { start : document.positionAt(tokenPos.min,offsetKind), end : document.positionAt(endOffset,offsetKind)};
	}
	static getFunctionPOpen(funIdent) {
		if(funIdent == null) {
			return null;
		}
		let _v_ = funIdent;
		let _v_1 = _v_ == null ? null : _v_.parent;
		let _g = _v_1 == null ? null : _v_1.tok;
		if(!(_g == null ? false : _g._hx_index == 1 && _g.k._hx_index == 0)) {
			let tmp = funIdent.getFirstChild();
			if(tmp != null) {
				funIdent = tmp;
			} else {
				return null;
			}
		}
		let _v_2 = tokentree_TokenTreeAccessHelper.firstOf(funIdent,tokentree_TokenTreeDef.POpen);
		return _v_2 == null ? null : _v_2;
	}
	static functionNewArgPos(document,funIdent) {
		let pOpen = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.getFunctionPOpen(funIdent);
		if(pOpen == null) {
			return null;
		}
		let _v_ = tokentree_TokenTreeAccessHelper.firstOf(pOpen,tokentree_TokenTreeDef.PClose);
		let pClose = _v_ == null ? null : _v_;
		if(pClose == null) {
			return null;
		}
		let endOffset = pClose.pos.min;
		let offsetKind = 0;
		return { start : document.positionAt(pClose.pos.min,offsetKind), end : document.positionAt(endOffset,offsetKind)};
	}
	static functionArgsCount(document,funIdent) {
		let tmp = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.getFunctionPOpen(funIdent);
		if(tmp == null) {
			return 0;
		}
		return tmp.filterCallback(function(tree,depth) {
			if(depth == 0) {
				return tokentree_FilterResult.GoDeeper;
			} else if(tree.isCIdent()) {
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.SkipSubtree;
			}
		}).length;
	}
	static functionArgsEndsWithComma(document,funIdent) {
		let tmp = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.getFunctionPOpen(funIdent);
		if(tmp == null) {
			return false;
		}
		let _v_ = tmp.getLastChild();
		let maybeComma = _v_ == null ? null : _v_.getLastChild();
		if(maybeComma == null) {
			return false;
		}
		return maybeComma.matches(tokentree_TokenTreeDef.Comma);
	}
}
haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.__name__ = "haxeLanguageServer.features.haxe.codeAction.diagnostics.MissingArgumentsAction";
class haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingFieldsActions {
	static createMissingFieldsActions(context,params,diagnostic) {
		if(params.context.only != null && !params.context.only.includes("quickfix")) {
			return [];
		}
		let args = context.diagnostics.getArguments(params.textDocument.uri,7,diagnostic.range);
		if(args == null) {
			return [];
		}
		let uri = haxeLanguageServer_extensions_FsPathExtensions_toUri(args.moduleFile);
		let value = context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let document = doc;
		if(document == null) {
			if(!sys_FileSystem.exists(args.moduleFile)) {
				return [];
			}
			let content = js_node_Fs.readFileSync(args.moduleFile,{ encoding : "utf8"});
			document = new haxeLanguageServer_documents_HaxeDocument(uri,"haxe",0,content);
		}
		let tmp = document.get_tokens();
		if(tmp == null) {
			return [];
		}
		let rangeClass = null;
		let rangeFieldInsertion;
		let moduleLevelField = false;
		let className = args.moduleType.name;
		let classToken = null;
		if(args.moduleType.kind == "class") {
			classToken = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingFieldsActions.getClassToken(tmp.tree,className);
			if(classToken == null) {
				moduleLevelField = true;
				let lastPos = document.content.length - 1;
				let offsetKind = 0;
				rangeFieldInsertion = { start : document.positionAt(lastPos,offsetKind), end : document.positionAt(lastPos,offsetKind)};
			} else {
				let pos = tmp.getPos(classToken);
				let endOffset = pos.min;
				let offsetKind = 0;
				rangeClass = { start : document.positionAt(pos.min,offsetKind), end : document.positionAt(endOffset,offsetKind)};
				let pos1 = tmp.getTreePos(classToken);
				let endOffset1 = pos1.max - 1;
				let offsetKind1 = 0;
				rangeFieldInsertion = { start : document.positionAt(pos1.max - 1,offsetKind1), end : document.positionAt(endOffset1,offsetKind1)};
			}
		} else {
			return [];
		}
		let actions = [];
		let importConfig = context.config.user.codeGeneration.imports;
		let printer = new haxeLanguageServer_protocol_DisplayPrinter(false,importConfig.enableAutoImports ? haxeLanguageServer_protocol_PathPrinting.Shadowed : haxeLanguageServer_protocol_PathPrinting.Qualified,context.config.user.codeGeneration.functions.field);
		let allEdits = [];
		let isSnippet = context.hasClientCommandSupport("haxe.codeAction.insertSnippet");
		let snippetEdit = null;
		let allDotPaths = [];
		let _g = 0;
		let _g1 = args.entries;
		while(_g < _g1.length) {
			let entry = _g1[_g];
			++_g;
			let fields = entry.fields.slice();
			let getTitle = function(cause) {
				switch(cause.kind) {
				case "AbstractParent":
					if(rangeClass != null) {
						let actions1 = actions;
						let changes = { };
						if(document != null) {
							changes[document.uri] = [{ range : rangeClass, newText : "abstract "}];
						}
						actions1.push({ title : "Make abstract", kind : "quickfix", edit : { changes : changes}, diagnostics : [diagnostic]});
					}
					return haxe_ds_Option.Some("Implement methods for " + printer.printPathWithParams(cause.args.parent));
				case "FieldAccess":
					let tmp = fields[0];
					if(tmp == null) {
						return haxe_ds_Option.None;
					}
					let target = moduleLevelField ? StringTools.replace(haxe_io_Path.withoutDirectory(args.moduleFile),".hx","") : className;
					return haxe_ds_Option.Some("Add " + tmp.field.name + " to " + target);
				case "FinalFields":
					let funArgs = [];
					let assignments = [];
					cause.args.fields.sort(function(cf1,cf2) {
						return cf1.pos.min - cf2.pos.min;
					});
					let _g = 0;
					let _g1 = cause.args.fields;
					while(_g < _g1.length) {
						let field = _g1[_g];
						++_g;
						funArgs.push({ name : field.name, opt : false, t : field.type});
						let name = field.name;
						assignments.push("this." + name + " = " + name);
					}
					let ctorField = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingFieldsActions.makeCtorJsonField(funArgs,assignments,args.moduleType.pos);
					fields.push({ field : ctorField, type : ctorField.type, unique : false});
					return haxe_ds_Option.Some("Add constructor to " + className);
				case "ImplementedInterface":
					return haxe_ds_Option.Some("Implement fields for " + printer.printPathWithParams(cause.args.parent));
				case "PropertyAccessor":
					return haxe_ds_Option.Some("Implement " + (cause.args.isGetter ? "getter" : "setter") + " for " + cause.args.property.name);
				}
			};
			let title;
			let _g2 = getTitle(entry.cause);
			switch(_g2._hx_index) {
			case 0:
				title = _g2.v;
				break;
			case 1:
				return [];
			}
			let edits = [];
			let snippetEditId = -1;
			let getQualified = printer.collectQualifiedPaths();
			fields.sort(function(a,b) {
				return a.field.pos.min - b.field.pos.min;
			});
			let _g3 = 0;
			while(_g3 < fields.length) {
				let field = fields[_g3];
				++_g3;
				let buf_b = "";
				buf_b = "" + (moduleLevelField ? "\n\n" : "\n\t");
				let expressions = [];
				if(field.field.expr != null) {
					let _g = 0;
					let _g1 = field.field.expr.string.split("\n");
					while(_g < _g1.length) expressions.push(_g1[_g++]);
				} else {
					let signature = haxeLanguageServer_protocol_Extensions_extractFunctionSignature(field.type);
					let args = signature == null ? null : signature.args;
					if(args != null) {
						let isSnippetArgs = isSnippet && snippetEditId == -1;
						haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingFieldsActions.renameGeneratedFunctionArgs(args,isSnippetArgs);
						if(isSnippetArgs) {
							snippetEditId = edits.length;
						}
					}
					if(signature != null && haxeLanguageServer_protocol_DotPath_getDotPath(signature.ret) != "StdTypes.Void") {
						expressions.push("throw new haxe.exceptions.NotImplementedException()");
					}
				}
				buf_b += Std.string(printer.printClassFieldImplementation(field.field,field.type,false,moduleLevelField,expressions));
				if(classToken != null) {
					if(field.type.kind != "TFun") {
						let range = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingFieldsActions.getNewVariablePos(document,classToken,field.field.scope);
						if(range != null) {
							rangeFieldInsertion = range;
						}
					} else {
						let _v_ = tmp;
						let funToken = _v_ == null ? null : _v_.getTokenAtOffset(document.offsetAt(diagnostic.range.start));
						if(funToken != null) {
							let range = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingFieldsActions.getNewClassFunctionPos(document,classToken,funToken);
							if(range != null) {
								rangeFieldInsertion = range;
							}
						}
					}
				}
				let edit = { range : rangeFieldInsertion, newText : buf_b};
				edits.push(edit);
				if(field.unique) {
					allEdits.push(edit);
				}
			}
			let dotPaths = getQualified();
			dotPaths = haxeLanguageServer_extensions_ArrayExtensions_filterDuplicates(dotPaths,function(a,b) {
				return a == b;
			});
			allDotPaths = allDotPaths.concat(dotPaths);
			if(dotPaths.length > 0) {
				edits.push(haxeLanguageServer_helper_ImportHelper_createImportsEdit(document,haxeLanguageServer_helper_ImportHelper_determineImportPosition(document),dotPaths,importConfig.style));
			}
			let codeAction = { title : title, kind : "quickfix", diagnostics : [diagnostic]};
			snippetEdit = edits[snippetEditId];
			if(snippetEdit != null) {
				let text = snippetEdit.newText;
				let matchBodyExpr = new EReg("({\n[\t ]+)(.+)\n","");
				if(matchBodyExpr.match(text)) {
					text = text.replace(matchBodyExpr.r,"$1$" + "{0:$2}\n");
				}
				codeAction.command = { title : "Insert Snippet", command : "haxe.codeAction.insertSnippet", 'arguments' : [document.uri,rangeFieldInsertion,text]};
			} else {
				let changes = { };
				if(document != null) {
					changes[document.uri] = edits;
				}
				codeAction.edit = { changes : changes};
				if(entry.cause.kind == "FieldAccess") {
					codeAction.command = { title : "Highlight Insertion", command : "haxe.codeAction.highlightInsertion", 'arguments' : [document.uri,rangeFieldInsertion]};
				}
			}
			actions.unshift(codeAction);
		}
		if(args.entries.length > 1) {
			allDotPaths = haxeLanguageServer_extensions_ArrayExtensions_filterDuplicates(allDotPaths,function(a,b) {
				return a == b;
			});
			if(allDotPaths.length > 0) {
				allEdits.push(haxeLanguageServer_helper_ImportHelper_createImportsEdit(document,haxeLanguageServer_helper_ImportHelper_determineImportPosition(document),allDotPaths,importConfig.style));
			}
			let action = { title : "Implement all missing fields", kind : "quickfix", diagnostics : [diagnostic]};
			if(snippetEdit != null) {
				let item = Lambda.find(allEdits,function(item) {
					return item.newText == snippetEdit.newText;
				});
				if(item != null) {
					HxOverrides.remove(allEdits,item);
				}
				action.command = { title : "Insert Snippet", command : "haxe.codeAction.insertSnippet", 'arguments' : [document.uri,snippetEdit.range,snippetEdit.newText]};
			}
			let changes = { };
			if(document != null) {
				changes[document.uri] = allEdits;
			}
			action.edit = { changes : changes};
			actions.unshift(action);
		}
		if(actions.length > 0) {
			actions[0].isPreferred = true;
		}
		return actions;
	}
	static getClassToken(tree,className) {
		let classTokens = tree.filterCallback(function(token,_) {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				if(_g.k._hx_index == 1) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
				break;
			case 3:
				return tokentree_FilterResult.GoDeeper;
			default:
				return tokentree_FilterResult.SkipSubtree;
			}
		});
		let _g = 0;
		while(_g < classTokens.length) {
			let token = classTokens[_g];
			++_g;
			let tmp = tokentree_utils_TokenTreeCheckUtils.getNameToken(token);
			if(tmp == null) {
				continue;
			}
			if(tokentree_utils_TokenTreeCheckUtils.getName(tmp) == className) {
				return token;
			}
		}
		return null;
	}
	static makeCtorJsonField(funArgs,assignments,pos) {
		let ctorField = assignments.join("\n");
		return { name : "new", type : { kind : "TFun", args : { args : funArgs, ret : { kind : "TMono", args : null}}}, isPublic : true, isFinal : false, isAbstract : false, params : [], meta : [], kind : { kind : "FMethod", args : "MethNormal"}, pos : pos, doc : null, overloads : [], scope : 2, expr : { string : ctorField}};
	}
	static renameGeneratedFunctionArgs(args,isSnippetArgs) {
		let argNames = [];
		let id = 0;
		let _g = 0;
		while(_g < args.length) {
			let arg = args[_g];
			++_g;
			let argName = arg.name;
			if(argName.startsWith("arg") && argName.length == 4) {
				argName = haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingArgumentsAction.genArgNameFromJsonType(arg.t);
			}
			let _g1 = 1;
			while(_g1 < 10) {
				let i = _g1++;
				let name = argName + (i == 1 ? "" : "" + i);
				if(!argNames.includes(name)) {
					argNames.push(name);
					argName = name;
					break;
				}
			}
			++id;
			if(arg.name.startsWith("${")) {
				continue;
			}
			arg.name = isSnippetArgs ? "$" + "{" + id + ":" + argName + "}" : argName;
		}
	}
	static getNewVariablePos(document,classToken,fieldScope) {
		let _v_ = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(classToken),tokentree_TokenTreeDef.BrOpen);
		let brOpen = _v_ == null ? null : _v_;
		if(brOpen == null) {
			return null;
		}
		if(fieldScope == 0) {
			let endOffset = brOpen.pos.max;
			let offsetKind = 0;
			return { start : document.positionAt(brOpen.pos.max,offsetKind), end : document.positionAt(endOffset,offsetKind)};
		}
		let firstFun = tokentree_TokenTreeAccessHelper.firstOf(brOpen,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction));
		let _v_1 = firstFun == null ? null : firstFun;
		let prev = _v_1 == null ? null : _v_1.previousSibling;
		if(prev == null) {
			let endOffset = brOpen.pos.max;
			let offsetKind = 0;
			return { start : document.positionAt(brOpen.pos.max,offsetKind), end : document.positionAt(endOffset,offsetKind)};
		}
		let pos = prev.getPos();
		let endOffset = pos.max;
		let offsetKind = 0;
		return { start : document.positionAt(pos.max,offsetKind), end : document.positionAt(endOffset,offsetKind)};
	}
	static getNewClassFunctionPos(document,classToken,callToken) {
		let _v_ = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(classToken),tokentree_TokenTreeDef.BrOpen);
		let brOpen = _v_ == null ? null : _v_;
		if(brOpen == null) {
			return null;
		}
		if(brOpen.filter([callToken.tok],tokentree_TokenFilterMode.First).length == 0) {
			return null;
		}
		let callPos = callToken.getPos();
		let _this = brOpen.children;
		let _g_current = 0;
		while(_g_current < _this.length) {
			let _g_value = _this[_g_current];
			++_g_current;
			let tokenPos = _g_value.getPos();
			if(callPos.min < tokenPos.min || callPos.min > tokenPos.max) {
				continue;
			}
			let _g = _g_value.tok;
			if(_g._hx_index == 1 && _g.k._hx_index == 0) {
				let endOffset = tokenPos.max + 1;
				let offsetKind = 0;
				return { start : document.positionAt(tokenPos.max + 1,offsetKind), end : document.positionAt(endOffset,offsetKind)};
			}
		}
		return null;
	}
}
haxeLanguageServer_features_haxe_codeAction_diagnostics_MissingFieldsActions.__name__ = "haxeLanguageServer.features.haxe.codeAction.diagnostics.MissingFieldsActions";
class haxeLanguageServer_features_haxe_codeAction_diagnostics_OrganizeImportActions {
	static createOrganizeImportActions(context,params,existingActions) {
		let shouldQuickFix = true;
		let shouldOrganize = true;
		let shouldSort = true;
		if(params.context.only != null) {
			shouldQuickFix = params.context.only.includes("quickfix");
			shouldOrganize = params.context.only.includes("source.organizeImports");
			shouldSort = params.context.only.includes("source.sortImports");
		}
		if(!shouldQuickFix && !shouldOrganize && !shouldSort) {
			return [];
		}
		let uri = params.textDocument.uri;
		let value = context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null) {
			return [];
		}
		let map = context.diagnostics.getArgumentsMap(uri);
		let removeUnusedFixes;
		if(map == null) {
			removeUnusedFixes = [];
		} else {
			let _g = [];
			let key = map.keys();
			while(key.hasNext()) {
				let key1 = key.next();
				if(key1.code == 0) {
					_g.push(haxeLanguageServer_helper_WorkspaceEditHelper.removeText(haxeLanguageServer_helper_DocHelper.untrimRange(doc1,key1.range)));
				}
			}
			removeUnusedFixes = _g;
		}
		let sortFixes = haxeLanguageServer_features_haxe_codeAction_OrganizeImportsFeature.organizeImports(doc1,context,[]);
		let result = new Array(removeUnusedFixes.length);
		let _g = 0;
		let _g1 = removeUnusedFixes.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = removeUnusedFixes[i].range;
		}
		let organizeFixes = removeUnusedFixes.concat(haxeLanguageServer_features_haxe_codeAction_OrganizeImportsFeature.organizeImports(doc1,context,result));
		let _g2 = [];
		let _g3 = 0;
		while(_g3 < existingActions.length) {
			let v = existingActions[_g3];
			++_g3;
			if(v.title == "Remove unused import/using") {
				_g2.push(v);
			}
		}
		let result1 = new Array(_g2.length);
		let _g4 = 0;
		let _g5 = _g2.length;
		while(_g4 < _g5) {
			let i = _g4++;
			result1[i] = _g2[i].diagnostics;
		}
		let _g6 = [];
		let e = $getIterator(result1);
		while(e.hasNext()) {
			let x = $getIterator(e.next());
			while(x.hasNext()) _g6.push(x.next());
		}
		let diagnostics = Lambda.array(_g6);
		let actions = [];
		if(shouldOrganize) {
			let uri = params.textDocument.uri;
			let value = context.documents.documents.h[uri];
			let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let doc1 = doc;
			let changes = { };
			if(doc1 != null) {
				changes[doc1.uri] = organizeFixes;
			}
			actions.push({ title : "Organize imports/usings", kind : "source.organizeImports", edit : { changes : changes}, diagnostics : diagnostics});
		}
		if(shouldSort) {
			let uri = params.textDocument.uri;
			let value = context.documents.documents.h[uri];
			let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let doc1 = doc;
			let changes = { };
			if(doc1 != null) {
				changes[doc1.uri] = sortFixes;
			}
			actions.push({ title : "Sort imports/usings", kind : "source.sortImports", edit : { changes : changes}});
		}
		if(shouldQuickFix && diagnostics.length > 0 && removeUnusedFixes.length > 1) {
			let uri = params.textDocument.uri;
			let value = context.documents.documents.h[uri];
			let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let doc1 = doc;
			let changes = { };
			if(doc1 != null) {
				changes[doc1.uri] = removeUnusedFixes;
			}
			actions.push({ title : "Remove all unused imports/usings", kind : "quickfix", edit : { changes : changes}, diagnostics : diagnostics});
		}
		return actions;
	}
}
haxeLanguageServer_features_haxe_codeAction_diagnostics_OrganizeImportActions.__name__ = "haxeLanguageServer.features.haxe.codeAction.diagnostics.OrganizeImportActions";
class haxeLanguageServer_features_haxe_codeAction_diagnostics_ParserErrorActions {
	static createParserErrorActions(context,params,diagnostic) {
		if(params.context.only != null && !params.context.only.includes("quickfix")) {
			return [];
		}
		let actions = [];
		let arg = context.diagnostics.getArguments(params.textDocument.uri,4,diagnostic.range);
		if(arg == null) {
			return actions;
		}
		if(arg.includes("modifier is not supported for module-level fields")) {
			let uri = params.textDocument.uri;
			let value = context.documents.documents.h[uri];
			let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let document = doc;
			let nextText = HxOverrides.substr(document.content,document.offsetAt(diagnostic.range.end),null);
			let isAuto = nextText.split("{").length == nextText.split("}").length;
			let _v_ = document == null ? null : document.get_tokens();
			let token = _v_ == null ? null : _v_.getTokenAtOffset(document.offsetAt(diagnostic.range.end));
			let range = diagnostic.range;
			if(token != null) {
				let _g = 0;
				let _g1 = [token.previousSibling,token.nextSibling];
				while(_g < _g1.length) {
					let sib = _g1[_g];
					++_g;
					if(sib == null) {
						continue;
					}
					let tmp;
					let _g2 = sib.tok;
					if(!(_g2._hx_index == 1 && _g2.k._hx_index == 17)) {
						let _g = sib.tok;
						tmp = _g._hx_index == 1 && _g.k._hx_index == 18;
					} else {
						tmp = true;
					}
					if(tmp) {
						let endOffset = sib.pos.max;
						let offsetKind = 0;
						range = haxeLanguageServer_extensions_RangeExtensions_union(range,{ start : document.positionAt(sib.pos.min,offsetKind), end : document.positionAt(endOffset,offsetKind)});
					}
				}
			}
			let pos = range.end;
			range.end = { line : pos.line, character : pos.character + 1};
			let uri1 = params.textDocument.uri;
			let value1 = context.documents.documents.h[uri1];
			let doc1 = ((value1) instanceof haxeLanguageServer_documents_HaxeDocument) ? value1 : null;
			if(doc1 == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri1)) {
				doc1 = new haxeLanguageServer_documents_HaxeDocument(uri1,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri1),{ encoding : "utf8"}));
			}
			let doc2 = doc1;
			let changes = { };
			if(doc2 != null) {
				changes[doc2.uri] = [{ range : range, newText : ""}];
			}
			actions.push({ title : "Remove redundant modifiers", kind : "quickfix" + (isAuto ? ".auto" : ""), edit : { changes : changes}, diagnostics : [diagnostic], isPreferred : true});
		}
		if(arg.includes("`final var` is not supported, use `final` instead")) {
			let uri = params.textDocument.uri;
			let value = context.documents.documents.h[uri];
			if((((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null) == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let edits = [{ range : diagnostic.range, newText : "final"}];
			let uri1 = params.textDocument.uri;
			let value1 = context.documents.documents.h[uri1];
			let doc = ((value1) instanceof haxeLanguageServer_documents_HaxeDocument) ? value1 : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri1)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri1,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri1),{ encoding : "utf8"}));
			}
			let doc1 = doc;
			let changes = { };
			if(doc1 != null) {
				changes[doc1.uri] = edits;
			}
			actions.push({ title : "Change to final", kind : "quickfix" + ".auto", edit : { changes : changes}, diagnostics : [diagnostic], isPreferred : true});
		}
		if(arg.includes("Missing ;")) {
			haxeLanguageServer_features_haxe_codeAction_diagnostics_ParserErrorActions.createMissingSemicolonAction(context,params,diagnostic,actions);
		}
		if(arg.includes("Expected }")) {
			let uri = params.textDocument.uri;
			let value = context.documents.documents.h[uri];
			let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let document = doc;
			let _v_ = document == null ? null : document.get_tokens();
			let token = _v_ == null ? null : _v_.getTokenAtOffset(document.offsetAt(diagnostic.range.end));
			let prevToken = haxeLanguageServer_features_haxe_codeAction_diagnostics_ParserErrorActions.getPrevNonCommentSibling(token);
			if(prevToken != null && token != null) {
				let prevToken1 = haxeLanguageServer_features_haxe_codeAction_diagnostics_ParserErrorActions.getLastNonCommentToken(prevToken);
				let _g = prevToken1.tok;
				let _g1 = token.tok;
				switch(_g._hx_index) {
				case 10:
					if(_g1._hx_index == 10) {
						let edits = [{ range : diagnostic.range, newText : ""}];
						let uri = params.textDocument.uri;
						let value = context.documents.documents.h[uri];
						let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
						if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
							doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
						}
						let doc1 = doc;
						let changes = { };
						if(doc1 != null) {
							changes[doc1.uri] = edits;
						}
						actions.push({ title : "Remove redundant ;", kind : "quickfix" + ".auto", edit : { changes : changes}, diagnostics : [diagnostic], isPreferred : true});
					} else {
						let tmp;
						switch(_g._hx_index) {
						case 15:case 18:
							tmp = true;
							break;
						default:
							tmp = false;
						}
						if(!tmp) {
							if(haxeLanguageServer_features_haxe_codeAction_diagnostics_ParserErrorActions.isAnonStructureField(token)) {
								let endOffset = prevToken1.pos.max;
								let offsetKind = 0;
								let prevRange = { start : document.positionAt(prevToken1.pos.max,offsetKind), end : document.positionAt(endOffset,offsetKind)};
								let uri = params.textDocument.uri;
								let value = context.documents.documents.h[uri];
								let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
								if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
									doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
								}
								let doc1 = doc;
								let changes = { };
								if(doc1 != null) {
									changes[doc1.uri] = [{ range : prevRange, newText : ","}];
								}
								actions.push({ title : "Add missing ,", kind : "quickfix" + ".auto", edit : { changes : changes}, diagnostics : [diagnostic], isPreferred : true});
							}
						}
					}
					break;
				case 15:
					switch(_g1._hx_index) {
					case 10:
						let tmp = token.previousSibling;
						if(tmp == null) {
							return actions;
						}
						let tmp1 = tmp.parent;
						if(tmp1 == null) {
							return actions;
						}
						let tmp2 = tmp1.parent;
						if(tmp2 == null) {
							return actions;
						}
						if(tmp.tok == tokentree_TokenTreeDef.DblDot && tmp1.tok._hx_index == 2 && tmp2.tok == tokentree_TokenTreeDef.BrOpen) {
							let edits = [{ range : diagnostic.range, newText : ","}];
							let uri = params.textDocument.uri;
							let value = context.documents.documents.h[uri];
							let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
							if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
								doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
							}
							let doc1 = doc;
							let changes = { };
							if(doc1 != null) {
								changes[doc1.uri] = edits;
							}
							actions.push({ title : "Replace ; with ,", kind : "quickfix" + ".auto", edit : { changes : changes}, diagnostics : [diagnostic], isPreferred : true});
						}
						break;
					case 15:
						let edits = [{ range : diagnostic.range, newText : ""}];
						let uri = params.textDocument.uri;
						let value = context.documents.documents.h[uri];
						let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
						if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
							doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
						}
						let doc1 = doc;
						let changes = { };
						if(doc1 != null) {
							changes[doc1.uri] = edits;
						}
						actions.push({ title : "Remove redundant ,", kind : "quickfix" + ".auto", edit : { changes : changes}, diagnostics : [diagnostic], isPreferred : true});
						break;
					default:
						let tmp3;
						switch(_g._hx_index) {
						case 15:case 18:
							tmp3 = true;
							break;
						default:
							tmp3 = false;
						}
						if(!tmp3) {
							if(haxeLanguageServer_features_haxe_codeAction_diagnostics_ParserErrorActions.isAnonStructureField(token)) {
								let endOffset = prevToken1.pos.max;
								let offsetKind = 0;
								let prevRange = { start : document.positionAt(prevToken1.pos.max,offsetKind), end : document.positionAt(endOffset,offsetKind)};
								let uri = params.textDocument.uri;
								let value = context.documents.documents.h[uri];
								let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
								if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
									doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
								}
								let doc1 = doc;
								let changes = { };
								if(doc1 != null) {
									changes[doc1.uri] = [{ range : prevRange, newText : ","}];
								}
								actions.push({ title : "Add missing ,", kind : "quickfix" + ".auto", edit : { changes : changes}, diagnostics : [diagnostic], isPreferred : true});
							}
						}
					}
					break;
				default:
					if(_g1._hx_index == 10) {
						let tmp = token.previousSibling;
						if(tmp == null) {
							return actions;
						}
						let tmp1 = tmp.parent;
						if(tmp1 == null) {
							return actions;
						}
						let tmp2 = tmp1.parent;
						if(tmp2 == null) {
							return actions;
						}
						if(tmp.tok == tokentree_TokenTreeDef.DblDot && tmp1.tok._hx_index == 2 && tmp2.tok == tokentree_TokenTreeDef.BrOpen) {
							let edits = [{ range : diagnostic.range, newText : ","}];
							let uri = params.textDocument.uri;
							let value = context.documents.documents.h[uri];
							let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
							if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
								doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
							}
							let doc1 = doc;
							let changes = { };
							if(doc1 != null) {
								changes[doc1.uri] = edits;
							}
							actions.push({ title : "Replace ; with ,", kind : "quickfix" + ".auto", edit : { changes : changes}, diagnostics : [diagnostic], isPreferred : true});
						}
					} else {
						let tmp;
						switch(_g._hx_index) {
						case 15:case 18:
							tmp = true;
							break;
						default:
							tmp = false;
						}
						if(!tmp) {
							if(haxeLanguageServer_features_haxe_codeAction_diagnostics_ParserErrorActions.isAnonStructureField(token)) {
								let endOffset = prevToken1.pos.max;
								let offsetKind = 0;
								let prevRange = { start : document.positionAt(prevToken1.pos.max,offsetKind), end : document.positionAt(endOffset,offsetKind)};
								let uri = params.textDocument.uri;
								let value = context.documents.documents.h[uri];
								let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
								if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
									doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
								}
								let doc1 = doc;
								let changes = { };
								if(doc1 != null) {
									changes[doc1.uri] = [{ range : prevRange, newText : ","}];
								}
								actions.push({ title : "Add missing ,", kind : "quickfix" + ".auto", edit : { changes : changes}, diagnostics : [diagnostic], isPreferred : true});
							}
						}
					}
				}
			}
		}
		if(arg.includes("Expected , or ]")) {
			let uri = params.textDocument.uri;
			let value = context.documents.documents.h[uri];
			let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let document = doc;
			let errRange = haxeLanguageServer_features_haxe_codeAction_diagnostics_ParserErrorActions.getMissingSemicolonPos(document,diagnostic.range.start);
			if(errRange != null) {
				let pos = errRange.start;
				let pos1 = { line : pos.line, character : pos.character + (-1)};
				if(document.getText({ start : pos1, end : { line : pos1.line, character : pos1.character + 1}}) != ",") {
					let uri = params.textDocument.uri;
					let value = context.documents.documents.h[uri];
					let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
					if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
						doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
					}
					let doc1 = doc;
					let changes = { };
					if(doc1 != null) {
						changes[doc1.uri] = [{ range : errRange, newText : ","}];
					}
					actions.push({ title : "Add missing ,", kind : "quickfix" + ".auto", edit : { changes : changes}, diagnostics : [diagnostic], isPreferred : true});
				}
			}
		}
		return actions;
	}
	static createMissingSemicolonAction(context,params,diagnostic,actions) {
		let uri = params.textDocument.uri;
		let value = context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let document = doc;
		let pos = diagnostic.range.start;
		let errRange = haxeLanguageServer_features_haxe_codeAction_diagnostics_ParserErrorActions.getMissingSemicolonPos(document,{ line : pos.line, character : pos.character + 1});
		if(errRange == null) {
			return;
		}
		let pos1 = errRange.start;
		let pos2 = { line : pos1.line, character : pos1.character + (-1)};
		if(document.getText({ start : pos2, end : { line : pos2.line, character : pos2.character + 1}}) != ";") {
			let uri = params.textDocument.uri;
			let value = context.documents.documents.h[uri];
			let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let doc1 = doc;
			let changes = { };
			if(doc1 != null) {
				changes[doc1.uri] = [{ range : errRange, newText : ";"}];
			}
			actions.push({ title : "Add missing ;", kind : "quickfix" + ".auto", edit : { changes : changes}, diagnostics : [diagnostic], isPreferred : true});
		}
	}
	static getMissingSemicolonPos(document,errPos) {
		let tokens = document.get_tokens();
		if(tokens == null) {
			return null;
		}
		let errToken = tokens == null ? null : tokens.getTokenAtOffset(document.offsetAt(errPos));
		if(errToken == null) {
			return null;
		}
		let prev = haxeLanguageServer_features_haxe_codeAction_diagnostics_ParserErrorActions.getPrevNonCommentSibling(errToken);
		if(prev == null || prev.tok._hx_index == 3) {
			return null;
		}
		let pos = haxeLanguageServer_features_haxe_codeAction_diagnostics_ParserErrorActions.getLastNonCommentToken(prev).getPos();
		let endOffset = pos.max;
		let offsetKind = 0;
		return { start : document.positionAt(pos.max,offsetKind), end : document.positionAt(endOffset,offsetKind)};
	}
	static getPrevNonCommentSibling(token) {
		while(true) {
			let _v_ = token;
			token = _v_ == null ? null : _v_.previousSibling;
			let _v_1 = token;
			if(!((_v_1 == null ? null : _v_1.isComment()) == true)) {
				break;
			}
		}
		return token;
	}
	static getLastNonCommentToken(token) {
		let lastChild = token;
		while(true) {
			let newLast = haxeLanguageServer_features_haxe_codeAction_diagnostics_ParserErrorActions.getLastNonCommentChild(lastChild);
			if(newLast == null) {
				return lastChild;
			}
			lastChild = newLast;
		}
	}
	static getLastNonCommentChild(token) {
		let children = token.children;
		if(children == null) {
			return null;
		}
		let i = children.length;
		while(i-- > 0) {
			let child = children[i];
			if((child == null ? null : child.isComment()) == false) {
				return child;
			}
		}
		return null;
	}
	static isAnonStructure(brToken) {
		if(brToken.tok == tokentree_TokenTreeDef.BrClose) {
			let tmp = brToken.parent;
			if(tmp != null) {
				brToken = tmp;
			} else {
				return false;
			}
		}
		let first;
		let _v_ = brToken;
		let tmp = _v_ == null ? null : _v_.getFirstChild();
		if(tmp != null) {
			first = tmp;
		} else {
			return false;
		}
		let tmp1 = first.getFirstChild();
		if(tmp1 == null) {
			return false;
		}
		let tmp2;
		if(tmp1.tok._hx_index == 12) {
			let _v_ = tmp1.nextSibling;
			let _g = _v_ == null ? null : _v_.tok;
			tmp2 = !(_g == null ? false : _g._hx_index == 10);
		} else {
			tmp2 = false;
		}
		if(tmp2) {
			return true;
		}
		return false;
	}
	static isAnonStructureField(token) {
		let tmp = token.parent;
		if(tmp == null) {
			return false;
		}
		if(!haxeLanguageServer_features_haxe_codeAction_diagnostics_ParserErrorActions.isAnonStructure(tmp)) {
			return false;
		}
		let tmp1 = token.getFirstChild();
		if(tmp1 == null) {
			return false;
		}
		if(tmp1.tok._hx_index == 12) {
			return true;
		} else {
			return false;
		}
	}
}
haxeLanguageServer_features_haxe_codeAction_diagnostics_ParserErrorActions.__name__ = "haxeLanguageServer.features.haxe.codeAction.diagnostics.ParserErrorActions";
class haxeLanguageServer_features_haxe_codeAction_diagnostics_RemovableCodeActions {
	static createRemovableCodeActions(context,params,diagnostic) {
		if(params.context.only != null && !params.context.only.includes("quickfix")) {
			return [];
		}
		let _v_ = context.diagnostics.getArguments(params.textDocument.uri,3,diagnostic.range);
		let range = _v_ == null ? null : _v_.range;
		if(range == null) {
			return [];
		}
		let uri = params.textDocument.uri;
		let value = context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		let changes = { };
		if(doc1 != null) {
			changes[doc1.uri] = [{ range : range, newText : ""}];
		}
		return [{ title : "Remove", kind : "quickfix", edit : { changes : changes}, diagnostics : [diagnostic], isPreferred : true}];
	}
}
haxeLanguageServer_features_haxe_codeAction_diagnostics_RemovableCodeActions.__name__ = "haxeLanguageServer.features.haxe.codeAction.diagnostics.RemovableCodeActions";
class haxeLanguageServer_features_haxe_codeAction_diagnostics_UnresolvedIdentifierActions {
	static createUnresolvedIdentifierActions(context,params,diagnostic) {
		if(params.context.only != null && !params.context.only.includes("quickfix")) {
			return [];
		}
		let args = context.diagnostics.getArguments(params.textDocument.uri,1,diagnostic.range);
		if(args == null) {
			return [];
		}
		let actions = [];
		let importCount = Lambda.count(args,function(a) {
			return a.kind == 0;
		});
		let _g = 0;
		while(_g < args.length) {
			let arg = args[_g];
			++_g;
			let actions1;
			switch(arg.kind) {
			case 0:
				actions1 = haxeLanguageServer_features_haxe_codeAction_diagnostics_UnresolvedIdentifierActions.createUnresolvedImportActions(context,params,diagnostic,arg,importCount);
				break;
			case 1:
				actions1 = haxeLanguageServer_features_haxe_codeAction_diagnostics_UnresolvedIdentifierActions.createTypoActions(context,params,diagnostic,arg);
				break;
			}
			actions = actions.concat(actions1);
		}
		return actions;
	}
	static createUnresolvedImportActions(context,params,diagnostic,arg,importCount) {
		let uri = params.textDocument.uri;
		let value = context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null) {
			return [];
		}
		let preferredStyle = context.config.user.codeGeneration.imports.style;
		let importPosition = haxeLanguageServer_helper_ImportHelper_determineImportPosition(doc1);
		let makeImportAction = function(style) {
			let path = style == "module" ? haxeLanguageServer_helper_TypeHelper.getModule(arg.name) : arg.name;
			let edits = [haxeLanguageServer_helper_ImportHelper_createImportsEdit(doc1,importPosition,[arg.name],style)];
			let uri = params.textDocument.uri;
			let value = context.documents.documents.h[uri];
			let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
			if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
				doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
			}
			let doc2 = doc;
			let changes = { };
			if(doc2 != null) {
				changes[doc2.uri] = edits;
			}
			return { title : "Import " + path, kind : "quickfix", edit : { changes : changes}, diagnostics : [diagnostic]};
		};
		let preferred = makeImportAction(preferredStyle);
		let secondary = makeImportAction(preferredStyle == "type" ? "module" : "type");
		if(importCount == 1) {
			preferred.isPreferred = true;
		}
		let actions = [preferred,secondary];
		let tmp = "Change to " + arg.name;
		let edits = [{ range : diagnostic.range, newText : arg.name}];
		let uri1 = params.textDocument.uri;
		let value1 = context.documents.documents.h[uri1];
		let doc2 = ((value1) instanceof haxeLanguageServer_documents_HaxeDocument) ? value1 : null;
		if(doc2 == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri1)) {
			doc2 = new haxeLanguageServer_documents_HaxeDocument(uri1,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri1),{ encoding : "utf8"}));
		}
		let doc3 = doc2;
		let changes = { };
		if(doc3 != null) {
			changes[doc3.uri] = edits;
		}
		actions.push({ title : tmp, kind : "quickfix", edit : { changes : changes}, diagnostics : [diagnostic]});
		return actions;
	}
	static createTypoActions(context,params,diagnostic,arg) {
		let tmp = "Change to " + arg.name;
		let edits = [{ range : diagnostic.range, newText : arg.name}];
		let uri = params.textDocument.uri;
		let value = context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		let changes = { };
		if(doc1 != null) {
			changes[doc1.uri] = edits;
		}
		return [{ title : tmp, kind : "quickfix", edit : { changes : changes}, diagnostics : [diagnostic]}];
	}
}
haxeLanguageServer_features_haxe_codeAction_diagnostics_UnresolvedIdentifierActions.__name__ = "haxeLanguageServer.features.haxe.codeAction.diagnostics.UnresolvedIdentifierActions";
class haxeLanguageServer_features_haxe_codeAction_diagnostics_UnusedImportActions {
	static createUnusedImportActions(context,params,diagnostic) {
		if(params.context.only != null && !params.context.only.includes("quickfix")) {
			return [];
		}
		let uri = params.textDocument.uri;
		let value = context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null) {
			return [];
		}
		let edits = [{ range : haxeLanguageServer_helper_DocHelper.untrimRange(doc1,diagnostic.range), newText : ""}];
		let uri1 = params.textDocument.uri;
		let value1 = context.documents.documents.h[uri1];
		let doc2 = ((value1) instanceof haxeLanguageServer_documents_HaxeDocument) ? value1 : null;
		if(doc2 == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri1)) {
			doc2 = new haxeLanguageServer_documents_HaxeDocument(uri1,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri1),{ encoding : "utf8"}));
		}
		let doc3 = doc2;
		let changes = { };
		if(doc3 != null) {
			changes[doc3.uri] = edits;
		}
		return [{ title : "Remove unused import/using", kind : "quickfix", edit : { changes : changes}, diagnostics : [diagnostic], isPreferred : true}];
	}
}
haxeLanguageServer_features_haxe_codeAction_diagnostics_UnusedImportActions.__name__ = "haxeLanguageServer.features.haxe.codeAction.diagnostics.UnusedImportActions";
class haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions {
	static createUpdateSyntaxActions(context,params,existingActions) {
		if(!haxeLanguageServer_helper_SemVer.isEqualOrGreaterThan(context.haxeServer.haxeVersion,{ major : 4, minor : 3, patch : 0, pre : null, build : null})) {
			return [];
		}
		let uri = params.textDocument.uri;
		let value = context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let tmp = doc;
		if(tmp == null) {
			return [];
		}
		let actions = [];
		let _v_ = tmp.get_tokens();
		let token = _v_ == null ? null : _v_.getTokenAtOffset(tmp.offsetAt(params.range.start));
		if(token == null) {
			return [];
		}
		let ifToken = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getSingleLineIfExpr(token);
		if(ifToken != null) {
			let ifVarRange = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getIfVarEqNullIdentRange(tmp,ifToken);
			if(ifVarRange != null) {
				let ifVarName = tmp.getText(ifVarRange);
				haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.addNullCoalPrevLineAction(context,params,actions,tmp,ifToken,ifVarName);
				haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.addNullCoalAssignAction(context,params,actions,tmp,ifToken,ifVarName);
			}
			let ifVarRange1 = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getIfVarNotEqNullIdentRange(tmp,ifToken);
			if(ifVarRange1 != null) {
				haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.addSaveNavIfNotNullAction(context,params,actions,tmp,ifToken,tmp.getText(ifVarRange1));
			}
			haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.addIfInvertAction(context,params,actions,tmp,ifToken);
		}
		let questionToken = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getNullCheckTernaryExpr(token);
		if(questionToken != null) {
			haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.addTernaryNullCheckAction(context,params,actions,tmp,questionToken);
		}
		return actions;
	}
	static addNullCoalPrevLineAction(context,params,actions,doc,ifToken,ifVarName) {
		let tmp = ifToken.previousSibling;
		if(tmp == null) {
			return;
		}
		let tmp1 = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getIdentAssignToken(doc,tmp);
		if(tmp1 == null) {
			return;
		}
		let varIdentEnd = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getIdentEnd(tmp1);
		let pos = tmp1.pos;
		let endOffset = pos.max;
		let offsetKind = 0;
		let varIdentRange = { start : doc.positionAt(pos.min,offsetKind), end : doc.positionAt(endOffset,offsetKind)};
		let pos1 = varIdentEnd.pos;
		let endOffset1 = pos1.max;
		let offsetKind1 = 0;
		if(doc.getText(haxeLanguageServer_extensions_RangeExtensions_union(varIdentRange,{ start : doc.positionAt(pos1.min,offsetKind1), end : doc.positionAt(endOffset1,offsetKind1)})) != ifVarName) {
			return;
		}
		let ranges = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getIfBodyVarAssignRanges(doc,ifToken);
		if(ranges != null) {
			if(ifVarName != doc.getText(ranges.varName)) {
				return;
			}
		}
		let valueRange;
		let tmp2 = ranges == null ? null : ranges.value;
		let tmp3 = tmp2 != null ? tmp2 : haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getIfBodyDeadEndRange(doc,ifToken);
		if(tmp3 != null) {
			valueRange = tmp3;
		} else {
			return;
		}
		let value = doc.getText(valueRange);
		if(!value.endsWith(";")) {
			value += ";";
		}
		let prevValueToken;
		let _v_ = tmp1.getFirstChild();
		let tmp4 = _v_ == null ? null : _v_.getFirstChild();
		if(tmp4 != null) {
			prevValueToken = tmp4;
		} else {
			return;
		}
		let pos2 = prevValueToken.getPos();
		let endOffset2 = pos2.max;
		let offsetKind2 = 0;
		let prevValueRange = { start : doc.positionAt(pos2.min,offsetKind2), end : doc.positionAt(endOffset2,offsetKind2)};
		let prevValue = doc.getText(prevValueRange);
		let pos3 = ifToken.getPos();
		let endOffset3 = pos3.max;
		let offsetKind3 = 0;
		let replaceRange = haxeLanguageServer_extensions_RangeExtensions_union(prevValueRange,{ start : doc.positionAt(pos3.min,offsetKind3), end : doc.positionAt(endOffset3,offsetKind3)});
		let edits = [{ range : replaceRange, newText : "" + prevValue + " ?? " + haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.multilineIndent(doc,context,value,replaceRange.start)}];
		let uri = params.textDocument.uri;
		let value1 = context.documents.documents.h[uri];
		let doc1 = ((value1) instanceof haxeLanguageServer_documents_HaxeDocument) ? value1 : null;
		if(doc1 == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc1 = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc2 = doc1;
		let changes = { };
		if(doc2 != null) {
			changes[doc2.uri] = edits;
		}
		actions.push({ title : "Change to ?? operator", kind : "quickfix", edit : { changes : changes}});
	}
	static multilineIndent(doc,context,value,pos,isSameLine) {
		if(isSameLine == null) {
			isSameLine = true;
		}
		if(!value.includes("\n") && isSameLine) {
			return value;
		}
		value = haxeLanguageServer_helper_FormatterHelper.formatText(doc,context,value,tokentree_TokenTreeEntryPoint.ExpressionLevel);
		let line = doc.lineAt(pos.line);
		let count = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.lineIndentationCount(line);
		if(count == 0) {
			return value;
		}
		let prefix = StringTools.rpad("",line.charAt(0),count);
		let i = 0;
		let _g = [];
		let x = $getIterator(value.split("\n"));
		while(x.hasNext()) {
			let x1 = x.next();
			let i1 = i++;
			_g.push(isSameLine && i1 == 0 ? x1 : "" + prefix + x1);
		}
		value = _g.join("\n");
		return value;
	}
	static lineIndentationCount(s) {
		let spaces = 0;
		let _g_offset = 0;
		while(_g_offset < s.length) {
			let _g_key = _g_offset;
			s.charCodeAt(_g_offset++);
			if(!StringTools.isSpace(s,_g_key)) {
				break;
			}
			++spaces;
		}
		return spaces;
	}
	static addNullCoalAssignAction(context,params,actions,doc,ifToken,ifVarName) {
		let tmp = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getIfBodyVarAssignRanges(doc,ifToken);
		if(tmp == null) {
			return;
		}
		if(ifVarName != doc.getText(tmp.varName)) {
			return;
		}
		let value = doc.getText(tmp.value);
		if(!value.endsWith(";")) {
			value += ";";
		}
		let pos = ifToken.getPos();
		let endOffset = pos.max;
		let offsetKind = 0;
		let replaceRange = { start : doc.positionAt(pos.min,offsetKind), end : doc.positionAt(endOffset,offsetKind)};
		let edits = [{ range : replaceRange, newText : "" + ifVarName + " ??= " + haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.multilineIndent(doc,context,value,replaceRange.start)}];
		let uri = params.textDocument.uri;
		let value1 = context.documents.documents.h[uri];
		let doc1 = ((value1) instanceof haxeLanguageServer_documents_HaxeDocument) ? value1 : null;
		if(doc1 == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc1 = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc2 = doc1;
		let changes = { };
		if(doc2 != null) {
			changes[doc2.uri] = edits;
		}
		actions.push({ title : "Change to ??= operator", kind : "quickfix", edit : { changes : changes}});
	}
	static addSaveNavIfNotNullAction(context,params,actions,doc,ifToken,ifVarName) {
		if(haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getElseBody(ifToken) != null) {
			return;
		}
		let tmp = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getSingleLineIfBodyExpr(ifToken);
		if(tmp == null) {
			return;
		}
		let pos = tmp.getPos();
		let endOffset = pos.max;
		let offsetKind = 0;
		let varName = doc.getText({ start : doc.positionAt(pos.min,offsetKind), end : doc.positionAt(endOffset,offsetKind)});
		if(!varName.startsWith(ifVarName)) {
			return;
		}
		let accessPart = StringTools.replace(varName,ifVarName,"");
		if(!accessPart.startsWith("?.")) {
			if(!accessPart.startsWith(".")) {
				return;
			}
			accessPart = "?" + accessPart;
		}
		if(!accessPart.endsWith(";")) {
			accessPart += ";";
		}
		let pos1 = ifToken.getPos();
		let endOffset1 = pos1.max;
		let offsetKind1 = 0;
		let replaceRange = { start : doc.positionAt(pos1.min,offsetKind1), end : doc.positionAt(endOffset1,offsetKind1)};
		let value = StringTools.rtrim(haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.multilineIndent(doc,context,accessPart,replaceRange.start));
		let uri = params.textDocument.uri;
		let value1 = context.documents.documents.h[uri];
		let doc1 = ((value1) instanceof haxeLanguageServer_documents_HaxeDocument) ? value1 : null;
		if(doc1 == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc1 = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc2 = doc1;
		let changes = { };
		if(doc2 != null) {
			changes[doc2.uri] = [{ range : replaceRange, newText : "" + ifVarName + value}];
		}
		actions.push({ title : "Change to ?. operator", kind : "quickfix", edit : { changes : changes}});
	}
	static getElseBody(ifToken) {
		let tmp = ifToken.getFirstChild();
		if(tmp == null) {
			return null;
		}
		let tmp1 = tmp.nextSibling;
		if(tmp1 == null) {
			return null;
		}
		let tmp2 = tmp1.nextSibling;
		if(tmp2 == null) {
			return null;
		}
		if(!tmp2.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse))) {
			return null;
		}
		return tmp2.getFirstChild();
	}
	static addIfInvertAction(context,params,actions,doc,ifToken) {
		let deadEndText;
		if(haxeLanguageServer_features_haxe_codeAction_TokenTreeUtils.isInFunctionScope(ifToken)) {
			let tmp = ifToken.parent;
			if(tmp == null) {
				return;
			}
			let returnToken = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getBlockReturn(tmp);
			if(returnToken != null) {
				let pos = returnToken.getPos();
				let endOffset = pos.max;
				let offsetKind = 0;
				deadEndText = doc.getText({ start : doc.positionAt(pos.min,offsetKind), end : doc.positionAt(endOffset,offsetKind)});
			} else {
				deadEndText = "return;";
			}
		} else if(haxeLanguageServer_features_haxe_codeAction_TokenTreeUtils.isInLoopScope(ifToken)) {
			deadEndText = "continue;";
		} else {
			return;
		}
		if(haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.filterNextSibling(ifToken,function(sib) {
			if(sib.isComment()) {
				return false;
			}
			let _g = sib.tok;
			let sibFilter;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 10:case 24:
					sibFilter = true;
					break;
				default:
					sibFilter = false;
				}
			} else {
				sibFilter = false;
			}
			if(sibFilter) {
				return false;
			}
			if(sib.tok._hx_index == 19) {
				return false;
			}
			return true;
		}) != null) {
			return;
		}
		let tmp = ifToken.getFirstChild();
		if(tmp == null) {
			return;
		}
		let tmp1 = tmp.nextSibling;
		if(tmp1 == null) {
			return;
		}
		let pos = ifToken.getPos();
		let endOffset = pos.max;
		let offsetKind = 0;
		let replaceRange = { start : doc.positionAt(pos.min,offsetKind), end : doc.positionAt(endOffset,offsetKind)};
		let elseBody = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getElseBody(ifToken);
		if(elseBody != null) {
			if(haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getBlockReturn(elseBody) != null) {
				deadEndText = "";
			}
			let elseBodyText = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getBlockText(doc,elseBody) + ("\n" + deadEndText);
			elseBodyText = "{\n" + elseBodyText + "\n}";
			elseBodyText = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.multilineIndent(doc,context,StringTools.trim(elseBodyText),replaceRange.start);
			elseBodyText = StringTools.rtrim(elseBodyText);
			deadEndText = elseBodyText;
		}
		let cond = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.invertCondition(tmp);
		let ifBodyText = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getBlockText(doc,tmp1);
		ifBodyText = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.multilineIndent(doc,context,StringTools.trim(ifBodyText),replaceRange.start,false);
		ifBodyText = StringTools.rtrim(ifBodyText);
		if(ifBodyText.length > 0) {
			ifBodyText = "\n" + ifBodyText;
		}
		let uri = params.textDocument.uri;
		let value = context.documents.documents.h[uri];
		let doc1 = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc1 == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc1 = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc2 = doc1;
		let changes = { };
		if(doc2 != null) {
			changes[doc2.uri] = [{ range : replaceRange, newText : "if (" + cond + ") " + deadEndText + ifBodyText}];
		}
		actions.push({ title : "Invert if expression", kind : "refactor.rewrite", edit : { changes : changes}});
	}
	static getBlockReturn(brOpen) {
		let maybeReturn;
		let _v_ = brOpen.getLastChild();
		let tmp = _v_ == null ? null : _v_.previousSibling;
		if(tmp != null) {
			maybeReturn = tmp;
		} else {
			return null;
		}
		let _g = maybeReturn.tok;
		let tmp1;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 10:case 24:
				tmp1 = true;
				break;
			default:
				tmp1 = false;
			}
		} else {
			tmp1 = false;
		}
		if(!tmp1) {
			return null;
		}
		return maybeReturn;
	}
	static getBlockText(doc,block) {
		let pos = block.getPos();
		let endOffset = pos.max;
		let offsetKind = 0;
		let blockText = doc.getText({ start : doc.positionAt(pos.min,offsetKind), end : doc.positionAt(endOffset,offsetKind)});
		if(block.tok == tokentree_TokenTreeDef.BrOpen && !haxeLanguageServer_features_haxe_codeAction_TokenTreeUtils.isAnonStructure(block)) {
			let reg = new EReg("\\{((.|\n)*)\\}","g");
			if(reg.match(blockText)) {
				blockText = reg.matched(1);
			}
		}
		return StringTools.trim(blockText);
	}
	static filterNextSibling(token,filter) {
		let token1;
		if(token != null) {
			token1 = token;
		} else {
			return null;
		}
		while(true) {
			let tmp = token1.nextSibling;
			if(tmp != null) {
				token1 = tmp;
			} else {
				return null;
			}
			if(!filter(tmp)) {
				continue;
			}
			return tmp;
		}
	}
	static invertCondition(pOpen) {
		let buf = "";
		let current;
		let tmp = pOpen.getFirstChild();
		if(tmp != null) {
			current = tmp;
		} else {
			return "";
		}
		let tmp1 = pOpen.getLastChild();
		if(tmp1 == null) {
			return "";
		}
		let waitBrs = [];
		let expr = "";
		let isInverted = false;
		while(current != tmp1) {
			if(waitBrs.length > 0) {
				if(current.matches(waitBrs[waitBrs.length - 1])) {
					waitBrs.pop();
				}
				let expr1;
				switch(current.tok._hx_index) {
				case 6:
					expr1 = " " + current.toString() + " ";
					break;
				case 12:case 14:case 22:
					expr1 = " " + current.toString() + " ";
					break;
				case 16:case 18:case 20:
					let close = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getClosingBracketTok(current.tok);
					if(close != null) {
						waitBrs.push(close);
					}
					expr1 = current.toString();
					break;
				default:
					expr1 = current.toString();
				}
				expr += expr1;
				let tmp = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.flatNextToken(current);
				if(tmp != null) {
					current = tmp;
				} else {
					return buf + expr;
				}
				continue;
			}
			let _g = current.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 38:
					expr += isInverted ? "true" : "false";
					isInverted = true;
					break;
				case 39:
					expr += isInverted ? "false" : "true";
					isInverted = true;
					break;
				default:
					expr += current.toString();
				}
				break;
			case 5:
				if(_g.op._hx_index == 2) {
					expr += isInverted ? "!" : "";
					isInverted = true;
				} else {
					expr += current.toString();
				}
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 5:
					buf += "" + expr + " " + (isInverted ? "==" : "!=") + " ";
					expr = "";
					isInverted = true;
					break;
				case 6:
					buf += "" + expr + " " + (isInverted ? "!=" : "==") + " ";
					expr = "";
					isInverted = true;
					break;
				case 7:
					buf += "" + expr + " " + (isInverted ? ">" : "<=") + " ";
					expr = "";
					isInverted = true;
					break;
				case 8:
					buf += "" + expr + " " + (isInverted ? ">=" : "<") + " ";
					expr = "";
					isInverted = true;
					break;
				case 9:
					buf += "" + expr + " " + (isInverted ? "<" : ">=") + " ";
					expr = "";
					isInverted = true;
					break;
				case 10:
					buf += "" + expr + " " + (isInverted ? "<=" : ">") + " ";
					expr = "";
					isInverted = true;
					break;
				case 14:
					buf += "" + (isInverted ? expr : "!" + expr) + " || ";
					expr = "";
					isInverted = false;
					break;
				case 15:
					buf += "" + (isInverted ? expr : "!" + expr) + " && ";
					expr = "";
					isInverted = false;
					break;
				default:
					expr += " " + current.toString() + " ";
				}
				break;
			case 16:case 18:case 20:
				let close = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getClosingBracketTok(current.tok);
				if(close != null) {
					waitBrs.push(close);
				}
				expr += current.toString();
				break;
			default:
				expr += current.toString();
			}
			let tmp = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.flatNextToken(current);
			if(tmp != null) {
				current = tmp;
			} else {
				return buf + expr;
			}
		}
		return "" + buf + (isInverted ? expr : "!" + expr);
	}
	static getClosingBracketTok(tok) {
		switch(tok._hx_index) {
		case 16:
			return tokentree_TokenTreeDef.BkClose;
		case 18:
			return tokentree_TokenTreeDef.BrClose;
		case 20:
			return tokentree_TokenTreeDef.PClose;
		default:
			return null;
		}
	}
	static flatNextToken(current) {
		let child = current.getFirstChild();
		if(child != null) {
			return child;
		}
		while(true) {
			let next = current.nextSibling;
			if(next != null) {
				return next;
			}
			let tmp = current.parent;
			if(tmp != null) {
				current = tmp;
			} else {
				return null;
			}
		}
	}
	static addTernaryNullCheckAction(context,params,actions,doc,questionToken) {
		let binopToken;
		let _v_ = questionToken.parent;
		let tmp = _v_ == null ? null : _v_.parent;
		if(tmp != null) {
			binopToken = tmp;
		} else {
			return;
		}
		let tmp1 = binopToken.parent;
		if(tmp1 == null) {
			return;
		}
		let ifIdentStart = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.preDotToken(tmp1);
		let tmp2 = questionToken.getFirstChild();
		if(tmp2 == null) {
			return;
		}
		let tmp3 = tmp2.nextSibling;
		if(tmp3 == null) {
			return;
		}
		let tmp4 = tmp3.getFirstChild();
		if(tmp4 == null) {
			return;
		}
		let tmp5 = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getLastNonCommaToken(tmp4);
		if(tmp5 == null) {
			return;
		}
		let pos = ifIdentStart.pos;
		let endOffset = pos.max;
		let offsetKind = 0;
		let ifIdentRange = { start : doc.positionAt(pos.min,offsetKind), end : doc.positionAt(endOffset,offsetKind)};
		let pos1 = tmp1.pos;
		let endOffset1 = pos1.max;
		let offsetKind1 = 0;
		let ifIdentRange1 = haxeLanguageServer_extensions_RangeExtensions_union(ifIdentRange,{ start : doc.positionAt(pos1.min,offsetKind1), end : doc.positionAt(endOffset1,offsetKind1)});
		let pos2 = tmp2.getPos();
		let endOffset2 = pos2.max;
		let offsetKind2 = 0;
		let firstRange = { start : doc.positionAt(pos2.min,offsetKind2), end : doc.positionAt(endOffset2,offsetKind2)};
		let pos3 = tmp4.pos;
		let endOffset3 = pos3.max;
		let offsetKind3 = 0;
		let secondRange = { start : doc.positionAt(pos3.min,offsetKind3), end : doc.positionAt(endOffset3,offsetKind3)};
		let pos4 = tmp5.pos;
		let endOffset4 = pos4.max;
		let offsetKind4 = 0;
		let secondRange1 = haxeLanguageServer_extensions_RangeExtensions_union(secondRange,{ start : doc.positionAt(pos4.min,offsetKind4), end : doc.positionAt(endOffset4,offsetKind4)});
		let isEq = binopToken.matches(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpEq));
		let condText = doc.getText(ifIdentRange1);
		let firstText = doc.getText(firstRange);
		let secondText = doc.getText(secondRange1);
		if(isEq) {
			if(condText != secondText) {
				return;
			}
		} else if(condText != firstText) {
			return;
		}
		let pos5 = ifIdentStart.getPos();
		let endOffset5 = pos5.max;
		let offsetKind5 = 0;
		let replaceRange = { start : doc.positionAt(pos5.min,offsetKind5), end : doc.positionAt(endOffset5,offsetKind5)};
		let value = isEq ? firstText : secondText;
		if(!value.endsWith(";")) {
			value += ";";
		}
		let edits = [{ range : replaceRange, newText : "" + condText + " ?? " + haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.multilineIndent(doc,context,value,replaceRange.start)}];
		let uri = params.textDocument.uri;
		let value1 = context.documents.documents.h[uri];
		let doc1 = ((value1) instanceof haxeLanguageServer_documents_HaxeDocument) ? value1 : null;
		if(doc1 == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc1 = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc2 = doc1;
		let changes = { };
		if(doc2 != null) {
			changes[doc2.uri] = edits;
		}
		actions.push({ title : "Change to ?? operator", kind : "quickfix", edit : { changes : changes}});
	}
	static getIdentAssignToken(doc,ident) {
		let _g = ident.tok;
		let tmp;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 2:case 42:
				tmp = true;
				break;
			default:
				tmp = false;
			}
		} else {
			tmp = false;
		}
		if(tmp) {
			let tmp = ident.getFirstChild();
			if(tmp != null) {
				ident = tmp;
			} else {
				return null;
			}
		}
		let tmp1 = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getIdentEnd(ident).getFirstChild();
		if(tmp1 == null) {
			return null;
		}
		let _g1 = tmp1.tok;
		if(_g1._hx_index == 6) {
			if(_g1.op._hx_index == 4) {
				return ident;
			} else {
				return null;
			}
		} else {
			return null;
		}
	}
	static getIfBodyDeadEndRange(doc,ifToken) {
		let tmp = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getSingleLineIfBodyExpr(ifToken);
		if(tmp == null) {
			return null;
		}
		let _g = tmp.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 8:case 9:case 10:case 24:
				let pos = tmp.getPos();
				let endOffset = pos.max;
				let offsetKind = 0;
				return { start : doc.positionAt(pos.min,offsetKind), end : doc.positionAt(endOffset,offsetKind)};
			default:
				return null;
			}
		} else {
			return null;
		}
	}
	static getSingleLineIfExpr(token) {
		if(token == null) {
			return null;
		}
		let _g = token.tok;
		if(_g._hx_index == 1 && _g.k._hx_index == 3) {
			return token;
		}
		token = token.parent;
		if(token == null) {
			return null;
		}
		let _g1 = token.tok;
		if(_g1._hx_index == 1 && _g1.k._hx_index == 3) {
			return token;
		}
		token = token.parent;
		if(token == null) {
			return null;
		}
		let _g2 = token.tok;
		if(_g2._hx_index == 1 && _g2.k._hx_index == 3) {
			return token;
		}
		token = token.parent;
		if(token == null) {
			return null;
		}
		let _g3 = token.tok;
		if(_g3._hx_index == 1 && _g3.k._hx_index == 3) {
			return token;
		}
		token = token.parent;
		if(token == null) {
			return null;
		}
		let _g4 = token.tok;
		if(_g4._hx_index == 1 && _g4.k._hx_index == 3) {
			return token;
		}
		token = token.parent;
		if(token == null) {
			return null;
		}
		let _g5 = token.tok;
		if(_g5._hx_index == 1 && _g5.k._hx_index == 3) {
			return token;
		}
		token = token.parent;
		if(token == null) {
			return null;
		}
		let _g6 = token.tok;
		if(_g6._hx_index == 1 && _g6.k._hx_index == 3) {
			return token;
		}
		token = token.parent;
		if(token == null) {
			return null;
		}
		let _g7 = token.tok;
		if(_g7._hx_index == 1 && _g7.k._hx_index == 3) {
			return token;
		}
		token = token.parent;
		if(token == null) {
			return null;
		}
		let _g8 = token.tok;
		if(_g8._hx_index == 1 && _g8.k._hx_index == 3) {
			return token;
		}
		token = token.parent;
		if(token == null) {
			return null;
		}
		let _g9 = token.tok;
		if(_g9._hx_index == 1 && _g9.k._hx_index == 3) {
			return token;
		}
		token = token.parent;
		return null;
	}
	static getNullCheckTernaryExpr(token) {
		let _g = 0;
		while(_g < 10) {
			++_g;
			if(token == null) {
				return null;
			}
			let _g1 = token.tok;
			let tmp;
			if(_g1._hx_index == 6) {
				switch(_g1.op._hx_index) {
				case 5:case 6:
					tmp = true;
					break;
				default:
					tmp = false;
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				let tmp = token.getFirstChild();
				if(tmp == null) {
					return null;
				}
				if(tmp.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdNull)) == false) {
					return null;
				}
				let tmp1 = tmp.getFirstChild();
				if(tmp1 == null) {
					return null;
				}
				let _v_ = tmp1;
				if((_v_ == null ? null : _v_.matches(tokentree_TokenTreeDef.Question)) == false) {
					return null;
				}
				return tmp1;
			}
			token = token.parent;
		}
		return null;
	}
	static getIfVarEqNullIdentRange(doc,ifToken) {
		let tmp = ifToken.getFirstChild();
		if(tmp == null) {
			return null;
		}
		let tmp1 = tmp.getFirstChild();
		if(tmp1 == null) {
			return null;
		}
		let identEnd = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getIdentEnd(tmp1);
		let tmp2 = identEnd.getFirstChild();
		if(tmp2 == null) {
			return null;
		}
		let tmp3 = tmp2.getFirstChild();
		if(tmp3 == null) {
			return null;
		}
		let _g = tmp2.tok;
		let _g1 = tmp3.tok;
		if(_g._hx_index == 6) {
			if(_g.op._hx_index == 5) {
				if(_g1._hx_index == 1) {
					if(_g1.k._hx_index == 37) {
						let pos = tmp1.pos;
						let endOffset = pos.max;
						let offsetKind = 0;
						let tmp = { start : doc.positionAt(pos.min,offsetKind), end : doc.positionAt(endOffset,offsetKind)};
						let pos1 = identEnd.pos;
						let endOffset1 = pos1.max;
						let offsetKind1 = 0;
						return haxeLanguageServer_extensions_RangeExtensions_union(tmp,{ start : doc.positionAt(pos1.min,offsetKind1), end : doc.positionAt(endOffset1,offsetKind1)});
					} else {
						return null;
					}
				} else {
					return null;
				}
			} else {
				return null;
			}
		} else {
			return null;
		}
	}
	static getIfVarNotEqNullIdentRange(doc,ifToken) {
		let tmp = ifToken.getFirstChild();
		if(tmp == null) {
			return null;
		}
		let tmp1 = tmp.getFirstChild();
		if(tmp1 == null) {
			return null;
		}
		let identEnd = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getIdentEnd(tmp1);
		let tmp2 = identEnd.getFirstChild();
		if(tmp2 == null) {
			return null;
		}
		let tmp3 = tmp2.getFirstChild();
		if(tmp3 == null) {
			return null;
		}
		let _g = tmp2.tok;
		let _g1 = tmp3.tok;
		if(_g._hx_index == 6) {
			if(_g.op._hx_index == 6) {
				if(_g1._hx_index == 1) {
					if(_g1.k._hx_index == 37) {
						let pos = tmp1.pos;
						let endOffset = pos.max;
						let offsetKind = 0;
						let tmp = { start : doc.positionAt(pos.min,offsetKind), end : doc.positionAt(endOffset,offsetKind)};
						let pos1 = identEnd.pos;
						let endOffset1 = pos1.max;
						let offsetKind1 = 0;
						return haxeLanguageServer_extensions_RangeExtensions_union(tmp,{ start : doc.positionAt(pos1.min,offsetKind1), end : doc.positionAt(endOffset1,offsetKind1)});
					} else {
						return null;
					}
				} else {
					return null;
				}
			} else {
				return null;
			}
		} else {
			return null;
		}
	}
	static getIfBodyVarAssignRanges(doc,ifToken) {
		let tmp = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getSingleLineIfBodyExpr(ifToken);
		if(tmp == null) {
			return null;
		}
		let ident2End = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getIdentEnd(tmp);
		let tmp1 = ident2End.getFirstChild();
		if(tmp1 == null) {
			return null;
		}
		let tmp2 = tmp1.getFirstChild();
		if(tmp2 == null) {
			return null;
		}
		let _g = tmp1.tok;
		if(_g._hx_index == 6) {
			if(_g.op._hx_index == 4) {
				let pos = tmp.pos;
				let endOffset = pos.max;
				let offsetKind = 0;
				let tmp1 = { start : doc.positionAt(pos.min,offsetKind), end : doc.positionAt(endOffset,offsetKind)};
				let pos1 = ident2End.pos;
				let endOffset1 = pos1.max;
				let offsetKind1 = 0;
				let tmp3 = haxeLanguageServer_extensions_RangeExtensions_union(tmp1,{ start : doc.positionAt(pos1.min,offsetKind1), end : doc.positionAt(endOffset1,offsetKind1)});
				let pos2 = tmp2.getPos();
				let endOffset2 = pos2.max;
				let offsetKind2 = 0;
				return { varName : tmp3, value : { start : doc.positionAt(pos2.min,offsetKind2), end : doc.positionAt(endOffset2,offsetKind2)}};
			} else {
				return null;
			}
		} else {
			return null;
		}
	}
	static getSingleLineIfBodyExpr(ifToken) {
		let ident;
		let _v_ = tokentree_TokenTreeAccessHelper.child(ifToken,1);
		let tmp = _v_ == null ? null : _v_;
		if(tmp != null) {
			ident = tmp;
		} else {
			return null;
		}
		if(ident.matches(tokentree_TokenTreeDef.BrOpen)) {
			let tmp = ident.children;
			if(tmp == null) {
				return null;
			}
			if(tmp.length > 2) {
				return null;
			}
			let tmp1 = ident.getFirstChild();
			if(tmp1 != null) {
				ident = tmp1;
			} else {
				return null;
			}
		}
		return ident;
	}
	static getIdentEnd(ident) {
		while(true) {
			let tmp = ident.getFirstChild();
			if(tmp == null) {
				return ident;
			}
			let _g = tmp.tok;
			let tmp1;
			switch(_g._hx_index) {
			case 2:
				tmp1 = _g.c._hx_index == 3;
				break;
			case 11:case 13:case 22:
				tmp1 = true;
				break;
			default:
				tmp1 = false;
			}
			if(tmp1) {
				ident = tmp;
				continue;
			}
			return ident;
		}
	}
	static preDotToken(token) {
		while(true) {
			let tmp = token.parent;
			if(tmp == null) {
				return token;
			}
			let _g = tmp.tok;
			switch(_g._hx_index) {
			case 1:
				if(_g.k._hx_index == 22) {
					return tmp;
				}
				break;
			case 11:case 13:
				let tmp1 = tmp.parent;
				if(tmp1 == null) {
					return token;
				}
				if(!token.isCIdent()) {
					return token;
				}
				token = tmp1;
				continue;
			default:
			}
			return token;
		}
	}
	static getLastToken(token) {
		if(token == null) {
			return null;
		}
		return tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
	}
	static getLastNonCommaToken(token) {
		while(true) {
			let last = haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.getLastToken(token);
			if(last == null) {
				return last;
			}
			if(last.tok == tokentree_TokenTreeDef.Comma || last.tok == tokentree_TokenTreeDef.Semicolon) {
				let tmp = last.previousSibling;
				if(tmp == null) {
					return last.parent;
				}
				token = tmp;
				continue;
			}
			return last;
		}
	}
}
haxeLanguageServer_features_haxe_codeAction_diagnostics_UpdateSyntaxActions.__name__ = "haxeLanguageServer.features.haxe.codeAction.diagnostics.UpdateSyntaxActions";
class haxeLanguageServer_features_haxe_completion_CompletionFeature {
	constructor(context) {
		this.context = context;
		let _v_ = this.context.capabilities.textDocument;
		let completion = _v_ == null ? null : _v_.completion;
		let _v_1 = completion;
		this.contextSupport = (_v_1 == null ? null : _v_1.contextSupport) == true;
		let _v_2 = completion;
		let _v_3 = _v_2 == null ? null : _v_2.completionItem;
		let value = _v_3 == null ? null : _v_3.documentationFormat;
		this.markdownSupport = (value == null ? null : value.includes("markdown")) == true;
		let _v_4 = completion;
		let _v_5 = _v_4 == null ? null : _v_4.completionItem;
		this.snippetSupport = (_v_5 == null ? null : _v_5.snippetSupport) == true;
		let _v_6 = completion;
		let _v_7 = _v_6 == null ? null : _v_6.completionItem;
		this.commitCharactersSupport = (_v_7 == null ? null : _v_7.commitCharactersSupport) == true;
		let _v_8 = completion;
		let _v_9 = _v_8 == null ? null : _v_8.completionItem;
		let _v_10 = _v_9 == null ? null : _v_9.tagSupport;
		let value1 = _v_10 == null ? null : _v_10.valueSet;
		this.deprecatedSupport = (value1 == null ? null : value1.includes(1)) == true;
		this.expectedTypeCompletion = new haxeLanguageServer_features_haxe_completion_ExpectedTypeCompletion(context);
		this.postfixCompletion = new haxeLanguageServer_features_haxe_completion_PostfixCompletion(context);
		this.snippetCompletion = new haxeLanguageServer_features_haxe_completion_SnippetCompletion(context);
		this.printer = new haxeLanguageServer_protocol_DisplayPrinter(false,haxeLanguageServer_protocol_PathPrinting.Qualified,{ argumentTypeHints : true, returnTypeHint : "non-void", useArrowSyntax : false, placeOpenBraceOnNewLine : false, explicitPublic : true, explicitPrivate : true, explicitNull : true});
		this.legacy = new haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy(context,this.contextSupport,$bind(this,this.formatDocumentation));
	}
	onCompletion(params,token,resolve,reject) {
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null || !haxeLanguageServer_extensions_DocumentUriExtensions_isFile(uri)) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		let offset = doc1.offsetAt(params.position);
		let textBefore = doc1.content.substring(0,offset);
		let pos = params.position;
		let currentToken = new haxeLanguageServer_tokentree_PositionAnalyzer(doc1).resolve({ line : pos.line, character : pos.character + -(textBefore.length - StringTools.rtrim(textBefore).length)});
		if(this.contextSupport && !this.isValidCompletionPosition(currentToken,doc1,params,textBefore)) {
			resolve({ items : [], isIncomplete : false});
			return;
		}
		(this.context.haxeServer.supports("display/completion") ? $bind(this,this.handleJsonRpc) : ($_=this.legacy,$bind($_,$_.handle)))(params,token,resolve,reject,doc1,offset,textBefore,currentToken);
	}
	isValidCompletionPosition(token,doc,params,text) {
		if(token == null) {
			return true;
		}
		let inComment;
		switch(token.tok._hx_index) {
		case 7:
			inComment = true;
			break;
		case 8:
			inComment = true;
			break;
		default:
			inComment = false;
		}
		if(inComment) {
			return false;
		}
		if(params.context == null) {
			return true;
		}
		let _g = params.context.triggerCharacter;
		if(_g == null) {
			return true;
		} else {
			switch(_g) {
			case " ":
				if(!haxeLanguageServer_features_haxe_completion_CompletionFeature.autoTriggerOnSpacePattern.match(text)) {
					return false;
				} else {
					return true;
				}
				break;
			case "$":
				if(!this.isInterpolationPosition(token,doc,params.position,text)) {
					return false;
				} else {
					return true;
				}
				break;
			case ">":
				if(!StringTools.trim(text).endsWith("->")) {
					return false;
				} else {
					return true;
				}
				break;
			default:
				return true;
			}
		}
	}
	isInterpolationPosition(token,doc,pos,text) {
		let inMacroReification = tokentree_TokenTreeAccessHelper.findParent(token,function(t) {
			return tokentree_TokenTreeAccessHelper.matches(t,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdMacro)) != null;
		}) != null;
		if(haxeLanguageServer_tokentree_PositionAnalyzer.getStringKind(token,doc,pos) != haxeLanguageServer_tokentree_StringKind.SingleQuote) {
			return inMacroReification;
		}
		if(!haxeLanguageServer_features_haxe_completion_CompletionFeature.dollarPattern.match(text)) {
			return false;
		}
		return haxeLanguageServer_features_haxe_completion_CompletionFeature.dollarPattern.matched(1).length % 2 != 0;
	}
	onCompletionResolve(item,token,resolve,reject) {
		let data = item.data;
		if(!this.context.haxeServer.supports("display/completionItem/resolve") || this.previousCompletionData == null || (data == null ? null : data.origin) == 1) {
			resolve(item);
			return;
		}
		let value = data == null ? null : data.index;
		let index;
		if(value == null) {
			throw new safety_NullPointerException("Null pointer in .sure() call");
		} else {
			index = value;
		}
		this.previousCompletionData.isResolve = true;
		let _gthis = this;
		this.context.callHaxeMethod("display/completionItem/resolve",{ index : index},token,function(result) {
			let _gthis1 = _gthis;
			let index1 = index;
			let result1 = result.item;
			let value = _gthis.previousCompletionData;
			if(value == null) {
				throw new safety_NullPointerException("Null pointer in .sure() call");
			}
			let resolvedItem = _gthis1.createCompletionItem(index1,result1,value);
			if(resolvedItem != null) {
				resolve(resolvedItem);
			} else {
				let reject1 = reject;
				let data = null;
				let this1 = { code : -32603, message : "Unable to resolve completion item."};
				if(data != null) {
					this1.data = data;
				}
				reject1(this1);
			}
			return null;
		},haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject));
	}
	handleJsonRpc(params,token,resolve,reject,doc,offset,textBefore,currentToken) {
		let wasAutoTriggered = true;
		if(params.context != null) {
			wasAutoTriggered = params.context.triggerKind == 2;
			if(params.context.triggerCharacter == "$") {
				wasAutoTriggered = false;
			}
		}
		let haxeParams = { file : haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc.uri), contents : doc.content, offset : this.context.displayOffsetConverter.characterOffsetToByteOffset(doc.content,offset), wasAutoTriggered : wasAutoTriggered, meta : [":deprecated"]};
		let tokenContext = haxeLanguageServer_tokentree_PositionAnalyzer.getContext(currentToken,doc,params.position);
		let position = params.position;
		let lineAfter = doc.getText({ start : position, end : { line : position.line + 1, character : position.character}});
		let wordPattern = new EReg("\\w*$","");
		wordPattern.match(textBefore);
		let pos = params.position;
		let characterDelta = -wordPattern.matched(0).length;
		let replaceRange = { start : { line : pos.line, character : pos.character + characterDelta}, end : params.position};
		let _gthis = this;
		let createCompletionWithoutHaxeResponse = function() {
			let _v_ = doc.get_tokens();
			let token = _v_ == null ? null : _v_.getTokenAtOffset(doc.offsetAt(replaceRange.start));
			if(token != null && token.parent != null) {
				let _g = token.parent.tok;
				if(_g._hx_index == 1) {
					if(_g.k._hx_index == 15) {
						if(token.tok == tokentree_TokenTreeDef.DblDot) {
							resolve({ items : [], isIncomplete : false});
							return;
						}
					}
				}
			}
			let keywords = _gthis.createFieldKeywordItems(tokenContext,replaceRange,lineAfter);
			if(_gthis.snippetSupport) {
				_gthis.snippetCompletion.createItems({ doc : doc, params : params, replaceRange : replaceRange, tokenContext : tokenContext},[]).then(function(result) {
					resolve({ items : keywords.concat(result.items), isIncomplete : false});
				});
			} else {
				resolve({ items : keywords, isIncomplete : false});
			}
		};
		this.context.callHaxeMethod("display/completion",haxeParams,token,function(result) {
			if(result == null) {
				createCompletionWithoutHaxeResponse();
				return null;
			}
			let mode = result.mode.kind;
			if(mode != 4 && wasAutoTriggered && StringTools.trim(textBefore).endsWith("->")) {
				resolve({ items : [], isIncomplete : false});
				return null;
			}
			let importPosition = haxeLanguageServer_helper_ImportHelper_determineImportPosition(doc);
			let indent = doc.indentAt(params.position.line);
			switch(mode) {
			case 2:
				if(result.replaceRange != null) {
					replaceRange = result.replaceRange;
				} else {
					let pathPattern = new EReg("\\w+(\\.\\w+)*$","");
					if(pathPattern.match(textBefore)) {
						let pos = params.position;
						let characterDelta = -pathPattern.matched(0).length;
						replaceRange.start = { line : pos.line, character : pos.character + characterDelta};
					}
				}
				break;
			case 3:
				if(result.replaceRange != null) {
					replaceRange = result.replaceRange;
				}
				break;
			case 4:case 5:case 6:case 10:case 13:
				let pathPattern = new EReg("\\w+(\\.\\w+)*$","");
				if(pathPattern.match(textBefore)) {
					let pos = params.position;
					let characterDelta = -pathPattern.matched(0).length;
					replaceRange.start = { line : pos.line, character : pos.character + characterDelta};
				}
				break;
			default:
			}
			let displayItems = result.items;
			let data = { replaceRange : replaceRange, mode : result.mode, doc : doc, indent : indent, lineAfter : lineAfter, params : params, importPosition : importPosition, tokenContext : tokenContext, isResolve : false};
			let items = [];
			items = items.concat(_gthis.postfixCompletion.createItems(data,displayItems));
			items = items.concat(_gthis.expectedTypeCompletion.createItems(data));
			items = items.concat(_gthis.createFieldKeywordItems(tokenContext,replaceRange,lineAfter));
			let resolveItems = function(itemsToIgnore) {
				let _g = 0;
				let _g1 = displayItems.length;
				while(_g < _g1) {
					let i = _g++;
					let displayItem = displayItems[i];
					if(itemsToIgnore.h[displayItem.__id__] == true) {
						continue;
					}
					let completionItem = _gthis.createCompletionItem(displayItem.index == null ? i : displayItem.index,displayItem,data);
					if(completionItem != null) {
						items.push(completionItem);
					}
				}
				let _g2 = [];
				let _g3 = 0;
				let _g4 = items;
				while(_g3 < _g4.length) {
					let v = _g4[_g3];
					++_g3;
					if(v != null) {
						_g2.push(v);
					}
				}
				items = _g2;
				resolve({ items : items, isIncomplete : result.isIncomplete == true});
			};
			if(_gthis.snippetSupport && mode != 8 && mode != 0) {
				_gthis.snippetCompletion.createItems(data,displayItems).then(function(result) {
					items = items.concat(result.items);
					resolveItems(result.itemsToIgnore);
				});
			} else {
				resolveItems(new haxe_ds_ObjectMap());
			}
			_gthis.previousCompletionData = data;
			return displayItems.length + " items";
		},function(error) {
			createCompletionWithoutHaxeResponse();
		});
	}
	createFieldKeywordItems(tokenContext,replaceRange,lineAfter) {
		if(!(tokenContext._hx_index == 1 && tokenContext.type.field == null)) {
			return [];
		}
		let results = [];
		let _gthis = this;
		let create = function(keyword) {
			return { label : keyword, kind : 14, textEdit : { newText : _gthis.maybeInsert(keyword," ",lineAfter), range : replaceRange}, command : haxeLanguageServer_helper_VscodeCommands_TriggerSuggest, sortText : "~~~", data : { origin : 1}};
		};
		let keywords = ["public","private","extern","final","static","dynamic","override","inline","macro"];
		if(haxeLanguageServer_helper_SemVer.isEqualOrGreaterThan(this.context.haxeServer.haxeVersion,{ major : 4, minor : 2, patch : 0, pre : null, build : null})) {
			keywords.push("abstract");
			keywords.push("overload");
		}
		let _g = 0;
		while(_g < keywords.length) results.push(create(keywords[_g++]));
		return results;
	}
	createCompletionItem(index,item,data) {
		let completionItem;
		switch(item.kind) {
		case "AnonymousStructure":
			completionItem = null;
			break;
		case "Define":
			completionItem = null;
			break;
		case "ClassField":case "EnumAbstractField":
			completionItem = this.createClassFieldCompletionItem(item,data);
			break;
		case "EnumField":
			completionItem = this.createEnumFieldCompletionItem(item,data);
			break;
		case "Expression":
			completionItem = null;
			break;
		case "Keyword":
			completionItem = this.createKeywordCompletionItem(item.args,data);
			break;
		case "Literal":
			completionItem = this.createLiteralCompletionItem(item,data);
			break;
		case "Local":
			completionItem = this.createLocalCompletionItem(item,data);
			break;
		case "Metadata":
			completionItem = item.args.internal ? null : { label : item.args.name, kind : 3};
			break;
		case "Module":
			completionItem = this.createModuleCompletionItem(item.args,data);
			break;
		case "Package":
			completionItem = this.createPackageCompletionItem(item.args,data);
			break;
		case "Type":
			completionItem = this.createTypeCompletionItem(item.args,data);
			break;
		case "TypeParameter":
			completionItem = { label : item.args.name, kind : 25};
			break;
		}
		if(completionItem == null) {
			return null;
		}
		if(completionItem.textEdit == null && data.replaceRange != null) {
			completionItem.textEdit = { range : data.replaceRange, newText : completionItem.label};
		}
		if(completionItem.documentation == null) {
			completionItem.documentation = this.formatDocumentation(haxeLanguageServer_protocol_Extensions_getDocumentation(item));
		}
		if(completionItem.detail != null) {
			completionItem.detail = StringTools.rtrim(completionItem.detail);
		}
		if(this.commitCharactersSupport) {
			let mode = data.mode.kind;
			if(item.type != null && item.type.kind == "TFun" && mode != 11 || mode == 10) {
				completionItem.commitCharacters = ["("];
			}
		}
		if(completionItem.sortText == null) {
			completionItem.sortText = "";
		}
		completionItem.sortText += StringTools.lpad(Std.string(index + 1),"0",10);
		completionItem.data = { origin : 0, index : index};
		return completionItem;
	}
	createClassFieldCompletionItem(item,data) {
		let occurrence = item.args;
		let concreteType = item.type;
		let field = occurrence.field;
		let resolution = occurrence.resolution;
		let printedOrigin = this.printer.printClassFieldOrigin(occurrence.origin,item.kind,"'");
		if(concreteType == null || haxeLanguageServer_protocol_Extensions_hasMeta(field.meta,":noCompletion")) {
			return null;
		}
		if(data.mode.kind == 12) {
			return this.createOverrideCompletionItem(item,data,printedOrigin);
		}
		let field1 = field.name;
		let item1 = this.getKindForField(field,item.kind);
		let overloads = occurrence.field.overloads == null ? 0 : occurrence.field.overloads.length;
		let detail = this.printer.printClassFieldDefinition(occurrence,concreteType,item.kind == "EnumAbstractField");
		if(overloads > 0) {
			detail += " (+" + overloads + " overloads)";
		}
		let shadowed = !resolution.isQualified ? " (shadowed)" : "";
		let item2 = printedOrigin != null ? detail + "\n " + printedOrigin + shadowed : detail + "\n " + shadowed;
		let qualifier = resolution.isQualified ? "" : resolution.qualifier + ".";
		let item3;
		switch(data.mode.kind) {
		case 1:
			item3 = this.maybeInsert(field.name,": ",data.lineAfter);
			break;
		case 11:
			item3 = this.maybeInsert(field.name,":",data.lineAfter);
			break;
		default:
			item3 = field.name;
		}
		let item4 = { label : field1, kind : item1, detail : item2, textEdit : { newText : qualifier + item3, range : data.replaceRange}};
		if(data.mode.kind == 1) {
			if(haxeLanguageServer_protocol_Extensions_hasMeta(field.meta,":optional")) {
				item4.label = "?" + field.name;
				item4.filterText = field.name;
			}
		}
		this.handleDeprecated(item4,field.meta);
		return item4;
	}
	createOverrideCompletionItem(item,data,printedOrigin) {
		let concreteType = item.type;
		let field = item.args.field;
		let importConfig = this.context.config.user.codeGeneration.imports;
		if(concreteType == null || concreteType.kind != "TFun" || haxeLanguageServer_protocol_Extensions_isFinalField(field)) {
			return null;
		}
		let kind = field.kind.args;
		if(field.kind.kind == "FMethod") {
			if(kind == "MethInline" || kind == "MethMacro") {
				return null;
			}
		}
		let fieldFormatting = this.context.config.user.codeGeneration.functions.field;
		let printer = new haxeLanguageServer_protocol_DisplayPrinter(false,importConfig.enableAutoImports ? haxeLanguageServer_protocol_PathPrinting.Shadowed : haxeLanguageServer_protocol_PathPrinting.Qualified,fieldFormatting);
		let item1 = { label : field.name, kind : this.getKindForField(field,item.kind), textEdit : { newText : printer.printOverrideDefinition(field,concreteType,data.indent,true), range : data.replaceRange}, insertTextFormat : 2, detail : "Auto-generate override" + (printedOrigin == null ? "" : "\n" + printedOrigin), documentation : { kind : "markdown", value : haxeLanguageServer_helper_DocHelper.printCodeBlock("override " + printer.printOverrideDefinition(field,concreteType,data.indent,false),"haxe")}, additionalTextEdits : haxeLanguageServer_helper_ImportHelper_createFunctionImportsEdit(data.doc,data.importPosition,this.context,concreteType,fieldFormatting)};
		this.handleDeprecated(item1,field.meta);
		return item1;
	}
	getKindForField(field,kind) {
		if(kind == "EnumAbstractField") {
			return 20;
		}
		let fieldKind = field.kind;
		switch(fieldKind.kind) {
		case "FMethod":
			if(haxeLanguageServer_protocol_Extensions_isOperator(field)) {
				return 24;
			} else if(field.scope == 0) {
				return 3;
			} else if(field.scope == 2) {
				return 4;
			} else {
				return 2;
			}
			break;
		case "FVar":
			if(haxeLanguageServer_protocol_Extensions_isFinalField(field)) {
				return 5;
			}
			let write = fieldKind.args.write.kind;
			switch(fieldKind.args.read.kind) {
			case "AccInline":
				return 21;
			case "AccNormal":
				if(write == "AccNormal") {
					return 5;
				} else {
					return 10;
				}
				break;
			default:
				return 10;
			}
			break;
		}
	}
	createEnumFieldCompletionItem(item,data) {
		if(item.type == null) {
			return null;
		}
		let occurrence = item.args;
		let field = occurrence.field;
		let name = field.name;
		let textEdit = { newText : name, range : data.replaceRange};
		let definition = this.printer.printEnumField(field,item.type,false,true);
		let origin = this.printer.printEnumFieldOrigin(occurrence.origin,"'");
		let result = { label : name, kind : 20, detail : origin != null ? definition + "\n" + origin : definition, textEdit : textEdit};
		if(data.mode.kind == 11) {
			let field1 = this.printer.printEnumField(field,item.type,true,false);
			field1 = this.maybeInsertPatternColon(field1,data);
			textEdit.newText = field1;
			result.insertTextFormat = 2;
			result.command = haxeLanguageServer_helper_VscodeCommands_TriggerParameterHints;
		}
		return result;
	}
	createTypeCompletionItem(type,data) {
		let mode = data.mode;
		let isImportCompletion = mode.kind == 8 || mode.kind == 9;
		let importConfig = this.context.config.user.codeGeneration.imports;
		let autoImport = importConfig.enableAutoImports;
		if(isImportCompletion || type.path.importStatus == 2) {
			autoImport = false;
		}
		let dotPath = new haxeLanguageServer_protocol_DisplayPrinter(null,haxeLanguageServer_protocol_PathPrinting.Always).printPath(type.path);
		if(this.isExcluded(dotPath)) {
			return null;
		}
		let unqualifiedName = type.path.typeName;
		let containerName = dotPath.includes(".") ? haxeLanguageServer_extensions_StringExtensions_untilLastDot(dotPath) : "";
		let qualifiedName = new haxeLanguageServer_protocol_DisplayPrinter(null,isImportCompletion ? haxeLanguageServer_protocol_PathPrinting.Always : haxeLanguageServer_protocol_PathPrinting.Qualified).printPath(type.path);
		let activePackage = this.context.latestActiveFilePackage;
		let sortText = containerName == activePackage ? "00" : containerName.length == 0 ? "01" : haxeLanguageServer_protocol_Extensions_hasMeta(type.meta,":deprecated") ? "09" : StringTools.lpad("" + ((activePackage.startsWith(containerName) ? StringTools.replace(containerName,activePackage,"") : containerName).split(".").length + 2),"0",2);
		let textEdit = { range : data.replaceRange, newText : autoImport ? unqualifiedName : qualifiedName};
		let item = { label : unqualifiedName + (containerName == "" ? "" : " - " + dotPath), kind : this.getKindForModuleType(type), textEdit : textEdit, sortText : unqualifiedName + sortText};
		if(isImportCompletion) {
			textEdit.newText = this.maybeInsert(textEdit.newText,";",data.lineAfter);
		} else if(importConfig.enableAutoImports && type.path.importStatus == 1) {
			item.additionalTextEdits = [haxeLanguageServer_helper_ImportHelper_createImportsEdit(data.doc,data.importPosition,[dotPath],importConfig.style)];
		}
		if(this.snippetSupport) {
			switch(data.mode.kind) {
			case 4:case 5:case 6:case 7:
				if(HxOverrides.cca(data.lineAfter,0) != 60 && haxeLanguageServer_protocol_Extensions_hasMandatoryTypeParameters(type)) {
					textEdit.newText += "<$1>";
					item.insertTextFormat = 2;
					item.command = haxeLanguageServer_helper_VscodeCommands_TriggerSuggest;
				}
				break;
			default:
			}
		}
		if(data.mode.kind == 7 && data.mode.args != null) {
			if(!data.mode.args.isIntersectionType) {
				textEdit.newText = this.maybeInsert(textEdit.newText,",",data.lineAfter);
			}
		}
		if(type.params != null) {
			item.detail = this.printTypeDetail(type,containerName);
		}
		this.handleDeprecated(item,type.meta);
		return item;
	}
	getKindForModuleType(type) {
		switch(type.kind) {
		case 0:
			return 7;
		case 1:
			return 8;
		case 2:
			return 13;
		case 3:
			return 7;
		case 4:
			return 13;
		case 5:
			return 8;
		case 6:
			return 22;
		}
	}
	formatDocumentation(doc) {
		if(doc == null) {
			return null;
		}
		if(this.markdownSupport) {
			return { kind : "markdown", value : haxeLanguageServer_helper_DocHelper.markdownFormat(doc)};
		}
		return haxeLanguageServer_helper_DocHelper.extractText(doc);
	}
	printTypeDetail(type,containerName) {
		let tmp = this.printer.printEmptyTypeDefinition(type) + "\n";
		let _g = type.path.importStatus;
		let tmp1;
		if(_g == null) {
			tmp1 = "";
		} else {
			switch(_g) {
			case 0:
				tmp1 = "(imported)";
				break;
			case 1:
				tmp1 = "Auto-import from '" + containerName + "'";
				break;
			case 2:
				tmp1 = "(shadowed)";
				break;
			}
		}
		return tmp + tmp1;
	}
	createPackageCompletionItem(pack,data) {
		let path = pack.path;
		let dotPath = path.pack.join(".");
		if(this.isExcluded(dotPath)) {
			return null;
		}
		let text = data.mode.kind == 0 ? path.pack[path.pack.length - 1] : dotPath;
		return { label : text, kind : 9, detail : "package " + dotPath, textEdit : { newText : this.maybeInsert(text,".",data.lineAfter), range : data.replaceRange}, command : haxeLanguageServer_helper_VscodeCommands_TriggerSuggest};
	}
	createKeywordCompletionItem(keyword,data) {
		let textEdit = { newText : keyword.name, range : data.replaceRange};
		let item = { label : keyword.name, kind : 14, textEdit : textEdit};
		if(data.mode.kind == 13 || keyword.name == "new" || keyword.name == "inline") {
			item.command = haxeLanguageServer_helper_VscodeCommands_TriggerSuggest;
		}
		if(data.mode.kind == 14) {
			switch(keyword.name) {
			case "extern":case "final":case "import":case "private":case "using":
				item.command = haxeLanguageServer_helper_VscodeCommands_TriggerSuggest;
				break;
			default:
			}
		}
		switch(keyword.name) {
		case "catch":case "for":case "if":case "while":
			if(this.snippetSupport) {
				item.insertTextFormat = 2;
				textEdit.newText = "" + keyword.name + " ($1)";
			} else {
				textEdit.newText = this.maybeInsert(textEdit.newText," ",data.lineAfter);
			}
			break;
		case "extends":case "implements":
			textEdit.newText += " ";
			break;
		case "break":case "cast":case "continue":case "default":case "package":case "return":
			break;
		case "do":case "else":case "switch":
			textEdit.newText = this.maybeInsert(textEdit.newText," ",data.lineAfter);
			break;
		default:
			textEdit.newText = this.maybeInsert(textEdit.newText," ",data.lineAfter);
		}
		return item;
	}
	createLocalCompletionItem(item,data) {
		let local = item.args;
		if(item.type == null || local.name == "_") {
			return null;
		}
		return { label : local.name, kind : local.origin == 5 ? 2 : 6, detail : "" + this.printer.printLocalDefinition(local,item.type) + " \n(" + this.printer.printLocalOrigin(local.origin) + ")"};
	}
	createModuleCompletionItem($module,data) {
		let path = $module.path;
		let dotPath = path.pack.concat([path.moduleName]).join(".");
		if(this.isExcluded(dotPath)) {
			return null;
		} else {
			return { label : path.moduleName, kind : 19, detail : "module " + dotPath};
		}
	}
	createLiteralCompletionItem(item,data) {
		if(item.type == null) {
			return null;
		}
		let literal = item.args;
		let result = { label : literal.name, kind : 14, detail : this.printer.printType(item.type)};
		switch(literal.name) {
		case "false":case "null":case "true":
			result.textEdit = { range : data.replaceRange, newText : this.maybeInsertPatternColon(literal.name,data)};
			break;
		default:
		}
		return result;
	}
	maybeInsert(text,token,lineAfter) {
		if(lineAfter.charAt(0) == token.charAt(0)) {
			return text;
		} else {
			return text + token;
		}
	}
	maybeInsertPatternColon(text,data) {
		let info = data.mode.args;
		if(info == null || info.isOutermostPattern) {
			return this.maybeInsert(text,":",data.lineAfter);
		}
		return text;
	}
	handleDeprecated(item,meta) {
		if(this.deprecatedSupport && haxeLanguageServer_protocol_Extensions_hasMeta(meta,":deprecated")) {
			if(item.tags == null) {
				item.tags = [];
			}
			item.tags.push(1);
		}
	}
	isExcluded(dotPath) {
		let excludes = this.context.config.user.exclude;
		if(excludes == null) {
			return false;
		}
		let _g = 0;
		while(_g < excludes.length) if(dotPath.startsWith(excludes[_g++])) {
			return true;
		}
		return false;
	}
}
haxeLanguageServer_features_haxe_completion_CompletionFeature.__name__ = "haxeLanguageServer.features.haxe.completion.CompletionFeature";
Object.assign(haxeLanguageServer_features_haxe_completion_CompletionFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_completion_CompletionFeature
});
class haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy {
	constructor(context,contextSupport,formatDocumentation) {
		this.context = context;
		this.contextSupport = contextSupport;
		this.formatDocumentation = formatDocumentation;
	}
	handle(params,token,resolve,reject,doc,offset,textBefore,_) {
		if(this.contextSupport && haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.isInvalidCompletionPosition(params.context,textBefore)) {
			resolve({ items : [], isIncomplete : false});
			return;
		}
		let r = haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.calculateCompletionPosition(textBefore,offset);
		let bytePos = this.context.displayOffsetConverter.characterOffsetToByteOffset(doc.content,r.pos);
		let tmp = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc.uri);
		let _gthis = this;
		this.context.callDisplay(r.toplevel ? "@toplevel" : "field completion",["" + (tmp == null ? "null" : tmp) + "@" + bytePos + (r.toplevel ? "@toplevel" : "")],doc.content,token,function(result) {
			switch(result._hx_index) {
			case 0:
				resolve(null);
				break;
			case 1:
				let _gmsg = result.msg;
				let xml;
				try {
					xml = Xml.parse(_gmsg).firstElement();
				} catch( _g ) {
					haxe_NativeStackTrace.lastError = _g;
					xml = null;
				}
				if(xml == null) {
					haxeLanguageServer_extensions_ResponseErrorExtensions_invalidXml(reject,_gmsg);
					return;
				}
				let items = r.toplevel ? _gthis.parseToplevelCompletion(xml,params.position,textBefore,doc) : _gthis.parseFieldCompletion(xml,textBefore,params.position);
				resolve({ items : items, isIncomplete : false});
				break;
			}
		},haxeLanguageServer_extensions_ResponseErrorExtensions_handler(reject));
	}
	parseToplevelCompletion(x,position,textBefore,doc) {
		let result = [];
		let timers = [];
		let el = x.elements();
		while(el.hasNext()) {
			let el1 = el.next();
			let kind = el1.get("k");
			let type = el1.get("t");
			if(el1.nodeType != Xml.Document && el1.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (el1.nodeType == null ? "null" : XmlType.toString(el1.nodeType)));
			}
			let _this = el1.children[0];
			if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
			}
			let name = _this.nodeValue;
			if(kind == "local" && name == "_") {
				continue;
			}
			let item = { label : name, detail : ""};
			let displayKind = haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.toplevelKindToCompletionItemKind(kind,type);
			if(displayKind != null) {
				item.kind = displayKind;
			}
			if(name.startsWith("@TIME") || name.startsWith("@TOTAL")) {
				let info = name.split(":");
				timers.push(haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.getTimerCompletionItem(info[0],info[1],position));
				continue;
			}
			let fullName = name;
			if(kind == "global") {
				fullName = el1.get("p") + "." + name;
			} else if(kind == "type") {
				fullName = el1.get("p");
			}
			if(type != null || fullName != name) {
				let parts = [];
				if(fullName != name) {
					parts.push(fullName);
				}
				if(type != null) {
					parts.push(type);
				}
				item.detail = parts.join(" ");
			}
			let documentation = el1.get("d");
			if(documentation != null) {
				item.documentation = this.formatDocumentation(documentation);
			}
			result.push(item);
		}
		haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.sortTimers(timers);
		return result.concat(timers);
	}
	parseFieldCompletion(x,textBefore,position) {
		let result = [];
		let timers = [];
		let methods_h = Object.create(null);
		let el = x.elements();
		while(el.hasNext()) {
			let el1 = el.next();
			let rawKind = el1.get("k");
			let kind = haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.fieldKindToCompletionItemKind(rawKind);
			let name = el1.get("n");
			if(kind == 2) {
				let method = methods_h[name];
				if(method != null) {
					method.overloads++;
					continue;
				}
			}
			let type = null;
			let doc = null;
			let child = el1.elements();
			while(child.hasNext()) {
				let child1 = child.next();
				if(child1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (child1.nodeType == null ? "null" : XmlType.toString(child1.nodeType)));
				}
				switch(child1.nodeName) {
				case "d":
					if(child1.nodeType != Xml.Document && child1.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (child1.nodeType == null ? "null" : XmlType.toString(child1.nodeType)));
					}
					let _this = child1.children[0];
					if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, unexpected " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
					}
					let s = _this.nodeValue;
					doc = s == "" ? null : s;
					break;
				case "t":
					if(child1.nodeType != Xml.Document && child1.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (child1.nodeType == null ? "null" : XmlType.toString(child1.nodeType)));
					}
					let _this1 = child1.children[0];
					if(_this1.nodeType == Xml.Document || _this1.nodeType == Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, unexpected " + (_this1.nodeType == null ? "null" : XmlType.toString(_this1.nodeType)));
					}
					let s1 = _this1.nodeValue;
					type = s1 == "" ? null : s1;
					break;
				}
			}
			let textEdit = null;
			if(rawKind == "metadata") {
				name = HxOverrides.substr(name,1,null);
				haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.reFieldPart.match(textBefore);
				if(haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.reFieldPart.matched(2) == ":") {
					textEdit = { newText : name, range : { start : { line : position.line, character : position.character + (-1)}, end : position}};
				}
			} else if((name.startsWith("@TIME") || name.startsWith("@TOTAL")) && type != null) {
				timers.push(haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.getTimerCompletionItem(name,type,position));
				continue;
			}
			let item = { label : name};
			if(doc != null) {
				item.documentation = this.formatDocumentation(doc);
			}
			if(kind != null) {
				item.kind = kind;
			}
			if(type != null) {
				item.detail = haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.formatType(type,name,kind);
			}
			if(textEdit != null) {
				item.textEdit = textEdit;
			}
			if(kind == 2) {
				methods_h[name] = { item : item, overloads : 0};
			}
			result.push(item);
		}
		let method_keys = Object.keys(methods_h);
		let method_length = method_keys.length;
		let method_current = 0;
		while(method_current < method_length) {
			let method = methods_h[method_keys[method_current++]];
			let overloads = method.overloads;
			if(overloads > 0) {
				method.item.detail += " (+" + overloads + " overloads)";
			}
		}
		haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.sortTimers(timers);
		return result.concat(timers);
	}
	static isInvalidCompletionPosition(context,text) {
		if((context == null ? null : context.triggerCharacter) == ":") {
			return haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.reCaseOrDefault.match(text);
		} else {
			return false;
		}
	}
	static calculateCompletionPosition(text,index) {
		if(haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.reFieldPart.match(text)) {
			return { pos : index - haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.reFieldPart.matched(3).length, toplevel : false};
		}
		return { pos : index - (text.length - StringTools.rtrim(text).length), toplevel : true};
	}
	static toplevelKindToCompletionItemKind(kind,type) {
		let isFunction = function() {
			if(type != null) {
				if(haxeLanguageServer_helper_TypeHelper.parseDisplayType(type)._hx_index == 1) {
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
		};
		switch(kind) {
		case "enum":case "enumabstract":
			return 13;
		case "global":
			return 6;
		case "literal":
			return 14;
		case "local":
			if(isFunction()) {
				return 2;
			} else {
				return 6;
			}
			break;
		case "package":
			return 9;
		case "member":case "static":
			if(isFunction()) {
				return 2;
			} else {
				return 5;
			}
			break;
		case "timer":
			return 12;
		case "type":
			return 7;
		default:
			haxe_Log.trace("unknown toplevel item kind: " + kind,{ fileName : "src/haxeLanguageServer/features/haxe/completion/CompletionFeatureLegacy.hx", lineNumber : 136, className : "haxeLanguageServer.features.haxe.completion.CompletionFeatureLegacy", methodName : "toplevelKindToCompletionItemKind"});
			return null;
		}
	}
	static sortTimers(items) {
		items.sort(function(a,b) {
			let time1 = a.data;
			let time2 = b.data;
			if(time1 < time2) {
				return 1;
			}
			if(time1 > time2) {
				return -1;
			}
			return 0;
		});
		let _g = 0;
		let _g1 = items.length;
		while(_g < _g1) {
			let i = _g++;
			items[i].sortText = "_" + String.fromCodePoint((65 + i));
		}
	}
	static getTimerCompletionItem(name,time,position) {
		let timeRegex = new EReg("([0-9.]*)s(?: \\(([0-9]*)%\\))?","");
		let seconds = 0.0;
		let percentage = "--";
		try {
			timeRegex.match(time);
			seconds = parseFloat(timeRegex.matched(1));
			percentage = timeRegex.matched(2);
		} catch( _g ) {
		}
		let doc = null;
		if(name.startsWith("@TIME @TOTAL")) {
			name = "@Total time: " + time;
		} else {
			name = StringTools.replace(name,"@TIME ","" + percentage + "% ");
			doc = seconds + "s";
		}
		return { label : name, kind : 12, documentation : { kind : "plaintext", value : doc}, textEdit : { range : { start : position, end : position}, newText : ""}, data : seconds};
	}
	static formatType(type,name,kind) {
		if(kind == null) {
			return type;
		} else if(kind == 2) {
			return name + haxeLanguageServer_helper_TypeHelper.prepareSignature(type);
		} else {
			return type;
		}
	}
	static fieldKindToCompletionItemKind(kind) {
		switch(kind) {
		case "metadata":
			return 3;
		case "method":
			return 2;
		case "package":
			return 9;
		case "timer":
			return 12;
		case "type":
			return 7;
		case "var":
			return 5;
		default:
			haxe_Log.trace("unknown field item kind: " + kind,{ fileName : "src/haxeLanguageServer/features/haxe/completion/CompletionFeatureLegacy.hx", lineNumber : 279, className : "haxeLanguageServer.features.haxe.completion.CompletionFeatureLegacy", methodName : "fieldKindToCompletionItemKind"});
			return null;
		}
	}
}
haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.__name__ = "haxeLanguageServer.features.haxe.completion.CompletionFeatureLegacy";
Object.assign(haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.prototype, {
	__class__: haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy
});
class haxeLanguageServer_features_haxe_completion_ExpectedTypeCompletion {
	constructor(context) {
		this.context = context;
	}
	createItems(data) {
		let toplevel;
		switch(data.mode.kind) {
		case 2:case 11:
			toplevel = data.mode.args;
			break;
		default:
			return [];
		}
		if(toplevel == null) {
			return [];
		}
		let types = [];
		let expectedTypeFollowed = toplevel.expectedTypeFollowed;
		if(expectedTypeFollowed != null) {
			let _g = 0;
			let _g1 = haxeLanguageServer_protocol_Extensions_resolveTypes(expectedTypeFollowed);
			while(_g < _g1.length) types.push(_g1[_g++]);
		}
		if(toplevel.compatibleTypes != null) {
			let _g = 0;
			let _g1 = toplevel.compatibleTypes;
			while(_g < _g1.length) {
				let _g2 = 0;
				let _g3 = haxeLanguageServer_protocol_Extensions_resolveTypes(_g1[_g++]);
				while(_g2 < _g3.length) types.push(_g3[_g2++]);
			}
		}
		let items = [];
		let _g = 0;
		while(_g < types.length) items = items.concat(this.createItemsForType(types[_g++],data));
		items = haxeLanguageServer_extensions_ArrayExtensions_filterDuplicates(items,function(item1,item2) {
			return item1.insertText == item2.insertText;
		});
		let _g1 = this;
		let position = data.params.position;
		let f = function(data) {
			return _g1.createExpectedTypeCompletionItem(data,position);
		};
		let result = new Array(items.length);
		let _g2 = 0;
		let _g3 = items.length;
		while(_g2 < _g3) {
			let i = _g2++;
			result[i] = f(items[i]);
		}
		return result;
	}
	createItemsForType(concreteType,data) {
		let items = [];
		let anonFormatting = this.context.config.user.codeGeneration.functions.anonymous;
		let printer = new haxeLanguageServer_protocol_DisplayPrinter(false,haxeLanguageServer_protocol_PathPrinting.Shadowed,anonFormatting);
		let _gthis = this;
		switch(concreteType.kind) {
		case "TAbstract":case "TInst":
			let type = concreteType.args;
			let getNested = function(i) {
				return _gthis.createItemsForType(type.params[i],data)[0];
			};
			let _g = haxeLanguageServer_protocol_DotPath_getDotPath(concreteType);
			if(_g != null) {
				switch(_g) {
				case "EReg":
					items.push({ label : "~/regex/", detail : "Generate regex literal", insertText : "~/${1:regex}/", insertTextFormat : 2});
					break;
				case "haxe.ds.Map":
					let nested = getNested(1);
					let item = { label : "[key => value]", detail : "Generate map literal", insertText : "[${1:key} => " + (nested == null ? "${2:value}" : haxeLanguageServer_helper_SnippetHelper.offset(nested.insertText,1)) + "]", insertTextFormat : 2};
					item.code = haxeLanguageServer_helper_SnippetHelper.prettify(item.insertText);
					items.push(item);
					break;
				case "Array":case "haxe.ds.ReadOnlyArray":
					let nested1 = getNested(0);
					let item1 = { label : "[]", detail : "Generate array literal", insertText : "[" + (nested1 == null ? "$1" : nested1.insertText) + "]", insertTextFormat : 2};
					item1.code = haxeLanguageServer_helper_SnippetHelper.prettify(item1.insertText);
					items.push(item1);
					break;
				default:
				}
			}
			break;
		case "TAnonymous":
			let anon = concreteType.args;
			let singleLine = data.mode.kind == 11;
			let allFields = printer.printObjectLiteral(anon,singleLine,false,true);
			let requiredFields = printer.printObjectLiteral(anon,singleLine,true,true);
			if(allFields == requiredFields) {
				items.push({ label : anon.fields.length == 0 ? "{}" : "{fields...}", detail : "Generate object literal", insertText : allFields, insertTextFormat : 2, code : printer.printObjectLiteral(anon,singleLine,false,false)});
			} else {
				items.push({ label : "{required fields...}", detail : "Generate object literal\n(only required fields)", sortText : ".", insertText : requiredFields, insertTextFormat : 2, code : printer.printObjectLiteral(anon,singleLine,true,false)});
				items.push({ label : "{all fields...}", detail : "Generate object literal\n(all fields)", sortText : "/", insertText : allFields, insertTextFormat : 2, code : printer.printObjectLiteral(anon,singleLine,false,false)});
			}
			break;
		case "TFun":
			let definition = printer.printAnonymousFunctionDefinition(concreteType.args);
			items.push({ label : definition, detail : "Generate anonymous function", insertText : definition, insertTextFormat : 1, additionalTextEdits : haxeLanguageServer_helper_ImportHelper_createFunctionImportsEdit(data.doc,data.importPosition,this.context,concreteType,anonFormatting)});
			break;
		default:
		}
		return items;
	}
	createExpectedTypeCompletionItem(data,position) {
		let item = { label : data.label, detail : data.detail, sortText : data.sortText == null ? "0" : data.sortText, kind : 15, textEdit : { newText : data.insertText, range : { start : position, end : position}}, insertTextFormat : data.insertTextFormat, additionalTextEdits : data.additionalTextEdits, data : { origin : 1}};
		if(data.code != null) {
			item.documentation = { kind : "markdown", value : haxeLanguageServer_helper_DocHelper.printCodeBlock(data.code,"haxe")};
		}
		return item;
	}
}
haxeLanguageServer_features_haxe_completion_ExpectedTypeCompletion.__name__ = "haxeLanguageServer.features.haxe.completion.ExpectedTypeCompletion";
Object.assign(haxeLanguageServer_features_haxe_completion_ExpectedTypeCompletion.prototype, {
	__class__: haxeLanguageServer_features_haxe_completion_ExpectedTypeCompletion
});
class haxeLanguageServer_features_haxe_completion_PostfixCompletion {
	constructor(context) {
		this.context = context;
	}
	createItems(data,items) {
		let level = this.context.config.user.postfixCompletion.level;
		if(level == "off") {
			return [];
		}
		let context = data.params.context;
		if((context == null ? null : context.triggerKind) == 2 && (context == null ? null : context.triggerCharacter) != ".") {
			return [];
		}
		let subject;
		let mode = data.mode;
		if(mode == null) {
			return [];
		}
		if(mode.kind == 0) {
			if(mode.args != null) {
				subject = mode.args;
			} else {
				return [];
			}
		} else {
			return [];
		}
		let type = subject.item.type;
		if(type == null) {
			return [];
		}
		let type1 = haxeLanguageServer_protocol_Extensions_removeNulls(type).type;
		let expr = data.doc.getText(subject.range);
		if(expr.startsWith("(") && expr.endsWith(")")) {
			expr = expr.substring(1,expr.length - 1);
		}
		let replaceRange = data.replaceRange;
		if(replaceRange == null) {
			let pos = data.params.position;
			replaceRange = { start : pos, end : pos};
		}
		let removeRange = { start : subject.range.start, end : replaceRange.start};
		let result = [];
		let _gthis = this;
		let add = function(item) {
			result.push(_gthis.createPostfixCompletionItem(item,data.doc,removeRange,replaceRange));
		};
		if(subject.iterator != null) {
			let tmp = "for ($" + "{1:" + haxeLanguageServer_protocol_Extensions_guessName($iterator(subject).type) + "} in " + expr + ") " + "{\n\t$0\n}";
			add({ label : "for", detail : "for (item in expr)", insertText : tmp, insertTextFormat : 2});
		}
		if(subject.keyValueIterator != null) {
			let key = haxeLanguageServer_protocol_DotPath_getDotPath($keyValueIterator(subject).key) == "StdTypes.Int" ? "index" : "key";
			add({ label : "for k=>v", detail : "for (" + key + " => value in expr)", insertText : "for (" + key + " => value in " + expr + ") " + "{\n\t$0\n}", insertTextFormat : 2});
		}
		let dotPath = haxeLanguageServer_protocol_DotPath_getDotPath(type1);
		if(dotPath != null) {
			switch(dotPath) {
			case "StdTypes.Bool":
				add({ label : "not", detail : "!expr", insertText : "!" + expr, insertTextFormat : 1});
				add({ label : "if", detail : "if (expr)", insertText : "if (" + expr + ") " + "{\n\t$0\n}", insertTextFormat : 2});
				add({ label : "else", detail : "if (!expr)", insertText : "if (!" + expr + ") " + "{\n\t$0\n}", insertTextFormat : 2});
				break;
			case "StdTypes.Float":
				add({ label : "int", detail : "Std.int(expr)", insertText : "Std.int(" + expr + ")", insertTextFormat : 1});
				break;
			case "StdTypes.Int":
				let _g = 0;
				let _g1 = this.createIndexedLoops(expr);
				while(_g < _g1.length) add(_g1[_g++]);
				break;
			default:
			}
		}
		if(level != "filtered") {
			this.createNonFilteredItems(dotPath,expr,add);
		}
		let _g2 = 0;
		let _g3 = this.createLengthIterators(subject,items,expr);
		while(_g2 < _g3.length) add(_g3[_g2++]);
		let switchItem = this.createSwitchItem(subject,expr);
		if(switchItem != null) {
			add(switchItem);
		}
		return result;
	}
	createNonFilteredItems(dotPath,expr,add) {
		if(dotPath != "String") {
			add({ label : "string", detail : "Std.string(expr)", insertText : "Std.string(" + expr + ")", insertTextFormat : 1});
		}
		add({ label : "trace", detail : "trace(expr);", insertText : "trace($" + "{1:" + expr + "});", insertTextFormat : 2});
		add({ label : "print", detail : "Sys.println(expr);", insertText : "Sys.println($" + "{1:" + expr + "});", insertTextFormat : 2});
		add({ label : "is", detail : "Std.is(expr, T)", insertText : "Std.is(" + expr + ", $1)", insertTextFormat : 2, command : haxeLanguageServer_helper_VscodeCommands_TriggerSuggest});
		add({ label : "unsafe cast", detail : "cast expr", insertText : "cast " + expr, insertTextFormat : 1});
		add({ label : "safe cast", detail : "cast(expr, T)", insertText : "cast(" + expr + ", $1)", insertTextFormat : 2, command : haxeLanguageServer_helper_VscodeCommands_TriggerSuggest});
		add({ label : "type check", detail : "(expr : T)", insertText : "(" + expr + " : $1)", insertTextFormat : 2, command : haxeLanguageServer_helper_VscodeCommands_TriggerSuggest});
		add({ label : "null", detail : "if (expr == null)", insertText : "if (" + expr + " == null) " + "{\n\t$0\n}", insertTextFormat : 2});
		add({ label : "not null", detail : "if (expr != null)", insertText : "if (" + expr + " != null) " + "{\n\t$0\n}", insertTextFormat : 2});
		add({ label : "return", detail : "return expr;", insertText : "return " + expr + ";", insertTextFormat : 1});
		let createLocalItem = function(kind,sortText) {
			return { label : kind, detail : "" + kind + " name = " + expr + ";", insertText : "" + kind + " $" + "{1:name} = " + expr + ";", insertTextFormat : 2, eat : ";"};
		};
		add(createLocalItem("var","1"));
		add(createLocalItem("final","2"));
	}
	createLengthIterators(subject,items,expr) {
		let result = [];
		let _g = 0;
		while(_g < items.length) {
			let item = items[_g];
			++_g;
			if(item.kind == "ClassField") {
				let field = item.args.field.name;
				if(!new EReg("^(get)?(length|count|size)$","i").match(field) || item.type == null) {
					continue;
				}
				let type = haxeLanguageServer_protocol_Extensions_removeNulls(item.type).type;
				if(type.kind == "TFun") {
					field += "()";
					let args = type.args;
					if(args.args.length > 0) {
						continue;
					}
					type = args.ret;
				}
				let _g = haxeLanguageServer_protocol_DotPath_getDotPath(type);
				if(_g != null) {
					switch(_g) {
					case "StdTypes.Int":case "UInt":
						result = result.concat(this.createIndexedLoops("" + expr + "." + field));
						break;
					default:
					}
				}
			}
		}
		return result;
	}
	createIndexedLoops(field) {
		return [{ label : "for 0..." + field, insertText : "for (i in 0..." + field + ") " + "{\n\t$0\n}", insertTextFormat : 2, showCode : true},{ label : "while 0..." + field, insertText : "var i = 0;\r\nwhile (i < " + field + ") {\r\n\t$0\r\n\ti++;\r\n}", insertTextFormat : 2, showCode : true},{ label : "while " + field + "...0", insertText : "var i = " + field + ";\r\nwhile (i-- > 0) {\r\n\t$0\r\n}", insertTextFormat : 2, showCode : true}];
	}
	createSwitchItem(subject,expr) {
		let moduleType = subject.moduleTypeFollowed;
		if(moduleType == null) {
			moduleType = subject.moduleType;
		}
		if(moduleType == null) {
			return null;
		}
		let type = subject.item.type;
		if(type == null) {
			return null;
		}
		let printer = new haxeLanguageServer_protocol_DisplayPrinter();
		let parentheses = this.context.config.user.codeGeneration.switch_.parentheses;
		let make = function(insertText) {
			return { label : "switch", detail : printer.printSwitchSubject("expr",parentheses) + " {cases...}", insertText : insertText, insertTextFormat : 2, showCode : true};
		};
		let nullable = haxeLanguageServer_protocol_Extensions_removeNulls(type).nullable;
		switch(moduleType.kind) {
		case "abstract":
			if(haxeLanguageServer_protocol_Extensions_hasMeta(moduleType.meta,":enum")) {
				let a = moduleType.args;
				if(a.impl != null && Lambda.exists(a.impl.statics,function(f) {
					return haxeLanguageServer_protocol_Extensions_isEnumAbstractField(f);
				})) {
					return make(printer.printSwitchOnEnumAbstract(expr,a,nullable,true,parentheses));
				}
			} else if(moduleType.moduleName == "StdTypes" && moduleType.name == "Bool") {
				return make(printer.printSwitch(expr,["true","false"],nullable,true,parentheses));
			} else {
				let item = make(printer.printSwitchSubject(expr,parentheses) + " {\n\tcase $0\n}");
				item.command = haxeLanguageServer_helper_VscodeCommands_TriggerSuggest;
				return item;
			}
			break;
		case "enum":
			let e = moduleType.args;
			if(e.constructors.length > 0) {
				return make(printer.printSwitchOnEnum(expr,e,nullable,true,parentheses));
			}
			break;
		default:
			let item = make(printer.printSwitchSubject(expr,parentheses) + " {\n\tcase $0\n}");
			item.command = haxeLanguageServer_helper_VscodeCommands_TriggerSuggest;
			return item;
		}
		return null;
	}
	createPostfixCompletionItem(data,doc,removeRange,replaceRange) {
		if(data.eat != null) {
			let pos = replaceRange.end;
			let nextChar = doc.getText({ start : pos, end : { line : pos.line, character : pos.character + 1}});
			if(data.eat == nextChar) {
				replaceRange = { start : replaceRange.start, end : { line : pos.line, character : pos.character + 1}};
			}
		}
		let item = { label : data.label, sortText : "~", kind : 15, insertTextFormat : data.insertTextFormat, textEdit : { newText : data.insertText, range : replaceRange}, additionalTextEdits : [{ range : removeRange, newText : ""}], data : { origin : 1}};
		if(data.showCode == true) {
			item.documentation = { kind : "markdown", value : haxeLanguageServer_helper_DocHelper.printCodeBlock(haxeLanguageServer_helper_SnippetHelper.prettify(data.insertText),"haxe")};
		}
		if(data.detail != null) {
			item.detail = data.detail;
		}
		if(data.command != null) {
			item.command = data.command;
		}
		return item;
	}
}
haxeLanguageServer_features_haxe_completion_PostfixCompletion.__name__ = "haxeLanguageServer.features.haxe.completion.PostfixCompletion";
Object.assign(haxeLanguageServer_features_haxe_completion_PostfixCompletion.prototype, {
	__class__: haxeLanguageServer_features_haxe_completion_PostfixCompletion
});
class haxeLanguageServer_features_haxe_completion_SnippetCompletion {
	constructor(context) {
		this.context = context;
	}
	createItems(data,displayItems) {
		let fsPath = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(data.doc.uri);
		let pos = data.params.position;
		let isRestOfLineEmpty = StringTools.trim(HxOverrides.substr(data.doc.lineAt(pos.line),pos.character,null)).length == 0;
		let itemsToIgnore = new haxe_ds_ObjectMap();
		let _g = 0;
		while(_g < displayItems.length) {
			let item = displayItems[_g];
			++_g;
			if(item.kind == "Keyword") {
				switch(item.args.name) {
				case "final":case "function":case "package":case "var":
					itemsToIgnore.set(item,true);
					break;
				case "abstract":case "class":case "enum":case "interface":case "typedef":
					if(isRestOfLineEmpty) {
						itemsToIgnore.set(item,true);
					}
					break;
				default:
				}
			}
		}
		let items = [];
		let result = function() {
			return { items : items, itemsToIgnore : itemsToIgnore};
		};
		let body = "{\n\t$" + 0 + "\n}";
		let _gthis = this;
		let add = function(label,detail,code,sortText) {
			items.push(_gthis.createItem(label,detail,code,data.replaceRange,sortText));
		};
		let label = "var";
		let detail = "var name:T;";
		let code = "var $" + "{1:name}:$" + "{2:T};";
		let addVar = function() {
			add(label,detail,code);
		};
		let label1 = "final";
		let detail1 = "final name:T;";
		let code1 = "final $" + "{1:name}:$" + "{2:T};";
		let addFinal = function() {
			add(label1,detail1,code1);
		};
		let label2 = "function";
		let detail2 = "function name()";
		let code2 = "function $" + "{1:name}($" + "2) " + body;
		let addFunction = function() {
			add(label2,detail2,code2);
		};
		let addReadonly = function(isDefaultPrivate) {
			let prefix = isDefaultPrivate ? "public " : "";
			add("readonly",prefix + "var name(default, null):T;",prefix + ("var $" + "{1:name}(default, null):$" + "{2:T};"));
		};
		let addProperty = function(isDefaultPrivate) {
			let propertyPrefix = isDefaultPrivate ? "public " : "";
			let accessorPrefix = isDefaultPrivate ? "" : "private ";
			add("property",propertyPrefix + "var name(get, set):T;",propertyPrefix + ("var $" + "{1:name}(get, set):$" + "{2:T};\r\n\r\n" + accessorPrefix + "function get_$" + "{1:name}():$" + "{2:T} " + ("{\n\t$" + 3 + "\n}") + "\r\n\r\n" + accessorPrefix + "function set_$" + "{1:name}($" + "{1:name}:$" + "{2:T}):$" + "{2:T} " + body));
		};
		let addMain = function(explicitStatic) {
			let main = (explicitStatic ? "static " : "") + "function main()";
			add("main",main,"" + main + " " + body);
		};
		let addExprLevel = function() {
			add("final","final name","final ${1:name}");
			add("var","var name","var ${1:name}");
			addFunction();
		};
		let supportsModuleLevelStatics = haxeLanguageServer_helper_SemVer.isEqualOrGreaterThan(this.context.haxeServer.haxeVersion,{ major : 4, minor : 2, patch : 0, pre : null, build : null});
		let _g1 = data.tokenContext;
		switch(_g1._hx_index) {
		case 0:
			let pos1 = _g1.pos;
			let moduleName = haxeLanguageServer_extensions_StringExtensions_untilFirstDot(haxe_io_Path.withoutDirectory(fsPath));
			let name = "$" + "{1:" + moduleName + "}";
			let abstractName = name + ("($" + "{2:T})");
			return new Promise(function(resolve,reject) {
				if(isRestOfLineEmpty) {
					let _this = [{ label : "class", code : "class " + name + " " + body},{ label : "interface", code : "interface " + name + " " + body},{ label : "enum", code : "enum " + name + " " + body},{ label : "typedef", code : "typedef " + name + " = "},{ label : "struct", code : "typedef " + name + " = " + body},{ label : "abstract", code : "abstract " + abstractName + " " + body},{ label : "enum abstract", code : "enum abstract " + abstractName + " " + body}];
					let result = new Array(_this.length);
					let _g = 0;
					let _g1 = _this.length;
					while(_g < _g1) {
						let i = _g++;
						let item = _this[i];
						result[i] = _gthis.createItem(item.label,item.label + " " + moduleName,item.code,data.replaceRange);
					}
					items = result;
				}
				if(supportsModuleLevelStatics) {
					addVar();
					addFinal();
					addReadonly(false);
					addProperty(false);
					addFunction();
					addMain(false);
				}
				if(pos1 == haxeLanguageServer_tokentree_RootPosition.BeforePackage) {
					_gthis.context.determinePackage.onDeterminePackage({ fsPath : fsPath},null,function(pack) {
						let code = pack.pack == "" ? "package;" : "package " + pack.pack + ";";
						add("package",code,code);
						resolve(result());
					},function(_) {
						resolve(result());
					});
				} else {
					resolve(result());
				}
			});
		case 1:
			let _gtype = _g1.type;
			let isClass = _gtype.kind == haxeLanguageServer_tokentree_TypeKind.Class || _gtype.kind == haxeLanguageServer_tokentree_TypeKind.MacroClass;
			if(_gtype.field == null && (isClass || (_gtype.kind == haxeLanguageServer_tokentree_TypeKind.Abstract || _gtype.kind == haxeLanguageServer_tokentree_TypeKind.EnumAbstract))) {
				if(_gtype.kind == haxeLanguageServer_tokentree_TypeKind.EnumAbstract) {
					add("var","var Name;","var $" + "{1:Name}$" + "2;","~");
					add("final","final Name;","final $" + "{1:Name}$" + "2;","~");
				} else {
					addVar();
					addFinal();
					addReadonly(true);
				}
				addFunction();
				addProperty(true);
				add("new","public function new" + "()","public function new" + "($1) " + body);
				if(isClass) {
					addMain(true);
				}
			}
			if(_gtype.field != null) {
				addExprLevel();
			}
			break;
		case 2:
			addExprLevel();
			break;
		}
		return Promise.resolve(result());
	}
	createItem(label,detail,code,replaceRange,sortText) {
		let tmp = haxeLanguageServer_helper_DocHelper.printCodeBlock(haxeLanguageServer_helper_SnippetHelper.prettify(code),"haxe");
		return { label : label, detail : detail, kind : 15, sortText : sortText == null ? "~~" : sortText, textEdit : { range : replaceRange, newText : code}, insertTextFormat : 2, documentation : { kind : "markdown", value : tmp}, data : { origin : 1}};
	}
}
haxeLanguageServer_features_haxe_completion_SnippetCompletion.__name__ = "haxeLanguageServer.features.haxe.completion.SnippetCompletion";
Object.assign(haxeLanguageServer_features_haxe_completion_SnippetCompletion.prototype, {
	__class__: haxeLanguageServer_features_haxe_completion_SnippetCompletion
});
class haxeLanguageServer_features_haxe_documentSymbols_DocumentSymbolsFeature {
	constructor(context) {
		this.context = context;
		context.languageServerProtocol.onRequest("textDocument/documentSymbol",$bind(this,this.onDocumentSymbols));
	}
	onDocumentSymbols(params,token,resolve,reject) {
		let onResolve = this.context.startTimer("textDocument/documentSymbol");
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		if(doc1.get_tokens() == null) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noTokens(reject);
			return;
		}
		let symbols = new haxeLanguageServer_features_haxe_documentSymbols_DocumentSymbolsResolver(doc1).resolve();
		resolve(symbols);
		onResolve(null,this.countSymbols(symbols) + " symbols");
	}
	countSymbols(symbols) {
		if(symbols == null) {
			return 0;
		} else {
			let symbols1 = symbols.length;
			let result = new Array(symbols.length);
			let _g = 0;
			let _g1 = symbols.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = this.countSymbols(symbols[i].children);
			}
			return symbols1 + Lambda.fold(result,function(a,b) {
				return a + b;
			},0);
		}
	}
}
haxeLanguageServer_features_haxe_documentSymbols_DocumentSymbolsFeature.__name__ = "haxeLanguageServer.features.haxe.documentSymbols.DocumentSymbolsFeature";
Object.assign(haxeLanguageServer_features_haxe_documentSymbols_DocumentSymbolsFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_documentSymbols_DocumentSymbolsFeature
});
class haxeLanguageServer_features_haxe_documentSymbols_DocumentSymbolsResolver {
	constructor(document) {
		this.document = document;
	}
	resolve() {
		let stack = haxeLanguageServer_features_haxe_documentSymbols_SymbolStack._new();
		let tokens = this.document.get_tokens();
		if(tokens == null) {
			return [];
		}
		let _gthis = this;
		tokens.tree.filterCallback(function(token,depth) {
			haxeLanguageServer_features_haxe_documentSymbols_SymbolStack.set_depth(stack,depth);
			let add = function(token,kind,level,name,opensScope) {
				let nameToken = tokentree_utils_TokenTreeCheckUtils.getNameToken(token);
				if(nameToken == null && name != null) {
					nameToken = token;
				}
				if(nameToken == null || nameToken.inserted) {
					return;
				}
				if(name == null) {
					name = tokentree_utils_TokenTreeCheckUtils.getName(nameToken);
					if(name == null) {
						return;
					}
				}
				if(level == haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Expression && name == "_") {
					return;
				}
				if(opensScope == null) {
					opensScope = true;
				}
				let range = tokens.getTreePos(token);
				if(level != haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Expression) {
					let docComment = tokentree_utils_TokenTreeCheckUtils.getDocComment(token);
					if(docComment != null) {
						let docCommentPos = tokens.getPos(docComment);
						range = { file : range.file, min : docCommentPos.min, max : range.max};
					}
				}
				let _this = _gthis.document;
				let endOffset = range.max;
				let symbol = { start : _this.positionAt(range.min,1), end : _this.positionAt(endOffset,1)};
				let pos = tokens.getPos(nameToken);
				let _this1 = _gthis.document;
				let endOffset1 = pos.max;
				let symbol1 = { name : name, kind : kind, range : symbol, selectionRange : { start : _this1.positionAt(pos.min,1), end : _this1.positionAt(endOffset1,1)}};
				if(tokentree_utils_TokenTreeCheckUtils.isDeprecated(token)) {
					symbol1.tags = [1];
				}
				haxeLanguageServer_features_haxe_documentSymbols_SymbolStack.addSymbol(stack,level,symbol1,opensScope);
			};
			let _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 1:
					let _v_ = tokentree_utils_TokenTreeCheckUtils.getNameToken(token);
					let name = _v_ == null ? null : tokentree_utils_TokenTreeCheckUtils.getName(_v_);
					if(name == null && tokentree_utils_TokenTreeCheckUtils.isTypeMacroClass(token)) {
						name = "<macro class>";
					}
					add(token,5,haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Type(0),name);
					break;
				case 7:case 21:
					let this1 = tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.POpen)));
					if(this1 != null) {
						add(this1,13,haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Expression,null,false);
					}
					break;
				case 26:
					if(tokentree_utils_TokenTreeCheckUtils.isTypeEnum(token)) {
						add(token,10,haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Type(2));
					}
					break;
				case 28:
					add(token,11,haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Type(1));
					break;
				case 32:
					if(tokentree_utils_TokenTreeCheckUtils.isTypeStructure(token)) {
						add(token,23,haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Type(6));
					} else {
						add(token,11,haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Type(5));
					}
					break;
				case 40:
					if(tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract(token)) {
						add(token,10,haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Type(4));
					} else {
						add(token,5,haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Type(3));
					}
					break;
				case 0:case 2:case 42:
					let currentLevel;
					switch(stack[stack.length - 1].level._hx_index) {
					case 0:
						currentLevel = haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Field;
						break;
					case 1:
						currentLevel = haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Field;
						break;
					case 2:case 3:
						currentLevel = haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Expression;
						break;
					}
					let _g1 = tokentree_utils_FieldUtils.getFieldType(token,tokentree_utils_TokenFieldVisibility.Private);
					switch(_g1._hx_index) {
					case 0:
						let _gname = _g1.name;
						let name1 = _gname;
						if(_gname == null) {
							name1 = "<anonymous function>";
						}
						let type = haxeLanguageServer_features_haxe_documentSymbols_SymbolStack.getParentTypeKind(stack);
						let kind = name1 == "new" ? 9 : tokentree_utils_FieldUtils.isOperatorFunction(token) && (type == 3 || type == 4) ? 25 : 6;
						add(token,kind,currentLevel,name1);
						break;
					case 1:
						let _gname1 = _g1.name;
						let _gisStatic = _g1.isStatic;
						let _gisInline = _g1.isInline;
						if(currentLevel == haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Expression) {
							let children = token.children;
							if(children != null) {
								let _g = 0;
								let _g1 = children.length;
								while(_g < _g1) {
									let i = _g++;
									add(i == 0 ? token : children[i],13,currentLevel,null,i == children.length - 1);
								}
							}
						} else {
							add(token,haxeLanguageServer_features_haxe_documentSymbols_SymbolStack.getParentTypeKind(stack) == 4 && !_gisStatic ? 22 : _gisInline ? 14 : 8,currentLevel,_gname1);
						}
						break;
					case 2:
						add(token,7,currentLevel,_g1.name);
						break;
					case 3:
						break;
					}
					break;
				default:
				}
				break;
			case 2:
				if(_g.c._hx_index == 3) {
					let _g = haxeLanguageServer_features_haxe_documentSymbols_SymbolStack.getParentTypeKind(stack);
					if(_g != null) {
						switch(_g) {
						case 2:
							if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.BrOpen) != null) {
								add(token,22,haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Field);
							}
							break;
						case 6:
							let parent = tokentree_TokenTreeAccessHelper.parent(token);
							if(tokentree_TokenTreeAccessHelper.matches(parent,tokentree_TokenTreeDef.Question) != null) {
								parent = tokentree_TokenTreeAccessHelper.parent(parent);
							}
							if(tokentree_TokenTreeAccessHelper.matches(parent,tokentree_TokenTreeDef.BrOpen) != null) {
								add(token,8,haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Field);
							}
							break;
						default:
						}
					}
				}
				break;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
		return stack[0].symbol.children;
	}
}
haxeLanguageServer_features_haxe_documentSymbols_DocumentSymbolsResolver.__name__ = "haxeLanguageServer.features.haxe.documentSymbols.DocumentSymbolsResolver";
Object.assign(haxeLanguageServer_features_haxe_documentSymbols_DocumentSymbolsResolver.prototype, {
	__class__: haxeLanguageServer_features_haxe_documentSymbols_DocumentSymbolsResolver
});
var haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel = $hxEnums["haxeLanguageServer.features.haxe.documentSymbols.SymbolLevel"] = { __ename__:true,__constructs__:null
	,Root: {_hx_name:"Root",_hx_index:0,__enum__:"haxeLanguageServer.features.haxe.documentSymbols.SymbolLevel",toString:$estr}
	,Type: ($_=function(kind) { return {_hx_index:1,kind:kind,__enum__:"haxeLanguageServer.features.haxe.documentSymbols.SymbolLevel",toString:$estr}; },$_._hx_name="Type",$_.__params__ = ["kind"],$_)
	,Field: {_hx_name:"Field",_hx_index:2,__enum__:"haxeLanguageServer.features.haxe.documentSymbols.SymbolLevel",toString:$estr}
	,Expression: {_hx_name:"Expression",_hx_index:3,__enum__:"haxeLanguageServer.features.haxe.documentSymbols.SymbolLevel",toString:$estr}
};
haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.__constructs__ = [haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Root,haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Type,haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Field,haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Expression];
class haxeLanguageServer_features_haxe_documentSymbols_SymbolStack {
	static set_depth(this1,newDepth) {
		if(newDepth > this1.length - 1) {
			if(this1[newDepth] == null) {
				this1[newDepth] = this1[newDepth - 1];
			}
		} else if(newDepth < this1.length - 1) {
			while(this1.length - 1 > newDepth) this1.pop();
		}
		return this1.length - 1;
	}
	static _new() {
		return [{ level : haxeLanguageServer_features_haxe_documentSymbols_SymbolLevel.Root, symbol : { name : "root", kind : 2, range : null, selectionRange : null, children : []}}];
	}
	static addSymbol(this1,level,symbol,opensScope) {
		let parentSymbol = this1[this1.length - 1].symbol;
		if(parentSymbol.children == null) {
			parentSymbol.children = [];
		}
		parentSymbol.children.push(symbol);
		if(opensScope) {
			this1[this1.length - 1 + 1] = { level : level, symbol : symbol};
		}
	}
	static getParentTypeKind(this1) {
		let i = this1.length - 1;
		while(i-- > 0) {
			let _g = this1[i].level;
			if(_g._hx_index == 1) {
				return _g.kind;
			}
		}
		return null;
	}
}
class haxeLanguageServer_features_haxe_foldingRange_FoldingRangeFeature {
	constructor(context) {
		this.context = context;
		context.languageServerProtocol.onRequest("textDocument/foldingRange",$bind(this,this.onFoldingRange));
	}
	onFoldingRange(params,token,resolve,reject) {
		let onResolve = this.context.startTimer("textDocument/foldingRange");
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HaxeDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHaxeFile(uri)) {
			doc = new haxeLanguageServer_documents_HaxeDocument(uri,"hx",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		if(doc1.get_tokens() == null) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noTokens(reject);
			return;
		}
		let ranges = new haxeLanguageServer_features_haxe_foldingRange_FoldingRangeResolver(doc1,this.context.capabilities.textDocument).resolve();
		resolve(ranges);
		onResolve(null,ranges.length + " ranges");
	}
}
haxeLanguageServer_features_haxe_foldingRange_FoldingRangeFeature.__name__ = "haxeLanguageServer.features.haxe.foldingRange.FoldingRangeFeature";
Object.assign(haxeLanguageServer_features_haxe_foldingRange_FoldingRangeFeature.prototype, {
	__class__: haxeLanguageServer_features_haxe_foldingRange_FoldingRangeFeature
});
class haxeLanguageServer_features_haxe_foldingRange_FoldingRangeResolver {
	constructor(document,capabilities) {
		this.document = document;
		let _v_ = capabilities == null ? null : capabilities.foldingRange;
		this.lineFoldingOnly = (_v_ == null ? null : _v_.lineFoldingOnly) == true;
	}
	resolve() {
		let ranges = [];
		let _gthis = this;
		let add = function(start,end,kind) {
			let range = { startLine : start.line, endLine : end.line};
			if(!_gthis.lineFoldingOnly) {
				range.startCharacter = start.character;
				range.endCharacter = end.character;
			}
			if(kind != null) {
				range.kind = kind;
			}
			ranges.push(range);
		};
		let addRange = function(range,kind) {
			let start = _gthis.document.positionAt(range.min);
			let end = _gthis.document.positionAt(range.max);
			add(start,end,kind);
		};
		let firstImport = null;
		let lastImport = null;
		let conditionalStack = [];
		let regionStack = [];
		let tokens = this.document.get_tokens();
		if(tokens == null) {
			return [];
		}
		tokens.tree.filterCallback(function(token,_) {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 15:case 16:
					addRange(tokens.getTreePos(token));
					break;
				case 13:case 36:
					if(firstImport == null) {
						firstImport = token;
					}
					lastImport = token;
					break;
				default:
				}
				break;
			case 2:
				if(_g.c._hx_index == 2) {
					let range = tokens.getTreePos(token);
					let start = _gthis.document.positionAt(range.min);
					let end = _gthis.getEndOfPreviousLine(range.max);
					if(end.line > start.line) {
						add(start,end);
					}
				}
				break;
			case 3:
				let _gs = _g.s;
				if(_gs == "else" || _gs == "elseif" || _gs == "end") {
					let start = conditionalStack.pop();
					let pos = tokens.getPos(token);
					let end = _gthis.getEndOfPreviousLine(pos.max);
					if(start != null && end.line > start.line) {
						add(start,end);
					}
				}
				if(_gs == "if" || _gs == "else" || _gs == "elseif") {
					let this1 = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.lastChild(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.POpen)),tokentree_TokenTreeDef.PClose);
					let pos = this1 == null ? tokens.getPos(token) : tokens.getPos(this1);
					let start = _gthis.document.positionAt(pos.max);
					start.character++;
					conditionalStack.push(start);
				}
				break;
			case 7:
				addRange(tokens.getTreePos(token),"comment");
				break;
			case 8:
				let _gs1 = _g.s;
				if(haxeLanguageServer_features_haxe_foldingRange_FoldingRangeResolver.regionStartPattern.match(_gs1)) {
					regionStack.push(tokens.getPos(token).max);
				} else if(haxeLanguageServer_features_haxe_foldingRange_FoldingRangeResolver.regionEndPattern.match(_gs1)) {
					let start = regionStack.pop();
					if(start != null) {
						let end = tokens.getPos(token);
						addRange({ file : end.file, min : start, max : end.max},"region");
					}
				}
				break;
			case 16:case 18:
				let range = tokens.getTreePos(token);
				let start = _gthis.document.positionAt(range.min);
				let end = _gthis.getEndOfPreviousLine(range.max);
				if(end.line > start.line) {
					add(start,end);
				}
				break;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
		if(lastImport != null && firstImport != lastImport) {
			let start = tokens.getPos(firstImport);
			let end = tokens.getTreePos(lastImport);
			addRange({ file : start.file, min : start.min, max : end.max},"imports");
		}
		return ranges;
	}
	getEndOfPreviousLine(offset) {
		let endLine = this.document.positionAt(offset).line - 1;
		return { line : endLine, character : this.document.lineAt(endLine).length - 1};
	}
}
haxeLanguageServer_features_haxe_foldingRange_FoldingRangeResolver.__name__ = "haxeLanguageServer.features.haxe.foldingRange.FoldingRangeResolver";
Object.assign(haxeLanguageServer_features_haxe_foldingRange_FoldingRangeResolver.prototype, {
	__class__: haxeLanguageServer_features_haxe_foldingRange_FoldingRangeResolver
});
class haxeLanguageServer_features_hxml_CompletionFeature {
	constructor(context) {
		this.IgnoredFiles = ["haxe_libraries","node_modules","dump"];
		this.context = context;
	}
	onCompletion(params,token,resolve,reject) {
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HxmlDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHxmlFile(uri)) {
			doc = new haxeLanguageServer_documents_HxmlDocument(uri,"hxml",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		let pos = params.position;
		let line = doc1.lineAt(pos.line);
		let textAfter = HxOverrides.substr(line,pos.character,null);
		let hxmlContext = haxeLanguageServer_features_hxml_HxmlContextAnalyzer_analyzeHxmlContext(HxOverrides.substr(line,0,pos.character),pos);
		let resolveItems = function(items) {
			resolve({ isIncomplete : false, items : items});
		};
		let range = hxmlContext.range;
		let _g = hxmlContext.element;
		switch(_g._hx_index) {
		case 0:
			resolveItems(this.createFlagCompletion(range,textAfter));
			break;
		case 1:
			resolveItems(this.createEnumValueCompletion(range,_g.values));
			break;
		case 2:
			resolveItems(this.createDefineCompletion(range));
			break;
		case 3:
			break;
		case 4:
			resolveItems(this.createFilePathCompletion(range,_g.path,true));
			break;
		case 5:
			resolveItems(this.createFilePathCompletion(range,_g.path,false));
			break;
		case 6:
			this.createLibraryNameCompletion(range,resolve,reject);
			break;
		case 7:
			break;
		}
	}
	createFlagCompletion(range,textAfter) {
		let items = [];
		let addFlag = function(flag,name) {
			let textEdit = { range : range, newText : name};
			let item = { label : name, textEdit : textEdit, filterText : name, kind : 3, documentation : { kind : "markdown", value : flag.description}, insertTextFormat : 2};
			let arg = flag.argument;
			if(arg != null) {
				item.label += " " + arg.name;
				if(textAfter.charAt(0) != " ") {
					textEdit.newText += " ";
				}
				if(arg.insertion != null) {
					let insertion = arg.insertion;
					if(!insertion.includes("$")) {
						insertion = "$" + "{1:" + insertion + "}";
					}
					textEdit.newText += insertion;
				}
				if(arg.kind != null) {
					item.command = haxeLanguageServer_helper_VscodeCommands_TriggerSuggest;
				}
			}
			items.push(item);
		};
		let _g = 0;
		let _g1 = [];
		let e = haxeLanguageServer_features_hxml_data_Flags_HxmlFlags.iterator();
		while(e.hasNext()) {
			let x = $getIterator(e.next());
			while(x.hasNext()) _g1.push(x.next());
		}
		while(_g < _g1.length) {
			let flag = _g1[_g];
			++_g;
			addFlag(flag,flag.name);
			if(flag.shortName != null) {
				addFlag(flag,flag.shortName);
			}
		}
		return items;
	}
	createEnumValueCompletion(range,values) {
		let _g = [];
		let _g1 = 0;
		let _g2 = values;
		while(_g1 < _g2.length) {
			let value = _g2[_g1];
			++_g1;
			_g.push({ label : value.name, kind : 20, textEdit : { range : range, newText : value.name}, documentation : value.description});
		}
		_g[0].preselect = true;
		return _g;
	}
	createDefineCompletion(range) {
		let haxeVersion = this.context.haxeServer.haxeVersion;
		let _this = haxeLanguageServer_features_hxml_data_Defines_getDefines(false);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			let define = _this[i];
			let name = haxeLanguageServer_features_hxml_data_Define.getRealName(define);
			let textEdit = { range : range, newText : name};
			let item = { label : name, kind : 21, textEdit : textEdit, documentation : { kind : "markdown", value : haxeLanguageServer_features_hxml_data_Define.printDetails(define,haxeVersion)}};
			if(haxeLanguageServer_features_hxml_data_Define.hasParams(define)) {
				textEdit.newText += "=";
				item.command = haxeLanguageServer_helper_VscodeCommands_TriggerSuggest;
			}
			if(!haxeLanguageServer_features_hxml_data_Define.isAvailable(define,haxeVersion)) {
				item.tags = [1];
			}
			result[i] = item;
		}
		return result;
	}
	createFilePathCompletion(range,path,includeFiles) {
		if(path == null) {
			path = "";
		}
		let isValidDirectory = function(path) {
			if(sys_FileSystem.exists(path)) {
				return sys_FileSystem.isDirectory(path);
			} else {
				return false;
			}
		};
		let directory = (path.endsWith("/") || path.endsWith("\\")) && isValidDirectory(path) ? path : haxe_io_Path.directory(path);
		if(StringTools.trim(directory) == "") {
			directory = ".";
		}
		if(!isValidDirectory(directory)) {
			return [];
		}
		let items = [];
		let _g = 0;
		let _g1 = js_node_Fs.readdirSync(directory);
		while(_g < _g1.length) {
			let file = _g1[_g];
			++_g;
			if(file.startsWith(".") || file.startsWith("$") || this.IgnoredFiles.includes(file)) {
				continue;
			}
			let isDirectory = sys_FileSystem.isDirectory(haxe_io_Path.join([directory,file]));
			if(!includeFiles && !isDirectory) {
				continue;
			}
			let item = { label : file, kind : isDirectory ? 19 : 17};
			if(isDirectory && includeFiles) {
				item.insertText = file + "/";
				item.command = haxeLanguageServer_helper_VscodeCommands_TriggerSuggest;
			}
			items.push(item);
		}
		items.push({ label : "..", insertText : "../", kind : 19, command : haxeLanguageServer_helper_VscodeCommands_TriggerSuggest});
		return items;
	}
	createLibraryNameCompletion(range,resolve,reject) {
		this.context.languageServerProtocol.sendRequest("haxe/listLibraries",null,null,function(libraries) {
			let resolve1 = resolve;
			let result = new Array(libraries.length);
			let _g = 0;
			let _g1 = libraries.length;
			while(_g < _g1) {
				let i = _g++;
				let lib = libraries[i];
				result[i] = { label : lib.name, kind : 19, textEdit : { newText : lib.name, range : range}};
			}
			resolve1({ isIncomplete : false, items : result});
		},function(_) {
			let reject1 = reject;
			let data = null;
			let this1 = { code : -32603, message : "unable to retrieve library names"};
			if(data != null) {
				this1.data = data;
			}
			reject1(this1);
		});
	}
}
haxeLanguageServer_features_hxml_CompletionFeature.__name__ = "haxeLanguageServer.features.hxml.CompletionFeature";
Object.assign(haxeLanguageServer_features_hxml_CompletionFeature.prototype, {
	__class__: haxeLanguageServer_features_hxml_CompletionFeature
});
class haxeLanguageServer_features_hxml_HoverFeature {
	constructor(context) {
		this.context = context;
		context.languageServerProtocol.onRequest("textDocument/hover",$bind(this,this.onHover));
	}
	onHover(params,token,resolve,reject) {
		let uri = params.textDocument.uri;
		let value = this.context.documents.documents.h[uri];
		let doc = ((value) instanceof haxeLanguageServer_documents_HxmlDocument) ? value : null;
		if(doc == null && haxeLanguageServer_extensions_DocumentUriExtensions_isHxmlFile(uri)) {
			doc = new haxeLanguageServer_documents_HxmlDocument(uri,"hxml",1,js_node_Fs.readFileSync(haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(uri),{ encoding : "utf8"}));
		}
		let doc1 = doc;
		if(doc1 == null) {
			haxeLanguageServer_extensions_ResponseErrorExtensions_noFittingDocument(reject,uri);
			return;
		}
		let pos = params.position;
		let hxmlContext = haxeLanguageServer_features_hxml_HxmlContextAnalyzer_analyzeHxmlContext(doc1.lineAt(pos.line),pos);
		let makeHover = function(sections) {
			return { contents : { kind : "markdown", value : sections.join("\n\n---\n")}, range : hxmlContext.range};
		};
		let _g = hxmlContext.element;
		let tmp;
		switch(_g._hx_index) {
		case 0:
			let _gflag = _g.flag;
			if(_gflag != null) {
				let signature = _gflag.name;
				if(_gflag.argument != null) {
					signature += " " + _gflag.argument.name;
				}
				tmp = makeHover([haxeLanguageServer_helper_DocHelper.printCodeBlock(signature,"hxml"),_gflag.description]);
			} else {
				tmp = null;
			}
			break;
		case 1:
			let _gvalue = _g.value;
			if(_gvalue != null) {
				let sections = [haxeLanguageServer_helper_DocHelper.printCodeBlock(_gvalue.name,"hxml")];
				if(_gvalue.description != null) {
					sections.push(_gvalue.description);
				}
				tmp = makeHover(sections);
			} else {
				tmp = null;
			}
			break;
		case 2:
			let _gdefine = _g.define;
			tmp = _gdefine != null ? makeHover([haxeLanguageServer_helper_DocHelper.printCodeBlock(haxeLanguageServer_features_hxml_data_Define.getRealName(_gdefine),"hxml"),haxeLanguageServer_features_hxml_data_Define.printDetails(_gdefine,this.context.haxeServer.haxeVersion)]) : null;
			break;
		case 3:
			tmp = null;
			break;
		default:
			tmp = null;
		}
		resolve(tmp);
	}
}
haxeLanguageServer_features_hxml_HoverFeature.__name__ = "haxeLanguageServer.features.hxml.HoverFeature";
Object.assign(haxeLanguageServer_features_hxml_HoverFeature.prototype, {
	__class__: haxeLanguageServer_features_hxml_HoverFeature
});
var haxeLanguageServer_features_hxml_HxmlElement = $hxEnums["haxeLanguageServer.features.hxml.HxmlElement"] = { __ename__:true,__constructs__:null
	,Flag: ($_=function(flag) { return {_hx_index:0,flag:flag,__enum__:"haxeLanguageServer.features.hxml.HxmlElement",toString:$estr}; },$_._hx_name="Flag",$_.__params__ = ["flag"],$_)
	,EnumValue: ($_=function(value,values) { return {_hx_index:1,value:value,values:values,__enum__:"haxeLanguageServer.features.hxml.HxmlElement",toString:$estr}; },$_._hx_name="EnumValue",$_.__params__ = ["value","values"],$_)
	,Define: ($_=function(define) { return {_hx_index:2,define:define,__enum__:"haxeLanguageServer.features.hxml.HxmlElement",toString:$estr}; },$_._hx_name="Define",$_.__params__ = ["define"],$_)
	,DefineValue: ($_=function(define,value) { return {_hx_index:3,define:define,value:value,__enum__:"haxeLanguageServer.features.hxml.HxmlElement",toString:$estr}; },$_._hx_name="DefineValue",$_.__params__ = ["define","value"],$_)
	,File: ($_=function(path) { return {_hx_index:4,path:path,__enum__:"haxeLanguageServer.features.hxml.HxmlElement",toString:$estr}; },$_._hx_name="File",$_.__params__ = ["path"],$_)
	,Directory: ($_=function(path) { return {_hx_index:5,path:path,__enum__:"haxeLanguageServer.features.hxml.HxmlElement",toString:$estr}; },$_._hx_name="Directory",$_.__params__ = ["path"],$_)
	,LibraryName: ($_=function(name) { return {_hx_index:6,name:name,__enum__:"haxeLanguageServer.features.hxml.HxmlElement",toString:$estr}; },$_._hx_name="LibraryName",$_.__params__ = ["name"],$_)
	,Unknown: {_hx_name:"Unknown",_hx_index:7,__enum__:"haxeLanguageServer.features.hxml.HxmlElement",toString:$estr}
};
haxeLanguageServer_features_hxml_HxmlElement.__constructs__ = [haxeLanguageServer_features_hxml_HxmlElement.Flag,haxeLanguageServer_features_hxml_HxmlElement.EnumValue,haxeLanguageServer_features_hxml_HxmlElement.Define,haxeLanguageServer_features_hxml_HxmlElement.DefineValue,haxeLanguageServer_features_hxml_HxmlElement.File,haxeLanguageServer_features_hxml_HxmlElement.Directory,haxeLanguageServer_features_hxml_HxmlElement.LibraryName,haxeLanguageServer_features_hxml_HxmlElement.Unknown];
function haxeLanguageServer_features_hxml_HxmlContextAnalyzer_analyzeHxmlContext(line,pos) {
	let range = haxeLanguageServer_features_hxml_HxmlContextAnalyzer_findWordRange(line,pos.character);
	line = line.substring(0,range.end);
	let _this_r = new RegExp("\\s+","".split("u").join(""));
	let parts = StringTools.ltrim(line).replace(_this_r," ").split(" ");
	let findFlag = function(word) {
		let _g = [];
		let e = haxeLanguageServer_features_hxml_data_Flags_HxmlFlags.iterator();
		while(e.hasNext()) {
			let x = $getIterator(e.next());
			while(x.hasNext()) _g.push(x.next());
		}
		return Lambda.find(_g,function(f) {
			if(!(f.name == word || f.shortName == word)) {
				let _v_ = f.deprecatedNames;
				if(_v_ == null) {
					return null;
				} else {
					return _v_.includes(word);
				}
			} else {
				return true;
			}
		});
	};
	let tmp;
	switch(parts.length) {
	case 0:
		tmp = haxeLanguageServer_features_hxml_HxmlElement.Flag();
		break;
	case 1:
		tmp = haxeLanguageServer_features_hxml_HxmlElement.Flag(findFlag(parts[0]));
		break;
	case 2:
		let arg = parts[1];
		let flag = findFlag(parts[0]);
		let _v_ = flag == null ? null : flag.argument;
		let _g = _v_ == null ? null : _v_.kind;
		if(_g == null) {
			tmp = haxeLanguageServer_features_hxml_HxmlElement.Unknown;
		} else {
			switch(_g._hx_index) {
			case 0:
				let _gvalues = _g.values;
				tmp = haxeLanguageServer_features_hxml_HxmlElement.EnumValue(Lambda.find(_gvalues,function(v) {
					return v.name == arg;
				}),_gvalues);
				break;
			case 1:
				let findDefine = function(define) {
					return Lambda.find(haxeLanguageServer_features_hxml_data_Defines_getDefines(true),function(d) {
						return haxeLanguageServer_features_hxml_data_Define.matches(d,define);
					});
				};
				let _g1 = arg.split("=");
				switch(_g1.length) {
				case 0:
					tmp = haxeLanguageServer_features_hxml_HxmlElement.Define();
					break;
				case 1:
					tmp = haxeLanguageServer_features_hxml_HxmlElement.Define(findDefine(_g1[0]));
					break;
				case 2:
					let _ga1 = _g1[1];
					let define = findDefine(_g1[0]);
					let enumValues = define == null ? null : haxeLanguageServer_features_hxml_data_Define.getEnumValues(define);
					tmp = enumValues != null ? haxeLanguageServer_features_hxml_HxmlElement.EnumValue(Lambda.find(enumValues,function(v) {
						return v.name == arg;
					}),enumValues) : haxeLanguageServer_features_hxml_HxmlElement.DefineValue(define,_ga1);
					break;
				default:
					tmp = haxeLanguageServer_features_hxml_HxmlElement.Unknown;
				}
				break;
			case 2:
				tmp = haxeLanguageServer_features_hxml_HxmlElement.File(arg);
				break;
			case 3:
				tmp = haxeLanguageServer_features_hxml_HxmlElement.Directory(arg);
				break;
			case 4:
				tmp = haxeLanguageServer_features_hxml_HxmlElement.LibraryName(arg);
				break;
			}
		}
		break;
	default:
		tmp = haxeLanguageServer_features_hxml_HxmlElement.Unknown;
	}
	return { element : tmp, range : { start : { line : pos.line, character : range.start}, end : { line : pos.line, character : range.end}}};
}
function haxeLanguageServer_features_hxml_HxmlContextAnalyzer_findWordRange(s,index) {
	let isWordBoundary = function(c) {
		if(!(StringTools.isSpace(c,0) || c == "=")) {
			return c == ":";
		} else {
			return true;
		}
	};
	let start = 0;
	let inWord = false;
	let _g = 0;
	let _g1 = s.length;
	while(_g < _g1) {
		let i = _g++;
		if(isWordBoundary(s.charAt(i))) {
			if(inWord) {
				inWord = false;
				if(start <= index && i >= index) {
					return { start : start, end : i};
				}
			}
		} else if(!inWord) {
			inWord = true;
			start = i;
		}
	}
	if(inWord) {
		return { start : start, end : s.length};
	}
	return { start : index, end : index};
}
class haxeLanguageServer_features_hxml_data_Define {
	static printDetails(this1,haxeVersion) {
		let details = new haxeLanguageServer_protocol_DisplayPrinter().printMetadataDetails({ name : haxeLanguageServer_features_hxml_data_Define.getRealName(this1), doc : this1.doc, links : this1.links, platforms : this1.platforms, parameters : this1.params, targets : [], internal : false, origin : this1.origin});
		let info = haxeLanguageServer_features_hxml_data_Defines_DefineVersions.h[this1.name];
		let since = info == null ? null : info.since;
		let until = info == null ? null : info.until;
		let youAreUsing = function() {
			if(haxeLanguageServer_features_hxml_data_Define.isAvailable(this1,haxeVersion)) {
				return "";
			} else {
				return " (you are using " + (haxeVersion == null ? "null" : haxeLanguageServer_helper_SemVer.toString(haxeVersion)) + ")";
			}
		};
		if(since != null && until != null) {
			details += "\n_Available from Haxe " + (since == null ? "null" : haxeLanguageServer_helper_SemVer.toString(since)) + " to " + (until == null ? "null" : haxeLanguageServer_helper_SemVer.toString(until)) + youAreUsing() + "_";
		} else if(since != null) {
			details += "\n_Available since Haxe " + (since == null ? "null" : haxeLanguageServer_helper_SemVer.toString(since)) + youAreUsing() + "_";
		} else if(until != null) {
			details += "\n_Available until Haxe " + (until == null ? "null" : haxeLanguageServer_helper_SemVer.toString(until)) + youAreUsing() + "_";
		}
		return details;
	}
	static normalizeName(name) {
		return StringTools.replace(name,"_","-");
	}
	static getRealName(this1) {
		return haxeLanguageServer_features_hxml_data_Define.normalizeName(this1.define);
	}
	static matches(this1,name) {
		return haxeLanguageServer_features_hxml_data_Define.normalizeName(name) == haxeLanguageServer_features_hxml_data_Define.normalizeName(this1.define);
	}
	static hasParams(this1) {
		if(this1.params == null) {
			return haxeLanguageServer_features_hxml_data_Define.getEnumValues(this1) != null;
		} else {
			return true;
		}
	}
	static isAvailable(this1,haxeVersion) {
		let info = haxeLanguageServer_features_hxml_data_Defines_DefineVersions.h[this1.name];
		if(info == null) {
			return true;
		}
		if(info.since != null && haxeLanguageServer_helper_SemVer.isGreaterThan(info.since,haxeVersion)) {
			return false;
		}
		if(info.until != null && haxeLanguageServer_helper_SemVer.isGreaterThan(haxeVersion,info.until)) {
			return false;
		}
		return true;
	}
	static getEnumValues(this1) {
		return haxeLanguageServer_features_hxml_data_Defines_DefineEnums.h[this1.name];
	}
}
class js_Boot {
	static getClass(o) {
		if(o == null) {
			return null;
		} else if(((o) instanceof Array)) {
			return Array;
		} else {
			let cl = o.__class__;
			if(cl != null) {
				return cl;
			}
			let name = js_Boot.__nativeClassName(o);
			if(name != null) {
				return js_Boot.__resolveNativeClass(name);
			}
			return null;
		}
	}
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let con = e.__constructs__[o._hx_index];
				let n = con._hx_name;
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
	static __interfLoop(cc,cl) {
		while(true) {
			if(cc == null) {
				return false;
			}
			if(cc == cl) {
				return true;
			}
			let intf = cc.__interfaces__;
			if(intf != null && (cc.__super__ == null || cc.__super__.__interfaces__ != intf)) {
				let _g = 0;
				let _g1 = intf.length;
				while(_g < _g1) {
					let i = intf[_g++];
					if(i == cl || js_Boot.__interfLoop(i,cl)) {
						return true;
					}
				}
			}
			cc = cc.__super__;
		}
	}
	static __instanceof(o,cl) {
		if(cl == null) {
			return false;
		}
		switch(cl) {
		case Array:
			return ((o) instanceof Array);
		case Bool:
			return typeof(o) == "boolean";
		case Dynamic:
			return o != null;
		case Float:
			return typeof(o) == "number";
		case Int:
			if(typeof(o) == "number") {
				return ((o | 0) === o);
			} else {
				return false;
			}
			break;
		case String:
			return typeof(o) == "string";
		default:
			if(o != null) {
				if(typeof(cl) == "function") {
					if(js_Boot.__downcastCheck(o,cl)) {
						return true;
					}
				} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
					if(((o) instanceof cl)) {
						return true;
					}
				}
			} else {
				return false;
			}
			if(cl == Class ? o.__name__ != null : false) {
				return true;
			}
			if(cl == Enum ? o.__ename__ != null : false) {
				return true;
			}
			return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
		}
	}
	static __downcastCheck(o,cl) {
		if(!((o) instanceof cl)) {
			if(cl.__isInterface__) {
				return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static __nativeClassName(o) {
		let name = js_Boot.__toStr.call(o).slice(8,-1);
		if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
			return null;
		}
		return name;
	}
	static __isNativeObj(o) {
		return js_Boot.__nativeClassName(o) != null;
	}
	static __resolveNativeClass(name) {
		return $global[name];
	}
}
js_Boot.__name__ = "js.Boot";
function haxeLanguageServer_features_hxml_data_Defines_integers(from,to) {
	let _g = [];
	let _g1 = from;
	let _g2 = to + 1;
	while(_g1 < _g2) {
		let i = _g1++;
		_g.push({ name : i == null ? "null" : "" + i});
	}
	return _g;
}
function haxeLanguageServer_features_hxml_data_Defines_getDefines(includeReserved) {
	let allDefines = haxeLanguageServer_features_hxml_data_Defines_Defines.concat(haxeLanguageServer_features_hxml_data_Defines_RemovedDefines.slice());
	if(includeReserved) {
		return allDefines;
	} else {
		let _g = [];
		let _g1 = 0;
		while(_g1 < allDefines.length) {
			let v = allDefines[_g1];
			++_g1;
			if(v.reserved != true) {
				_g.push(v);
			}
		}
		return _g;
	}
}
var haxeLanguageServer_features_hxml_data_ArgumentKind = $hxEnums["haxeLanguageServer.features.hxml.data.ArgumentKind"] = { __ename__:true,__constructs__:null
	,Enum: ($_=function(values) { return {_hx_index:0,values:values,__enum__:"haxeLanguageServer.features.hxml.data.ArgumentKind",toString:$estr}; },$_._hx_name="Enum",$_.__params__ = ["values"],$_)
	,Define: {_hx_name:"Define",_hx_index:1,__enum__:"haxeLanguageServer.features.hxml.data.ArgumentKind",toString:$estr}
	,File: {_hx_name:"File",_hx_index:2,__enum__:"haxeLanguageServer.features.hxml.data.ArgumentKind",toString:$estr}
	,Directory: {_hx_name:"Directory",_hx_index:3,__enum__:"haxeLanguageServer.features.hxml.data.ArgumentKind",toString:$estr}
	,LibraryName: {_hx_name:"LibraryName",_hx_index:4,__enum__:"haxeLanguageServer.features.hxml.data.ArgumentKind",toString:$estr}
};
haxeLanguageServer_features_hxml_data_ArgumentKind.__constructs__ = [haxeLanguageServer_features_hxml_data_ArgumentKind.Enum,haxeLanguageServer_features_hxml_data_ArgumentKind.Define,haxeLanguageServer_features_hxml_data_ArgumentKind.File,haxeLanguageServer_features_hxml_data_ArgumentKind.Directory,haxeLanguageServer_features_hxml_data_ArgumentKind.LibraryName];
var haxeLanguageServer_features_hxml_data_Category = $hxEnums["haxeLanguageServer.features.hxml.data.Category"] = { __ename__:true,__constructs__:null
	,Target: {_hx_name:"Target",_hx_index:0,__enum__:"haxeLanguageServer.features.hxml.data.Category",toString:$estr}
	,Compilation: {_hx_name:"Compilation",_hx_index:1,__enum__:"haxeLanguageServer.features.hxml.data.Category",toString:$estr}
	,Optimization: {_hx_name:"Optimization",_hx_index:2,__enum__:"haxeLanguageServer.features.hxml.data.Category",toString:$estr}
	,Debug: {_hx_name:"Debug",_hx_index:3,__enum__:"haxeLanguageServer.features.hxml.data.Category",toString:$estr}
	,Batch: {_hx_name:"Batch",_hx_index:4,__enum__:"haxeLanguageServer.features.hxml.data.Category",toString:$estr}
	,Services: {_hx_name:"Services",_hx_index:5,__enum__:"haxeLanguageServer.features.hxml.data.Category",toString:$estr}
	,CompilationServer: {_hx_name:"CompilationServer",_hx_index:6,__enum__:"haxeLanguageServer.features.hxml.data.Category",toString:$estr}
	,TargetSpecific: {_hx_name:"TargetSpecific",_hx_index:7,__enum__:"haxeLanguageServer.features.hxml.data.Category",toString:$estr}
	,Miscellaneous: {_hx_name:"Miscellaneous",_hx_index:8,__enum__:"haxeLanguageServer.features.hxml.data.Category",toString:$estr}
};
haxeLanguageServer_features_hxml_data_Category.__constructs__ = [haxeLanguageServer_features_hxml_data_Category.Target,haxeLanguageServer_features_hxml_data_Category.Compilation,haxeLanguageServer_features_hxml_data_Category.Optimization,haxeLanguageServer_features_hxml_data_Category.Debug,haxeLanguageServer_features_hxml_data_Category.Batch,haxeLanguageServer_features_hxml_data_Category.Services,haxeLanguageServer_features_hxml_data_Category.CompilationServer,haxeLanguageServer_features_hxml_data_Category.TargetSpecific,haxeLanguageServer_features_hxml_data_Category.Miscellaneous];
class haxeLanguageServer_helper_DisplayOffsetConverter {
	byteRangeToCharacterRange(range,doc) {
		return { start : { line : range.start.line, character : this.byteOffsetToCharacterOffset(doc.lineAt(range.start.line),range.start.character)}, end : { line : range.end.line, character : this.byteOffsetToCharacterOffset(doc.lineAt(range.end.line),range.end.character)}};
	}
	static create(haxeVersion) {
		if(haxeLanguageServer_helper_SemVer.isEqualOrGreaterThan(haxeVersion,{ major : 4, minor : 0, patch : 0, pre : null, build : null})) {
			return new haxeLanguageServer_helper_Haxe4DisplayOffsetConverter();
		} else {
			return new haxeLanguageServer_helper_Haxe3DisplayOffsetConverter();
		}
	}
}
haxeLanguageServer_helper_DisplayOffsetConverter.__name__ = "haxeLanguageServer.helper.DisplayOffsetConverter";
Object.assign(haxeLanguageServer_helper_DisplayOffsetConverter.prototype, {
	__class__: haxeLanguageServer_helper_DisplayOffsetConverter
});
class haxeLanguageServer_helper_Haxe3DisplayOffsetConverter extends haxeLanguageServer_helper_DisplayOffsetConverter {
	constructor() {
		super();
	}
	positionCharToZeroBasedColumn(char) {
		return char;
	}
	byteOffsetToCharacterOffset(string,byteOffset) {
		let buf = js_node_buffer_Buffer.from(string,"utf-8");
		return buf.toString("utf-8",0,byteOffset).length;
	}
	characterOffsetToByteOffset(string,offset) {
		if(offset == 0) {
			return 0;
		} else if(offset == string.length) {
			return js_node_buffer_Buffer.byteLength(string,"utf-8");
		} else {
			return js_node_buffer_Buffer.byteLength(HxOverrides.substr(string,0,offset),"utf-8");
		}
	}
}
haxeLanguageServer_helper_Haxe3DisplayOffsetConverter.__name__ = "haxeLanguageServer.helper.Haxe3DisplayOffsetConverter";
haxeLanguageServer_helper_Haxe3DisplayOffsetConverter.__super__ = haxeLanguageServer_helper_DisplayOffsetConverter;
Object.assign(haxeLanguageServer_helper_Haxe3DisplayOffsetConverter.prototype, {
	__class__: haxeLanguageServer_helper_Haxe3DisplayOffsetConverter
});
class haxeLanguageServer_helper_Haxe4DisplayOffsetConverter extends haxeLanguageServer_helper_DisplayOffsetConverter {
	constructor() {
		super();
	}
	positionCharToZeroBasedColumn(char) {
		return char - 1;
	}
	byteOffsetToCharacterOffset(string,offset) {
		let ret = offset;
		let i = 0;
		let j = 0;
		while(j < string.length && i < offset) {
			let value = HxOverrides.cca(string,j);
			if(value == null) {
				throw new safety_NullPointerException("Null pointer in .sure() call");
			}
			if(value >= 55296 && value < 56320) {
				++ret;
				++j;
			}
			++i;
			++j;
		}
		return ret;
	}
	characterOffsetToByteOffset(string,offset) {
		let ret = offset;
		let i = 0;
		let j = 0;
		while(j < string.length && i < offset) {
			let value = HxOverrides.cca(string,j);
			if(value == null) {
				throw new safety_NullPointerException("Null pointer in .sure() call");
			}
			if(value >= 55296 && value < 56320) {
				ret += -1;
				++j;
			}
			++i;
			++j;
		}
		return ret;
	}
}
haxeLanguageServer_helper_Haxe4DisplayOffsetConverter.__name__ = "haxeLanguageServer.helper.Haxe4DisplayOffsetConverter";
haxeLanguageServer_helper_Haxe4DisplayOffsetConverter.__super__ = haxeLanguageServer_helper_DisplayOffsetConverter;
Object.assign(haxeLanguageServer_helper_Haxe4DisplayOffsetConverter.prototype, {
	__class__: haxeLanguageServer_helper_Haxe4DisplayOffsetConverter
});
class haxeLanguageServer_helper_DocHelper {
	static trim(doc) {
		if(doc == null) {
			return "";
		}
		while(doc.charAt(0) == "*") doc = HxOverrides.substr(doc,1,null);
		while(doc.charAt(doc.length - 1) == "*") doc = HxOverrides.substr(doc,0,doc.length - 1);
		doc = StringTools.trim(doc);
		let ereg = new EReg("^([ \t]+(\\* )?)[^\\s\\*]","m");
		if(ereg.match(doc)) {
			let string = ereg.matched(1);
			string = string.split("* ").join("\\* ?");
			let indent_r = new RegExp("^" + string,"gm".split("u").join(""));
			doc = doc.replace(indent_r,"");
		}
		if(doc.charAt(0) == "*") {
			doc = StringTools.ltrim(HxOverrides.substr(doc,1,null));
		}
		return doc;
	}
	static markdownFormat(doc) {
		let tableLine = function(a,b) {
			return "| " + a + " | " + b + " |\n";
		};
		let tableHeader = function(a,b) {
			return "\n" + tableLine(a,b) + tableLine("------","------");
		};
		let replaceNewlines = function(s,by) {
			return StringTools.replace(StringTools.replace(s,"\n",by),"\r",by);
		};
		let mapDocTags = function(tags) {
			let result = new Array(tags.length);
			let _g = 0;
			let _g1 = tags.length;
			while(_g < _g1) {
				let i = _g++;
				let p = tags[i];
				let desc = replaceNewlines(p.doc," ");
				result[i] = tableLine("`" + p.value + "`",desc);
			}
			return result.join("");
		};
		doc = haxeLanguageServer_helper_DocHelper.trim(doc);
		let docInfos = haxeLanguageServer_helper_JavadocHelper.parse(doc);
		let result = docInfos.doc;
		let hasParams = docInfos.params.length > 0;
		let hasReturn = docInfos.returns != null;
		result += "\n";
		if(docInfos.deprecated != null) {
			result += "\n**Deprecated:** " + docInfos.deprecated.doc + "\n";
		}
		if(hasParams || hasReturn) {
			result += tableHeader("Argument","Description");
		}
		if(hasParams) {
			result += mapDocTags(docInfos.params);
		}
		if(hasReturn) {
			result += tableLine("`return`",replaceNewlines(docInfos.returns.doc," "));
		}
		if(docInfos.throws.length > 0) {
			result += tableHeader("Exception","Description") + mapDocTags(docInfos.throws);
		}
		if(docInfos.events.length > 0) {
			result += tableHeader("Event","Description") + mapDocTags(docInfos.events);
		}
		if(docInfos.sees.length > 0) {
			let _this = docInfos.sees;
			let result1 = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result1[i] = "* " + _this[i].doc;
			}
			result += "\nSee also:\n" + result1.join("\n") + "\n";
		}
		if(docInfos.since != null) {
			result += "\n_Available since " + docInfos.since.doc + "_";
		}
		return result;
	}
	static extractText(doc) {
		if(doc == null) {
			return null;
		}
		let result = "";
		let _g = 0;
		let _g1 = StringTools.trim(doc).split("\n");
		while(_g < _g1.length) {
			let line = _g1[_g];
			++_g;
			line = StringTools.trim(line);
			if(line.startsWith("*")) {
				line = HxOverrides.substr(line,1,null);
			}
			result += line == "" ? "\n\n" : line + " ";
		}
		return result;
	}
	static printCodeBlock(content,languageId) {
		return "```" + languageId + "\n" + content + "\n```";
	}
	static untrimRange(doc,range) {
		let startLine = doc.lineAt(range.start.line);
		if(haxeLanguageServer_helper_DocHelper.reStartsWhitespace.match(startLine.substring(0,range.start.character))) {
			range = { start : { line : range.start.line, character : 0}, end : range.end};
		}
		if(haxeLanguageServer_helper_DocHelper.reEndsWithWhitespace.match((range.start.line == range.end.line ? startLine : doc.lineAt(range.end.line)).substring(range.end.character))) {
			range = { start : range.start, end : { line : range.end.line + 1, character : 0}};
		}
		return range;
	}
}
haxeLanguageServer_helper_DocHelper.__name__ = "haxeLanguageServer.helper.DocHelper";
class haxeLanguageServer_helper_FormatterHelper {
	static formatText(doc,context,code,entryPoint) {
		let path;
		let origin;
		if(haxeLanguageServer_extensions_DocumentUriExtensions_isFile(doc.uri)) {
			let this1 = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc.uri);
			path = this1;
			origin = formatter_CodeOrigin.SourceFile(this1);
		} else {
			path = context.workspacePath;
			origin = formatter_CodeOrigin.Snippet;
		}
		let _g = formatter_Formatter.format(formatter_FormatterInput.Code(code,origin),formatter_Formatter.loadConfig(path),null,entryPoint);
		switch(_g._hx_index) {
		case 0:
			return _g.formattedCode;
		case 1:
			break;
		case 2:
			break;
		}
		return code;
	}
}
haxeLanguageServer_helper_FormatterHelper.__name__ = "haxeLanguageServer.helper.FormatterHelper";
class haxeLanguageServer_helper_FsHelper {
	static cp(source,destination) {
		let promises = [];
		let stats = js_node_Fs.lstatSync(source);
		if(stats.isDirectory()) {
			if(!sys_FileSystem.exists(destination)) {
				sys_FileSystem.createDirectory(destination);
			}
			let files = js_node_Fs.readdirSync(source);
			let _g = 0;
			while(_g < files.length) {
				let f = files[_g];
				++_g;
				let source1 = haxe_io_Path.join([source,f]);
				let destination1 = haxe_io_Path.join([destination,f]);
				let stats = js_node_Fs.statSync(source1);
				promises.push((stats.isDirectory() ? haxeLanguageServer_helper_FsHelper.cp : haxeLanguageServer_helper_FsHelper.copyFile)(source1,destination1));
			}
		} else if(stats.isFile()) {
			promises.push(haxeLanguageServer_helper_FsHelper.copyFile(source,destination));
		}
		return Promise.all(promises).then(function(_) {
			return null;
		});
	}
	static rmdir(path) {
		try {
			if(!js_node_Fs.existsSync(path)) {
				return Promise.resolve();
			}
			let stats = js_node_Fs.lstatSync(path);
			if(!stats.isDirectory()) {
				return haxeLanguageServer_helper_FsHelper.rmFile(path);
			}
			let _g = [];
			let _g1 = 0;
			let _g2 = js_node_Fs.readdirSync(path);
			while(_g1 < _g2.length) _g.push(haxeLanguageServer_helper_FsHelper.rmdir(haxe_io_Path.join([path,_g2[_g1++]])));
			return Promise.all(_g).then(function(_) {
				js_node_Fs.rmdirSync(path);
			});
		} catch( _g ) {
			return Promise.reject(haxe_Exception.caught(_g));
		}
	}
	static rmFile(path) {
		js_node_Fs.unlinkSync(path);
		return Promise.resolve();
	}
	static copyFile(source,destination) {
		let dir = haxe_io_Path.directory(destination);
		if(!sys_FileSystem.exists(dir)) {
			sys_FileSystem.createDirectory(dir);
		}
		sys_io_File.copy(source,destination);
		return Promise.resolve();
	}
}
haxeLanguageServer_helper_FsHelper.__name__ = "haxeLanguageServer.helper.FsHelper";
class haxeLanguageServer_helper_HaxePosition {
	static parse(pos,doc,cache,offsetConverter) {
		if(!haxeLanguageServer_helper_HaxePosition.positionRe.match(pos)) {
			return null;
		}
		let file = haxeLanguageServer_helper_HaxePosition.getProperFileNameCase(haxeLanguageServer_helper_HaxePosition.positionRe.matched(1));
		let s = haxeLanguageServer_helper_HaxePosition.positionRe.matched(3);
		if(s != null) {
			let value = Std.parseInt(s);
			if(value == null) {
				throw new safety_NullPointerException("Null pointer in .sure() call");
			}
			let endLine = Std.parseInt(haxeLanguageServer_helper_HaxePosition.positionRe.matched(4));
			return { uri : file == haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc.uri) ? doc.uri : haxeLanguageServer_extensions_FsPathExtensions_toUri(file), range : { start : { line : value - 1, character : 0}, end : { line : endLine, character : 0}}};
		} else {
			let value = Std.parseInt(haxeLanguageServer_helper_HaxePosition.positionRe.matched(2));
			let line;
			if(value == null) {
				throw new safety_NullPointerException("Null pointer in .sure() call");
			} else {
				line = value;
			}
			line = value - 1;
			let lineContent;
			let uri;
			if(file == haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(doc.uri)) {
				lineContent = doc.lineAt(line);
				uri = doc.uri;
			} else {
				let lines;
				if(cache == null) {
					lines = js_node_Fs.readFileSync(file,{ encoding : "utf8"}).split("\n");
				} else {
					lines = cache.h[file];
					if(lines == null) {
						let v = js_node_Fs.readFileSync(file,{ encoding : "utf8"}).split("\n");
						cache.h[file] = v;
						lines = v;
					}
				}
				lineContent = lines[line];
				uri = haxeLanguageServer_extensions_FsPathExtensions_toUri(file);
			}
			let value1 = Std.parseInt(haxeLanguageServer_helper_HaxePosition.positionRe.matched(6));
			if(value1 == null) {
				throw new safety_NullPointerException("Null pointer in .sure() call");
			}
			let endChar = offsetConverter.byteOffsetToCharacterOffset(lineContent,offsetConverter.positionCharToZeroBasedColumn(value1));
			s = haxeLanguageServer_helper_HaxePosition.positionRe.matched(5);
			let startChar;
			if(s != null) {
				let value = Std.parseInt(s);
				if(value == null) {
					throw new safety_NullPointerException("Null pointer in .sure() call");
				}
				startChar = offsetConverter.byteOffsetToCharacterOffset(lineContent,offsetConverter.positionCharToZeroBasedColumn(value));
			} else {
				startChar = endChar;
			}
			return { uri : uri, range : { start : { line : line, character : startChar}, end : { line : line, character : endChar}}};
		}
	}
	static getProperFileNameCase(normalizedPath) {
		if(!haxeLanguageServer_helper_HaxePosition.isWindows) {
			return normalizedPath;
		}
		if(haxeLanguageServer_helper_HaxePosition.properFileNameCaseCache != null) {
			let cached = haxeLanguageServer_helper_HaxePosition.properFileNameCaseCache.h[normalizedPath];
			if(cached != null) {
				return cached;
			}
		}
		let result = normalizedPath;
		let parts = normalizedPath.split("\\");
		if(parts.length > 1) {
			let acc = parts[0];
			let _g = 1;
			let _g1 = parts.length;
			while(_g < _g1) {
				let part = parts[_g++];
				let _g1 = 0;
				let _g2 = js_node_Fs.readdirSync(acc + "\\");
				while(_g1 < _g2.length) {
					let realFile = _g2[_g1];
					++_g1;
					if(realFile.toLowerCase() == part) {
						part = realFile;
						break;
					}
				}
				acc = acc + "/" + part;
			}
			result = acc;
		}
		haxeLanguageServer_helper_HaxePosition.properFileNameCaseCache.h[normalizedPath] = result;
		return result;
	}
}
haxeLanguageServer_helper_HaxePosition.__name__ = "haxeLanguageServer.helper.HaxePosition";
class haxeLanguageServer_helper_IdentifierHelper {
	static guessNames(args) {
		let _g = [];
		let _g1 = 0;
		while(_g1 < args.length) {
			let arg = args[_g1];
			++_g1;
			if(arg.name != null) {
				_g.push(arg.name);
			} else {
				_g.push(haxeLanguageServer_helper_IdentifierHelper.guessName(arg.type));
			}
		}
		return haxeLanguageServer_helper_IdentifierHelper.avoidDuplicates(_g);
	}
	static guessName(type) {
		if(type == null) {
			return "unknown";
		}
		type = haxeLanguageServer_helper_TypeHelper.unwrapNullable(type);
		type = haxeLanguageServer_helper_TypeHelper.getTypeWithoutParams(type);
		if(type == null) {
			if(type.startsWith("{")) {
				return "struct";
			} else {
				let segments = new EReg("(?=[A-Z][^A-Z]*$)","").split(type);
				let result = segments[segments.length - 1];
				return result.substring(0,1).toLowerCase() + HxOverrides.substr(result,1,null);
			}
		} else {
			switch(type) {
			case "":
				return "unknown";
			case "Bool":
				return "b";
			case "Dynamic":
				return "d";
			case "False":
				return "f";
			case "Float":
				return "f";
			case "Int":
				return "i";
			case "Null":
				return "n";
			case "String":
				return "s";
			case "True":
				return "t";
			case "Void":
				return "_";
			default:
				if(type.startsWith("{")) {
					return "struct";
				} else {
					let segments = new EReg("(?=[A-Z][^A-Z]*$)","").split(type);
					let result = segments[segments.length - 1];
					return result.substring(0,1).toLowerCase() + HxOverrides.substr(result,1,null);
				}
			}
		}
	}
	static avoidDuplicates(names) {
		let currentOccurrence_h = Object.create(null);
		let _g = [];
		let _g1 = 0;
		while(_g1 < names.length) {
			let name = names[_g1];
			++_g1;
			let i = currentOccurrence_h[name];
			if(i == null) {
				i = 0;
			}
			let element = name;
			if(Lambda.count(names,function(e) {
				return e == element;
			}) > 1) {
				++i;
			}
			currentOccurrence_h[name] = i;
			if(i > 0) {
				name += i;
			}
			_g.push(name);
		}
		return _g;
	}
	static addNamesToSignatureType(type,index) {
		if(index == null) {
			index = 0;
		}
		let isOptional = false;
		if(type.startsWith("?")) {
			isOptional = true;
			type = HxOverrides.substr(type,1,null);
		}
		if(type.startsWith(":")) {
			let tmp = isOptional ? "?" : "";
			let letters = 26;
			let lowerAsciiA = 97;
			let _g = [];
			let _g1 = 0;
			let _g2 = (index / letters | 0) + 1;
			while(_g1 < _g2) {
				_g1++;
				_g.push(String.fromCodePoint((lowerAsciiA + index % letters)));
			}
			return tmp + _g.join("") + type;
		} else if(type.startsWith("(")) {
			let segmentsRe = new EReg("\\((.*?)\\)\\s*:\\s*(.*)","");
			if(!segmentsRe.match(type)) {
				return type;
			}
			let args = segmentsRe.matched(1);
			let returnType = segmentsRe.matched(2);
			let _g = [];
			let _g1 = 0;
			let _g2 = new EReg("\\s*,\\s*","g").split(args);
			while(_g1 < _g2.length) _g.push(haxeLanguageServer_helper_IdentifierHelper.addNamesToSignatureType(_g2[_g1++],index++));
			return "(" + _g.join(", ") + "):" + returnType;
		}
		return type;
	}
}
haxeLanguageServer_helper_IdentifierHelper.__name__ = "haxeLanguageServer.helper.IdentifierHelper";
function haxeLanguageServer_helper_ImportHelper_createImportsEdit(doc,result,paths,style) {
	if(style == "module") {
		let f = haxeLanguageServer_helper_TypeHelper.getModule;
		let result = new Array(paths.length);
		let _g = 0;
		let _g1 = paths.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = f(paths[i]);
		}
		paths = result;
	}
	let pos = result.position;
	let importData = { start : pos, end : pos};
	let result1 = new Array(paths.length);
	let _g = 0;
	let _g1 = paths.length;
	while(_g < _g1) {
		let i = _g++;
		result1[i] = "import " + paths[i] + ";\n";
	}
	let importData1 = { range : importData, newText : result1.join("")};
	let isLineEmpty = function(delta) {
		return StringTools.trim(doc.lineAt(result.position.line + delta)).length == 0;
	};
	if(result.insertLineBefore && !isLineEmpty(-1)) {
		importData1.newText = "\n" + importData1.newText;
	}
	if(result.insertLineAfter && !isLineEmpty(0)) {
		importData1.newText += "\n";
	}
	return importData1;
}
function haxeLanguageServer_helper_ImportHelper_createFunctionImportsEdit(doc,result,context,type,formatting) {
	let importConfig = context.config.user.codeGeneration.imports;
	if(!importConfig.enableAutoImports) {
		return [];
	}
	let paths = [];
	let signature = haxeLanguageServer_protocol_Extensions_extractFunctionSignatureOrThrow(type);
	if(formatting.argumentTypeHints && (!formatting.useArrowSyntax || signature.args.length != 1)) {
		let _this = signature.args;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = haxeLanguageServer_protocol_Extensions_resolveImports(_this[i].t);
		}
		let _g2 = [];
		let e = $getIterator(result);
		while(e.hasNext()) {
			let x = $getIterator(e.next());
			while(x.hasNext()) _g2.push(x.next());
		}
		paths = paths.concat(Lambda.array(_g2));
	}
	if(haxeLanguageServer_extensions_FunctionFormattingConfigExtensions_shouldPrintReturn(formatting,signature)) {
		paths = paths.concat(haxeLanguageServer_protocol_Extensions_resolveImports(signature.ret));
	}
	paths = haxeLanguageServer_extensions_ArrayExtensions_filterDuplicates(paths,function(e1,e2) {
		return JSON.stringify(e1) == JSON.stringify(e2);
	});
	if(paths.length == 0) {
		return [];
	} else {
		let f = ($_=new haxeLanguageServer_protocol_DisplayPrinter(false,haxeLanguageServer_protocol_PathPrinting.Always),$bind($_,$_.printPath));
		let result1 = new Array(paths.length);
		let _g = 0;
		let _g1 = paths.length;
		while(_g < _g1) {
			let i = _g++;
			result1[i] = f(paths[i]);
		}
		return [haxeLanguageServer_helper_ImportHelper_createImportsEdit(doc,result,result1,importConfig.style)];
	}
}
function haxeLanguageServer_helper_ImportHelper_determineImportPosition(document) {
	let defaultResult = function() {
		return { position : { line : 0, character : 0}, insertLineAfter : true, insertLineBefore : true};
	};
	let tokens = document.get_tokens();
	if(tokens == null) {
		return defaultResult();
	}
	let firstImport = null;
	let packageStatement = null;
	let firstComment = tokens.list[0].tok._hx_index == 3 ? tokens.list[0] : null;
	tokens.tree.filterCallback(function(tree,_) {
		let _g = tree.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 34:
				packageStatement = tree;
				break;
			case 13:case 36:
				if(firstImport == null) {
					firstImport = tree;
				}
				break;
			default:
			}
			break;
		case 3:
			if(_g.s == "if") {
				if(firstImport == null) {
					firstImport = tree;
				}
			}
			break;
		default:
		}
		return tokentree_FilterResult.SkipSubtree;
	});
	if(firstImport != null) {
		return { position : document.positionAt(tokens.getPos(firstImport).min), insertLineBefore : false, insertLineAfter : false};
	} else if(packageStatement != null) {
		let lastChild = packageStatement.getLastChild();
		let pos = document.positionAt(tokens.getPos(lastChild != null ? lastChild : packageStatement).max);
		pos.line += 1;
		pos.character = 0;
		return { position : pos, insertLineAfter : true, insertLineBefore : true};
	} else if(firstComment != null) {
		let pos = document.positionAt(firstComment.pos.max);
		pos.line += 1;
		pos.character = 0;
		return { position : pos, insertLineAfter : true, insertLineBefore : true};
	} else {
		return defaultResult();
	}
}
class haxeLanguageServer_helper_JavadocHelper {
	static parse(doc) {
		let tags = [];
		doc = new EReg("^@(param|default|exception|throws|deprecated|return|returns|since|see|event|author)\\s+([^@]+)","gm").map(doc,function(e) {
			let name = e.matched(1);
			let doc = e.matched(2);
			let value = null;
			switch(name) {
			case "event":case "exception":case "param":case "throws":
				let ereg = new EReg("([^\\s]+)\\s+([\\s\\S]*)","g");
				if(ereg.match(doc)) {
					value = ereg.matched(1);
					doc = ereg.matched(2);
				} else {
					value = doc;
					doc = "";
				}
				break;
			default:
			}
			doc = haxeLanguageServer_helper_JavadocHelper.trimDoc(doc);
			tags.push({ name : name, doc : doc, value : value});
			return "";
		});
		let infos = { doc : doc, throws : [], params : [], sees : [], events : [], tags : tags};
		let _g = 0;
		while(_g < tags.length) {
			let tag = tags[_g];
			++_g;
			switch(tag.name) {
			case "default":
				infos.defaultValue = tag;
				break;
			case "deprecated":
				infos.deprecated = tag;
				break;
			case "event":
				infos.events.push(tag);
				break;
			case "param":
				infos.params.push(tag);
				break;
			case "return":case "returns":
				infos.returns = tag;
				break;
			case "see":
				infos.sees.push(tag);
				break;
			case "since":
				infos.since = tag;
				break;
			case "exception":case "throws":
				infos.throws.push(tag);
				break;
			default:
			}
		}
		return infos;
	}
	static trimDoc(doc) {
		let ereg = new EReg("^\\s+","m");
		if(ereg.match(doc)) {
			let space_r = new RegExp("^" + ereg.matched(0),"mg".split("u").join(""));
			doc = doc.replace(space_r,"");
		}
		return doc;
	}
}
haxeLanguageServer_helper_JavadocHelper.__name__ = "haxeLanguageServer.helper.JavadocHelper";
class haxeLanguageServer_helper_PathHelper {
	static matches(path,pathFilter) {
		return new EReg(pathFilter,"").match(haxeLanguageServer_helper_PathHelper.normalize(path));
	}
	static preparePathFilter(diagnosticsPathFilter,haxelibPath,workspaceRoot) {
		let path = diagnosticsPathFilter;
		path = StringTools.replace(diagnosticsPathFilter,"${workspaceRoot}",workspaceRoot);
		if(haxelibPath != null) {
			path = StringTools.replace(path,"${haxelibPath}",haxelibPath);
		}
		return haxeLanguageServer_helper_PathHelper.normalize(path);
	}
	static normalize(path) {
		let strPath = haxe_io_Path.normalize(path);
		if(haxeLanguageServer_helper_PathHelper.reUpperCaseDriveLetter.match(strPath)) {
			strPath = HxOverrides.substr(strPath,0,1).toLowerCase() + strPath.substring(1);
		}
		return strPath;
	}
}
haxeLanguageServer_helper_PathHelper.__name__ = "haxeLanguageServer.helper.PathHelper";
class haxeLanguageServer_helper_SemVer {
	static parse(s) {
		if(!haxeLanguageServer_helper_SemVer.reVersion.match(s)) {
			return null;
		}
		return { major : Std.parseInt(haxeLanguageServer_helper_SemVer.reVersion.matched(1)), minor : Std.parseInt(haxeLanguageServer_helper_SemVer.reVersion.matched(2)), patch : Std.parseInt(haxeLanguageServer_helper_SemVer.reVersion.matched(3)), pre : haxeLanguageServer_helper_SemVer.reVersion.matched(4), build : haxeLanguageServer_helper_SemVer.reVersion.matched(5)};
	}
	static isEqualOrGreaterThan(this1,other) {
		if(!haxeLanguageServer_helper_SemVer.isEqual(this1,other)) {
			return haxeLanguageServer_helper_SemVer.isGreaterThan(this1,other);
		} else {
			return true;
		}
	}
	static isGreaterThan(this1,other) {
		if(!(this1.major > other.major || this1.major == other.major && this1.minor > other.minor)) {
			if(this1.major == other.major && this1.minor == other.minor) {
				return this1.patch > other.patch;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static isEqual(this1,other) {
		if(this1.major == other.major && this1.minor == other.minor) {
			return this1.patch == other.patch;
		} else {
			return false;
		}
	}
	static toString(this1) {
		return "" + this1.major + "." + this1.minor + "." + this1.patch;
	}
	static toFullVersion(this1) {
		let ret = "" + this1.major + "." + this1.minor + "." + this1.patch;
		if(this1.pre != null) {
			ret += "-" + this1.pre;
		}
		if(this1.build != null) {
			ret += "+" + this1.build;
		}
		return ret;
	}
}
class haxeLanguageServer_helper_SnippetHelper {
	static prettify(snippet) {
		let _this_r = new RegExp("\\$\\{\\d+:(.*?)\\}","g".split("u").join(""));
		snippet = snippet.replace(_this_r,"$1");
		let _this_r1 = new RegExp("\\$\\d+","g".split("u").join(""));
		return snippet.replace(_this_r1,"|");
	}
	static offset(snippet,offset) {
		return new EReg("\\$\\{(\\d+)(:.*?)?\\}","g").map(snippet,function(regex) {
			let id = Std.parseInt(regex.matched(1));
			if(id == null) {
				return regex.matched(0);
			}
			let name = regex.matched(2);
			if(name == null) {
				name = "";
			}
			return "$" + "{" + (id + offset) + name + "}";
		});
	}
}
haxeLanguageServer_helper_SnippetHelper.__name__ = "haxeLanguageServer.helper.SnippetHelper";
class haxeLanguageServer_helper_StringHelper {
	static clean(str) {
		return str.replace(haxeLanguageServer_helper_StringHelper.stripAnsi.r,"");
	}
}
haxeLanguageServer_helper_StringHelper.__name__ = "haxeLanguageServer.helper.StringHelper";
class haxeLanguageServer_helper_TypeHelper {
	static getCloseChar(c) {
		switch(c) {
		case "(":
			return ")";
		case "<":
			return ">";
		case "{":
			return "}";
		default:
			throw haxe_Exception.thrown("unknown opening char " + c);
		}
	}
	static prepareSignature(type) {
		let _g = haxeLanguageServer_helper_TypeHelper.parseDisplayType(type);
		switch(_g._hx_index) {
		case 0:
			let _gtype = _g.type;
			if(_gtype == null) {
				return "";
			} else {
				return _gtype;
			}
			break;
		case 1:
			return haxeLanguageServer_helper_TypeHelper.printFunctionSignature(_g.args,_g.ret,{ argumentTypeHints : true, returnTypeHint : "always", useArrowSyntax : false, placeOpenBraceOnNewLine : false, explicitNull : false, explicitPrivate : false, explicitPublic : false});
		}
	}
	static printFunctionSignature(args,ret,formatting) {
		let parens = !formatting.useArrowSyntax || formatting.argumentTypeHints || args.length != 1;
		let result_b = "";
		if(parens) {
			result_b += String.fromCodePoint(40);
		}
		let _g = 0;
		let _g1 = args.length;
		while(_g < _g1) {
			let i = _g++;
			if(i > 0) {
				result_b += ", ";
			}
			result_b += Std.string(haxeLanguageServer_helper_TypeHelper.printSignatureArgument(i,args[i],formatting.argumentTypeHints));
		}
		if(parens) {
			result_b += String.fromCodePoint(41);
		}
		if(haxeLanguageServer_helper_TypeHelper.shouldPrintReturnType(ret,formatting.returnTypeHint) && !formatting.useArrowSyntax) {
			result_b += String.fromCodePoint(58);
			result_b += Std.string(ret.replace(haxeLanguageServer_helper_TypeHelper.packagePathsRegex.r,""));
		}
		return result_b;
	}
	static shouldPrintReturnType(ret,option) {
		if(ret == null) {
			return false;
		}
		switch(option) {
		case "always":
			return true;
		case "never":
			return false;
		case "non-void":
			return ret != "Void";
		}
	}
	static printSignatureArgument(index,arg,typeHints) {
		let result = arg.name != null ? arg.name : String.fromCodePoint((97 + index));
		if(arg.opt == true) {
			result = "?" + result;
		}
		if(arg.type != null && typeHints) {
			result += ":";
			result += arg.type;
		}
		return result;
	}
	static printFunctionType(args,ret) {
		let result_b = "";
		result_b += String.fromCodePoint(40);
		let _g = 0;
		let _g1 = args.length;
		while(_g < _g1) {
			let i = _g++;
			if(i > 0) {
				result_b += ", ";
			}
			result_b += Std.string(haxeLanguageServer_helper_TypeHelper.printSignatureArgument(i,args[i],true));
		}
		result_b += ") -> ";
		result_b += Std.string(ret == null ? "Unknown" : ret);
		return result_b;
	}
	static unwrapNullable(type) {
		while(type.startsWith("Null<") && type.endsWith(">")) type = type.substring("Null<".length,type.length - 1);
		return type;
	}
	static getTypeWithoutParams(type) {
		let index = type.indexOf("<");
		if(index >= 0) {
			return type.substring(0,index);
		}
		return type;
	}
	static getModule(packagePath) {
		if(haxeLanguageServer_helper_TypeHelper.subtypePackageRegex.match(packagePath)) {
			return haxeLanguageServer_extensions_StringExtensions_untilLastDot(packagePath);
		}
		return packagePath;
	}
	static parseDisplayType(type) {
		type = StringTools.replace(type," -> ","%");
		let toplevel_b = "";
		let groups_h = { };
		let closeStack = new haxe_ds_GenericStack();
		let depth = 0;
		let groupId = 0;
		let _g = 0;
		let _g1 = type.length;
		while(_g < _g1) {
			let char = type.charAt(_g++);
			if(char == "(" || char == "<" || char == "{") {
				++depth;
				closeStack.head = new haxe_ds_GenericCell(haxeLanguageServer_helper_TypeHelper.getCloseChar(char),closeStack.head);
				if(depth == 1) {
					++groupId;
					groups_h[groupId] = new StringBuf();
					toplevel_b += char == null ? "null" : "" + char;
					toplevel_b += Std.string("$" + groupId);
					continue;
				}
			} else if(char == (closeStack.head == null ? null : closeStack.head.elt)) {
				let k = closeStack.head;
				if(k != null) {
					closeStack.head = k.next;
				}
				--depth;
			}
			if(depth == 0) {
				toplevel_b += char == null ? "null" : "" + char;
			} else {
				groups_h[groupId].b += char == null ? "null" : "" + char;
			}
		}
		let processType = function(type) {
			type = haxeLanguageServer_helper_TypeHelper.groupRegex.map(type,function(r) {
				let groupId = Std.parseInt(r.matched(1));
				if(groupId == null) {
					return "";
				}
				return StringTools.replace(groups_h[groupId].b,"%","->");
			});
			if(haxeLanguageServer_helper_TypeHelper.parenRegex.match(type)) {
				type = haxeLanguageServer_helper_TypeHelper.parenRegex.matched(1);
			}
			return type;
		};
		let parts = toplevel_b.split("%");
		let returnType = processType(parts.pop());
		if(haxeLanguageServer_helper_TypeHelper.monomorphRegex.match(returnType)) {
			returnType = null;
		}
		if(parts.length > 0) {
			let args = [];
			let _g = 0;
			let _g1 = parts.length;
			while(_g < _g1) {
				let part = parts[_g++];
				let name;
				let type;
				let opt = false;
				if(haxeLanguageServer_helper_TypeHelper.argNameRegex.match(part)) {
					name = haxeLanguageServer_helper_TypeHelper.argNameRegex.matched(1);
					if(HxOverrides.cca(name,0) == 63) {
						name = name.substring(1);
						opt = true;
					}
					type = haxeLanguageServer_helper_TypeHelper.argNameRegex.matchedRight();
				} else {
					name = null;
					type = part;
					if(HxOverrides.cca(part,0) == 63) {
						type = part.substring(1);
						opt = true;
					}
				}
				if(opt && haxeLanguageServer_helper_TypeHelper.nullRegex.match(type)) {
					type = haxeLanguageServer_helper_TypeHelper.nullRegex.matched(1);
				}
				type = processType(type);
				if(type == "Void") {
					continue;
				}
				let arg = { name : name};
				if(!haxeLanguageServer_helper_TypeHelper.monomorphRegex.match(type)) {
					arg.type = type;
				}
				if(opt) {
					arg.opt = true;
				}
				args.push(arg);
			}
			return haxeLanguageServer_helper_DisplayType.DTFunction(args,returnType);
		} else {
			return haxeLanguageServer_helper_DisplayType.DTValue(returnType);
		}
	}
}
haxeLanguageServer_helper_TypeHelper.__name__ = "haxeLanguageServer.helper.TypeHelper";
var haxeLanguageServer_helper_DisplayType = $hxEnums["haxeLanguageServer.helper.DisplayType"] = { __ename__:true,__constructs__:null
	,DTValue: ($_=function(type) { return {_hx_index:0,type:type,__enum__:"haxeLanguageServer.helper.DisplayType",toString:$estr}; },$_._hx_name="DTValue",$_.__params__ = ["type"],$_)
	,DTFunction: ($_=function(args,ret) { return {_hx_index:1,args:args,ret:ret,__enum__:"haxeLanguageServer.helper.DisplayType",toString:$estr}; },$_._hx_name="DTFunction",$_.__params__ = ["args","ret"],$_)
};
haxeLanguageServer_helper_DisplayType.__constructs__ = [haxeLanguageServer_helper_DisplayType.DTValue,haxeLanguageServer_helper_DisplayType.DTFunction];
class haxeLanguageServer_helper_WorkspaceEditHelper {
	static createNewFile(uri,overwrite,ignoreIfExists) {
		return { kind : "create", uri : uri, options : { overwrite : overwrite, ignoreIfExists : ignoreIfExists}};
	}
	static textDocumentEdit(uri,edits) {
		return { textDocument : { uri : uri, version : null}, edits : edits};
	}
	static insertText(pos,newText) {
		return { range : { start : pos, end : pos}, newText : newText};
	}
	static replaceText(range,newText) {
		return { range : range, newText : newText};
	}
	static removeText(range) {
		return { range : range, newText : ""};
	}
}
haxeLanguageServer_helper_WorkspaceEditHelper.__name__ = "haxeLanguageServer.helper.WorkspaceEditHelper";
var haxeLanguageServer_protocol_PathPrinting = $hxEnums["haxeLanguageServer.protocol.PathPrinting"] = { __ename__:true,__constructs__:null
	,Always: {_hx_name:"Always",_hx_index:0,__enum__:"haxeLanguageServer.protocol.PathPrinting",toString:$estr}
	,Never: {_hx_name:"Never",_hx_index:1,__enum__:"haxeLanguageServer.protocol.PathPrinting",toString:$estr}
	,Qualified: {_hx_name:"Qualified",_hx_index:2,__enum__:"haxeLanguageServer.protocol.PathPrinting",toString:$estr}
	,Shadowed: {_hx_name:"Shadowed",_hx_index:3,__enum__:"haxeLanguageServer.protocol.PathPrinting",toString:$estr}
};
haxeLanguageServer_protocol_PathPrinting.__constructs__ = [haxeLanguageServer_protocol_PathPrinting.Always,haxeLanguageServer_protocol_PathPrinting.Never,haxeLanguageServer_protocol_PathPrinting.Qualified,haxeLanguageServer_protocol_PathPrinting.Shadowed];
class haxeLanguageServer_protocol_DisplayPrinter {
	constructor(wrap,pathPrinting,functionFormatting) {
		if(pathPrinting == null) {
			pathPrinting = haxeLanguageServer_protocol_PathPrinting.Qualified;
		}
		if(wrap == null) {
			wrap = false;
		}
		this.indent = "";
		this.wrap = wrap;
		this.pathPrinting = pathPrinting;
		this.functionFormatting = functionFormatting == null ? { useArrowSyntax : true, returnTypeHint : "non-void", argumentTypeHints : true, placeOpenBraceOnNewLine : false, explicitPublic : false, explicitPrivate : false, explicitNull : false} : functionFormatting;
	}
	collectQualifiedPaths() {
		let previous = this.qualifiedPaths;
		let current = this.qualifiedPaths = [];
		let _gthis = this;
		return function() {
			_gthis.qualifiedPaths = previous;
			return current;
		};
	}
	printPath(path) {
		let qualified;
		switch(this.pathPrinting._hx_index) {
		case 0:
			qualified = true;
			break;
		case 1:
			qualified = false;
			break;
		case 2:
			qualified = path.importStatus != 0;
			break;
		case 3:
			qualified = path.importStatus == 2;
			break;
		}
		let isSubType = path.moduleName != path.typeName;
		if(path.pack.length == 0 && !isSubType && path.importStatus == 2) {
			path.pack.push("std");
		}
		let printFullPath = function() {
			let printedPath = path.moduleName + (isSubType ? "." + path.typeName : "");
			if(path.pack.length > 0) {
				printedPath = path.pack.join(".") + "." + printedPath;
			}
			return printedPath;
		};
		if(qualified) {
			return printFullPath();
		} else {
			if(path.importStatus == 1 && this.qualifiedPaths != null) {
				this.qualifiedPaths.push(printFullPath());
			}
			return path.typeName;
		}
	}
	printPathWithParams(path) {
		let s = this.printPath(path.path);
		if(path.params.length == 0) {
			return s;
		} else {
			let _this = path.params;
			let f = $bind(this,this.printType);
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = f(_this[i]);
			}
			return "" + s + "<" + result.join(", ") + ">";
		}
	}
	printType(t) {
		let _gthis = this;
		switch(t.kind) {
		case "TAbstract":case "TEnum":case "TInst":case "TType":
			return this.printPathWithParams(t.args);
		case "TAnonymous":
			let fields = t.args.fields;
			let _g = [];
			let _g1 = 0;
			while(_g1 < fields.length) {
				let field = fields[_g1];
				++_g1;
				_g.push("" + (haxeLanguageServer_protocol_Extensions_hasMeta(field.meta,":optional") ? "?" : "") + field.name + ":" + this.printTypeRec(field.type));
			}
			return "{" + _g.join(", ") + "}";
		case "TDynamic":
			if(t.args == null) {
				return "Dynamic";
			} else {
				return "Dynamic<" + this.printTypeRec(t.args) + ">";
			}
			break;
		case "TFun":
			let hasNamed = false;
			let printFunctionArgument = function(arg) {
				if(arg.name != "") {
					hasNamed = true;
				}
				return _gthis.printFunctionArgument(arg);
			};
			let _this = t.args.args;
			let f = printFunctionArgument;
			let result = new Array(_this.length);
			let _g2 = 0;
			let _g3 = _this.length;
			while(_g2 < _g3) {
				let i = _g2++;
				result[i] = f(_this[i]);
			}
			let r = this.printTypeRec(t.args.ret);
			switch(result.length) {
			case 0:
				return "() -> " + r;
			case 1:
				if(hasNamed) {
					return "(" + result[0] + ") -> " + r;
				} else {
					return "" + result[0] + " -> " + r;
				}
				break;
			default:
				if(Lambda.fold(result,function(args,i) {
					return i + args.length;
				},0) < 50 || !this.wrap) {
					return "(" + result.join(", ") + ") -> " + r;
				} else {
					return "(" + result.join(",\n " + this.indent) + ")\n" + this.indent + "-> " + r;
				}
			}
			break;
		case "TMono":
			return "?";
		}
	}
	printTypeRec(t) {
		let old = this.indent;
		this.indent += "  ";
		let t1 = this.printType(t);
		this.indent = old;
		return t1;
	}
	printFunctionArgument(arg) {
		let nullRemoval = haxeLanguageServer_protocol_Extensions_removeNulls(arg.t);
		let concreteType = this.functionFormatting.explicitNull || !arg.opt ? arg.t : nullRemoval.type;
		let argument = (arg.opt && arg.value == null ? "?" : "") + arg.name;
		if(this.functionFormatting.argumentTypeHints && (concreteType.kind != "TMono" || arg.name == "")) {
			argument += (arg.name == "" ? "" : ":") + this.printTypeRec(concreteType);
		}
		if(arg.value != null) {
			argument += " = " + arg.value.string;
		}
		return argument;
	}
	printCallArguments(signature,printFunctionArgument) {
		let _this = signature.args;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = printFunctionArgument(_this[i]);
		}
		return "(" + result.join(", ") + ")";
	}
	printTypeParameters(params) {
		if(params.length == 0) {
			return "";
		} else {
			let result = new Array(params.length);
			let _g = 0;
			let _g1 = params.length;
			while(_g < _g1) {
				let i = _g++;
				let param = params[i];
				let s = param.name;
				if(param.constraints.length > 0) {
					let _this = param.constraints;
					let result = new Array(_this.length);
					let _g = 0;
					let _g1 = _this.length;
					while(_g < _g1) {
						let i = _g++;
						result[i] = this.printTypeRec(_this[i]);
					}
					s += ":" + result.join(" & ");
				}
				result[i] = s;
			}
			return "<" + result.join(", ") + ">";
		}
	}
	printReturn(signature) {
		if(signature.ret.kind == "TMono") {
			return "";
		}
		if(haxeLanguageServer_extensions_FunctionFormattingConfigExtensions_shouldPrintReturn(this.functionFormatting,signature)) {
			return ":" + this.printTypeRec(signature.ret);
		} else {
			return "";
		}
	}
	printEmptyFunctionDefinition(name,signature,params) {
		return "function " + name + (params == null ? "" : this.printTypeParameters(params)) + this.printCallArguments(signature,$bind(this,this.printFunctionArgument)) + this.printReturn(signature);
	}
	printOverrideDefinition(field,concreteType,indent,snippets) {
		let access = field.isPublic ? "public " : "private ";
		if(field.isPublic && !this.functionFormatting.explicitPublic) {
			access = "";
		}
		if(!field.isPublic && !this.functionFormatting.explicitPrivate) {
			access = "";
		}
		let signature = haxeLanguageServer_protocol_Extensions_extractFunctionSignatureOrThrow(concreteType);
		let returnKeyword = haxeLanguageServer_protocol_DotPath_getDotPath(signature.ret) == "StdTypes.Void" ? "" : "return ";
		let $arguments = this.printCallArguments(signature,function(arg) {
			return arg.name;
		});
		let lineBreak = this.functionFormatting.placeOpenBraceOnNewLine ? "\n" : " ";
		let definition = access + this.printEmptyFunctionDefinition(field.name,signature,field.params) + ("" + lineBreak + "{\n" + indent);
		let superCall = "" + returnKeyword + "super." + field.name + $arguments + ";";
		if(snippets) {
			return definition + ("$" + "{1:" + superCall + "}$0" + "\n}");
		} else {
			return definition + superCall + "\n}";
		}
	}
	printCommonFieldModifiers(buf,field,moduleLevelField) {
		if(field.isPublic) {
			if(!moduleLevelField) {
				buf.b += "public ";
			}
		} else if(this.functionFormatting.explicitPrivate) {
			buf.b += "private ";
		}
		if(field.scope == 0 && !moduleLevelField) {
			buf.b += "static ";
		}
	}
	printMethodImplementation(field,concreteType,withOverride,moduleLevelField,expressions,tab) {
		if(tab == null) {
			tab = "\t";
		}
		let buf = new StringBuf();
		let signature = haxeLanguageServer_protocol_Extensions_extractFunctionSignatureOrThrow(concreteType);
		let lineBreak = this.functionFormatting.placeOpenBraceOnNewLine ? "\n" : " ";
		if(haxeLanguageServer_protocol_Extensions_hasMeta(field.meta,":overload")) {
			buf.b += "overload ";
		}
		if(withOverride) {
			buf.b += "override ";
		}
		this.printCommonFieldModifiers(buf,field,moduleLevelField);
		let x = this.printEmptyFunctionDefinition(field.name,signature,field.params);
		buf.b += Std.string(x);
		buf.b = (buf.b += lineBreak == null ? "null" : "" + lineBreak) + "{";
		if(expressions.length > 0) {
			let _g = 0;
			while(_g < expressions.length) {
				let expr = expressions[_g];
				++_g;
				buf.b += "\n";
				buf.b = (buf.b += Std.string(this.indent)) + (tab == null ? "null" : "" + tab);
				buf.b = (buf.b += tab == null ? "null" : "" + tab) + (expr == null ? "null" : "" + expr);
				buf.b += ";";
			}
			buf.b += "\n";
			buf.b = (buf.b += Std.string(this.indent)) + (tab == null ? "null" : "" + tab);
		}
		buf.b += "}\n";
		return buf.b;
	}
	printVarImplementation(field,args,concreteType,moduleLevelField) {
		let buf = new StringBuf();
		this.printCommonFieldModifiers(buf,field,moduleLevelField);
		if(haxeLanguageServer_protocol_Extensions_isFinalField(field)) {
			buf.b += "final ";
			buf.b += Std.string(field.name);
		} else {
			buf.b += "var ";
			buf.b += Std.string(field.name);
			let x = this.printAccessors(args);
			buf.b += Std.string(x);
		}
		buf.b += ":";
		let x = this.printType(field.type);
		buf.b += Std.string(x);
		buf.b += ";\n";
		return buf.b;
	}
	printClassFieldImplementation(field,concreteType,withOverride,moduleLevelField,expressions,tab) {
		if(tab == null) {
			tab = "\t";
		}
		switch(field.kind.kind) {
		case "FMethod":
			return this.printMethodImplementation(field,concreteType,withOverride,moduleLevelField,expressions,tab);
		case "FVar":
			return this.printVarImplementation(field,field.kind.args,concreteType,moduleLevelField);
		}
	}
	printAccessors(args) {
		let read = this.printAccessor(args.read,true);
		let write = this.printAccessor(args.write,false);
		return read != null && write != null && (read != "default" || write != "default") ? "(" + read + ", " + write + ")" : "";
	}
	printClassFieldDefinition(occurrence,concreteType,isEnumAbstractField) {
		let field = occurrence.field;
		if(concreteType.kind == "TMono") {
			concreteType = field.type;
		}
		let type = this.printType(concreteType);
		let name = field.name;
		let kind = field.kind;
		let access = field.isPublic ? "public " : "private ";
		let staticKeyword = field.scope == 0 && !haxeLanguageServer_protocol_Extensions_isModuleLevel(occurrence.origin) ? "static " : "";
		switch(kind.kind) {
		case "FMethod":
			let methodKind;
			switch(kind.args) {
			case "MethDynamic":
				methodKind = "dynamic ";
				break;
			case "MethInline":
				methodKind = "inline ";
				break;
			case "MethMacro":
				methodKind = "macro ";
				break;
			case "MethNormal":
				methodKind = "";
				break;
			}
			return "" + access + staticKeyword + (haxeLanguageServer_protocol_Extensions_isFinalField(field) ? "final " : "") + (field.isAbstract ? "abstract " : "") + methodKind + this.printEmptyFunctionDefinition(name,haxeLanguageServer_protocol_Extensions_extractFunctionSignatureOrThrow(concreteType),field.params);
		case "FVar":
			let inlineKeyword = kind.args.write.kind == "AccInline" ? "inline " : "";
			let isFinal = kind.args.write.kind == "AccCtor" || haxeLanguageServer_protocol_Extensions_isFinalField(field);
			let accessors = isFinal ? "" : this.printAccessors(kind.args);
			if(haxeLanguageServer_protocol_Extensions_isStructure(occurrence.origin)) {
				access = "";
				if(haxeLanguageServer_protocol_Extensions_hasMeta(field.meta,":optional")) {
					name = "?" + name;
				}
			} else if(isEnumAbstractField) {
				access = "";
				staticKeyword = "";
			}
			let definition = "" + access + staticKeyword + (isFinal ? "final" : "var") + " " + inlineKeyword + name + accessors + ":" + type;
			if(field.expr != null) {
				definition += " = " + field.expr.string.replace(haxeLanguageServer_protocol_DisplayPrinter.castRegex.r,"");
			}
			return definition;
		}
	}
	printAccessor(access,isRead) {
		switch(access.kind) {
		case "AccCall":
			if(isRead) {
				return "get";
			} else {
				return "set";
			}
			break;
		case "AccCtor":
			return null;
		case "AccInline":
			return null;
		case "AccNever":
			return "never";
		case "AccNo":
			return "null";
		case "AccNormal":
			return "default";
		case "AccRequire":
			return null;
		case "AccResolve":
			return null;
		}
	}
	printLocalDefinition(local,concreteType) {
		let _g = local.origin;
		if(_g == 5) {
			return (local.isInline ? "inline " : "") + this.printEmptyFunctionDefinition(local.name,haxeLanguageServer_protocol_Extensions_extractFunctionSignatureOrThrow(concreteType),local.extra == null ? null : local.extra.params);
		} else {
			let keyword = local.isFinal ? "final " : "var ";
			let name = local.name;
			if(_g == 1) {
				keyword = "";
				if(haxeLanguageServer_protocol_Extensions_removeNulls(concreteType).nullable) {
					name = "?" + name;
				}
			}
			return "" + keyword + name + ":" + this.printType(concreteType);
		}
	}
	printEmptyTypeDefinition(type) {
		let components = [];
		if(type.isPrivate) {
			components.push("private");
		}
		if(haxeLanguageServer_protocol_Extensions_isFinalType(type)) {
			components.push("final");
		}
		if(type.isExtern) {
			components.push("extern");
		}
		if(type.isAbstract) {
			components.push("abstract");
		}
		let tmp;
		switch(type.kind) {
		case 0:
			tmp = "class";
			break;
		case 1:
			tmp = "interface";
			break;
		case 2:
			tmp = "enum";
			break;
		case 3:
			tmp = "abstract";
			break;
		case 4:
			tmp = "enum abstract";
			break;
		case 5:case 6:
			tmp = "typedef";
			break;
		}
		components.push(tmp);
		let typeName = type.path.typeName;
		if(type.params.length > 0) {
			let _this = type.params;
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = _this[i].name;
			}
			typeName += "<" + result.join(", ") + ">";
		}
		components.push(typeName);
		return components.join(" ");
	}
	printClassFieldOrigin(origin,kind,quote) {
		if(quote == null) {
			quote = "";
		}
		if(origin == null) {
			return null;
		}
		if(kind == "EnumAbstractField" || origin.kind == 6) {
			return null;
		}
		if(origin.args == null && origin.kind != 5) {
			return null;
		}
		let printTypeKind = function(type) {
			switch(type.kind) {
			case "abstract":
				if(haxeLanguageServer_protocol_Extensions_hasMeta(type.meta,":enum")) {
					return "enum abstract";
				} else {
					return "abstract";
				}
				break;
			case "class":
				if(type.args.isInterface) {
					return "interface";
				} else {
					return "class";
				}
				break;
			case "enum":
				return "enum";
			case "typedef":
				return "typedef";
			}
		};
		let printTypeInfo = function(type) {
			return (haxeLanguageServer_protocol_Extensions_isModuleLevel(origin) ? "module" : printTypeKind(type)) + " " + (quote + (haxeLanguageServer_protocol_Extensions_isModuleLevel(origin) ? type.moduleName : type.name) + quote);
		};
		let tmp;
		switch(origin.kind) {
		case 0:
			tmp = printTypeInfo(origin.args);
			break;
		case 1:
			tmp = printTypeInfo(origin.args) + " (statically imported)";
			break;
		case 2:
			tmp = "parent " + printTypeInfo(origin.args);
			break;
		case 3:
			tmp = printTypeInfo(origin.args) + " (static extension method)";
			break;
		case 4:
			tmp = "anonymous structure";
			break;
		case 5:
			tmp = "compiler (built-in)";
			break;
		case 6:
			tmp = "";
			break;
		}
		return "from " + tmp;
	}
	printEnumFieldOrigin(origin,quote) {
		if(quote == null) {
			quote = "";
		}
		if(origin == null || origin.args == null) {
			return null;
		}
		let tmp;
		switch(origin.kind) {
		case 0:
			tmp = "" + quote + origin.args.name + quote;
			break;
		case 1:
			tmp = "" + quote + origin.args.name + quote + " (statically imported)";
			break;
		}
		return "from enum " + tmp;
	}
	printLocalOrigin(origin) {
		switch(origin) {
		case 0:
			return "local variable";
		case 1:
			return "argument";
		case 2:
			return "for loop variable";
		case 3:
			return "pattern variable";
		case 4:
			return "catch variable";
		case 5:
			return "local function";
		}
	}
	printEnumField(field,concreteType,snippets,typeHints) {
		switch(concreteType.kind) {
		case "TEnum":
			return field.name;
		case "TFun":
			let signature = concreteType.args;
			let text = "" + field.name + "(";
			let _g = 0;
			let _g1 = signature.args.length;
			while(_g < _g1) {
				let i = _g++;
				let arg = signature.args[i];
				text += snippets ? "$" + "{" + (i + 1) + ":" + arg.name + "}" : arg.name;
				if(typeHints) {
					text += ":" + this.printTypeRec(arg.t);
				}
				if(i < signature.args.length - 1) {
					text += ", ";
				}
			}
			return text + ")";
		default:
			return "";
		}
	}
	printAnonymousFunctionDefinition(signature) {
		let _this = signature.args;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			let arg = _this[i];
			result[i] = { name : arg.name == "" ? null : arg.name, opt : arg.opt, type : new haxeLanguageServer_protocol_DisplayPrinter(null,haxeLanguageServer_protocol_PathPrinting.Never).printTypeRec(arg.t)};
		}
		let names = haxeLanguageServer_helper_IdentifierHelper.guessNames(result);
		let printedArgs = [];
		let singleArgument = result.length == 1;
		if(singleArgument && this.functionFormatting.useArrowSyntax) {
			printedArgs = [names[0]];
		} else {
			let _g = 0;
			let _g1 = result.length;
			while(_g < _g1) {
				let i = _g++;
				printedArgs.push(this.printFunctionArgument({ t : signature.args[i].t, opt : result[i].opt, name : names[i]}));
			}
		}
		let printedArguments = printedArgs.join(", ");
		if(this.functionFormatting.useArrowSyntax) {
			if(!singleArgument) {
				printedArguments = "(" + printedArguments + ")";
			}
			return printedArguments + " -> ";
		} else {
			return "function(" + printedArguments + ")" + this.printReturn(signature) + " ";
		}
	}
	printObjectLiteral(anon,singleLine,onlyRequiredFields,snippets) {
		let printedFields = [];
		let _g = 0;
		let _g1 = anon.fields.length;
		while(_g < _g1) {
			let i = _g++;
			let field = anon.fields[i];
			let name = field.name;
			let printedField = name + ": ";
			if(!singleLine) {
				printedField = "\t" + printedField;
			}
			printedField += snippets ? "$" + "{" + (i + 1) + ":" + name + "}" : name;
			if(!onlyRequiredFields || !haxeLanguageServer_protocol_Extensions_hasMeta(field.meta,":optional")) {
				printedFields.push(printedField);
			}
		}
		if(printedFields.length == 0) {
			return "{}";
		} else if(singleLine) {
			return "{" + printedFields.join(", ") + "}";
		} else {
			return "{\n" + printedFields.join(",\n") + "\n}";
		}
	}
	printSwitchSubject(subject,parentheses) {
		return "switch " + (parentheses ? "(" + subject + ")" : subject);
	}
	printSwitchOnEnum(subject,e,nullable,snippets,parentheses) {
		let _this = e.constructors;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			let field = _this[i];
			result[i] = this.printEnumField(field,field.type,false,false);
		}
		return this.printSwitch(subject,result,nullable,snippets,parentheses);
	}
	printSwitchOnEnumAbstract(subject,a,nullable,snippets,parentheses) {
		let fields;
		if(a.impl == null) {
			fields = [];
		} else {
			let _this = a.impl.statics;
			let _g = [];
			let _g1 = 0;
			while(_g1 < _this.length) {
				let v = _this[_g1];
				++_g1;
				if(haxeLanguageServer_protocol_Extensions_isEnumAbstractField(v)) {
					_g.push(v);
				}
			}
			let result = new Array(_g.length);
			let _g2 = 0;
			let _g3 = _g.length;
			while(_g2 < _g3) {
				let i = _g2++;
				result[i] = _g[i].name;
			}
			fields = result;
		}
		return this.printSwitch(subject,fields,nullable,snippets,parentheses);
	}
	printSwitch(subject,fields,nullable,snippets,parentheses) {
		if(nullable) {
			fields.unshift("null");
		}
		let _g = 0;
		let _g1 = fields.length;
		while(_g < _g1) {
			let i = _g++;
			let field = fields[i];
			field = "\tcase " + field + ":";
			if(snippets) {
				field += "$" + (i + 1);
			}
			fields[i] = field;
		}
		return this.printSwitchSubject(subject,parentheses) + (" {\n" + fields.join("\n") + "\n}");
	}
	printMetadataTarget(target) {
		switch(target) {
		case "TAbstract":
			return "abstracts";
		case "TAbstractField":
			return "abstract fields";
		case "TAnyField":
			return "any field";
		case "TClass":
			return "classes";
		case "TClassField":
			return "class fields";
		case "TEnum":
			return "enums";
		case "TExpr":
			return "expressions";
		case "TTypeParameter":
			return "type parameters";
		case "TTypedef":
			return "typedefs";
		}
	}
	printPlatform(platform) {
		switch(platform) {
		case "cpp":
			return "C++";
		case "cross":
			return "cross";
		case "cs":
			return "C#";
		case "eval":
			return "Eval";
		case "flash":
			return "Flash";
		case "hl":
			return "HashLink";
		case "java":
			return "Java";
		case "js":
			return "JavaScript";
		case "lua":
			return "Lua";
		case "neko":
			return "Neko";
		case "php":
			return "PHP";
		case "python":
			return "Python";
		}
	}
	printMetadataDetails(metadata) {
		let details = metadata.doc + "\n";
		if(metadata.parameters != null) {
			let list = metadata.parameters;
			details += list.length == 0 ? "" : "- **" + "Parameters" + ":** " + list.join(", ") + "\n";
		}
		if(metadata.platforms != null) {
			let _this = metadata.platforms;
			let f = $bind(this,this.printPlatform);
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = f(_this[i]);
			}
			details += result.length == 0 ? "" : "- **" + "Targets" + ":** " + result.join(", ") + "\n";
		}
		if(metadata.targets != null) {
			let _this = metadata.targets;
			let f = $bind(this,this.printMetadataTarget);
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = f(_this[i]);
			}
			details += result.length == 0 ? "" : "- **" + "Can be used on" + ":** " + result.join(", ") + "\n";
		}
		if(metadata.links != null && metadata.links.length > 0) {
			let _this = metadata.links;
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = "- " + _this[i];
			}
			details += result.join("\n");
		}
		if(metadata.internal) {
			details += "\n_compiler-internal_";
		}
		return details;
	}
	printArrayAccess(signature) {
		let index = this.printFunctionArgument(signature.args[0]);
		if(signature.args.length > 1) {
			return "[" + index + "] = " + this.printFunctionArgument(signature.args[1]);
		} else {
			return "[" + index + "] -> " + this.printType(signature.ret);
		}
	}
}
haxeLanguageServer_protocol_DisplayPrinter.__name__ = "haxeLanguageServer.protocol.DisplayPrinter";
Object.assign(haxeLanguageServer_protocol_DisplayPrinter.prototype, {
	__class__: haxeLanguageServer_protocol_DisplayPrinter
});
class haxeLanguageServer_protocol_DotPath {
	static _new(dotPath) {
		return dotPath;
	}
}
function haxeLanguageServer_protocol_DotPath_getDotPath(type) {
	let path = haxeLanguageServer_protocol_Extensions_getTypePath(type);
	if(path == null) {
		return null;
	}
	return haxeLanguageServer_protocol_DotPath_getDotPath2(path.path);
}
function haxeLanguageServer_protocol_DotPath_getDotPath2(path) {
	return haxeLanguageServer_protocol_DotPath._new(new haxeLanguageServer_protocol_DisplayPrinter(null,haxeLanguageServer_protocol_PathPrinting.Always).printPath(path));
}
function haxeLanguageServer_protocol_Extensions_getDocumentation(item) {
	switch(item.kind) {
	case "ClassField":case "EnumAbstractField":
		return item.args.field.doc;
	case "EnumField":
		return item.args.field.doc;
	case "Metadata":
		return new haxeLanguageServer_protocol_DisplayPrinter().printMetadataDetails(item.args);
	case "Type":
		return item.args.doc;
	default:
		return null;
	}
}
function haxeLanguageServer_protocol_Extensions_extractFunctionSignatureOrThrow(type) {
	let value = haxeLanguageServer_protocol_Extensions_extractFunctionSignature(type);
	if(value == null) {
		throw new safety_NullPointerException("Null pointer in .sure() call");
	} else {
		return value;
	}
}
function haxeLanguageServer_protocol_Extensions_extractFunctionSignature(type) {
	let _g = haxeLanguageServer_protocol_Extensions_removeNulls(type).type;
	if(_g.kind == "TFun") {
		return _g.args;
	} else {
		return null;
	}
}
function haxeLanguageServer_protocol_Extensions_resolveImports(type) {
	let rec = null;
	rec = function(type) {
		while(true) switch(type.kind) {
		case "TAbstract":case "TEnum":case "TInst":case "TType":
			let paths = [];
			let typePath = type.args;
			if(typePath.params != null) {
				let _this = typePath.params;
				let f = rec;
				let result = new Array(_this.length);
				let _g = 0;
				let _g1 = _this.length;
				while(_g < _g1) {
					let i = _g++;
					result[i] = f(_this[i]);
				}
				let _g2 = [];
				let e = $getIterator(result);
				while(e.hasNext()) {
					let x = $getIterator(e.next());
					while(x.hasNext()) _g2.push(x.next());
				}
				paths = Lambda.array(_g2);
			}
			if(typePath.path.importStatus == 1) {
				paths.push(typePath.path);
			}
			return paths;
		case "TAnonymous":
			let _this = type.args.fields;
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = rec(_this[i].type);
			}
			let _g2 = [];
			let e = $getIterator(result);
			while(e.hasNext()) {
				let x = $getIterator(e.next());
				while(x.hasNext()) _g2.push(x.next());
			}
			return Lambda.array(_g2);
		case "TDynamic":
			if(type.args != null) {
				type = type.args;
				continue;
			} else {
				return [];
			}
			break;
		case "TFun":
			let signature = type.args;
			let _this1 = signature.args;
			let result1 = new Array(_this1.length);
			let _g3 = 0;
			let _g4 = _this1.length;
			while(_g3 < _g4) {
				let i = _g3++;
				result1[i] = rec(_this1[i].t);
			}
			let _g5 = [];
			let e1 = $getIterator(result1);
			while(e1.hasNext()) {
				let x = $getIterator(e1.next());
				while(x.hasNext()) _g5.push(x.next());
			}
			return Lambda.array(_g5).concat(rec(signature.ret));
		case "TMono":
			return [];
		}
	};
	return rec(type);
}
function haxeLanguageServer_protocol_Extensions_resolveTypes(type) {
	if(type.kind == "TAbstract") {
		if(haxeLanguageServer_protocol_DotPath_getDotPath(type) == "haxe.extern.EitherType") {
			let _this = type.args.params;
			let f = haxeLanguageServer_protocol_Extensions_resolveTypes;
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = f(_this[i]);
			}
			let _g2 = [];
			let e = $getIterator(result);
			while(e.hasNext()) {
				let x = $getIterator(e.next());
				while(x.hasNext()) _g2.push(x.next());
			}
			return Lambda.array(_g2);
		}
	}
	return [type];
}
function haxeLanguageServer_protocol_Extensions_hasMeta(meta,name) {
	if(meta != null) {
		return Lambda.exists(meta,function(meta) {
			return meta.name == name;
		});
	} else {
		return false;
	}
}
function haxeLanguageServer_protocol_Extensions_isOperator(field) {
	if(!(haxeLanguageServer_protocol_Extensions_hasMeta(field.meta,":op") || haxeLanguageServer_protocol_Extensions_hasMeta(field.meta,":resolve"))) {
		return haxeLanguageServer_protocol_Extensions_hasMeta(field.meta,":arrayAccess");
	} else {
		return true;
	}
}
function haxeLanguageServer_protocol_Extensions_isEnumAbstractField(field) {
	if(haxeLanguageServer_protocol_Extensions_hasMeta(field.meta,":enum")) {
		switch(field.kind.kind) {
		case "FMethod":
			return false;
		case "FVar":
			return field.kind.args.write.kind == "AccNever";
		}
	} else {
		return false;
	}
}
function haxeLanguageServer_protocol_Extensions_isModuleLevel(origin) {
	if(origin == null) {
		return false;
	}
	switch(origin.kind) {
	case 0:case 1:case 2:case 3:
		let moduleType = origin.args;
		if(moduleType == null) {
			return false;
		}
		if(moduleType.kind == "class") {
			return moduleType.args.kind.kind == "KModuleFields";
		} else {
			return false;
		}
		break;
	default:
		return false;
	}
}
function haxeLanguageServer_protocol_Extensions_isStructure(origin) {
	if(origin == null) {
		return false;
	}
	switch(origin.kind) {
	case 0:case 1:case 2:case 3:
		let moduleType = origin.args;
		if(moduleType == null) {
			return false;
		}
		if(moduleType.kind == "typedef") {
			return haxeLanguageServer_protocol_Extensions_removeNulls(moduleType.args.type).type.kind == "TAnonymous";
		} else {
			return false;
		}
		break;
	case 4:
		return true;
	default:
		return false;
	}
}
function haxeLanguageServer_protocol_Extensions_removeNulls(type,nullable) {
	if(nullable == null) {
		nullable = false;
	}
	while(true) {
		if(type.kind == "TAbstract") {
			let path = type.args;
			if(haxeLanguageServer_protocol_DotPath_getDotPath(type) == "StdTypes.Null") {
				if(path.params != null && path.params[0] != null) {
					type = path.params[0];
					nullable = true;
					continue;
				}
			}
		}
		return { type : type, nullable : nullable};
	}
}
function haxeLanguageServer_protocol_Extensions_getTypePath(type) {
	let _g = type.kind;
	if(_g == null) {
		return null;
	} else {
		switch(_g) {
		case "TAbstract":case "TEnum":case "TInst":case "TType":
			return type.args;
		default:
			return null;
		}
	}
}
function haxeLanguageServer_protocol_Extensions_guessName(type) {
	let path = haxeLanguageServer_protocol_Extensions_getTypePath(type);
	if(path == null) {
		return "unknown";
	}
	return haxeLanguageServer_helper_IdentifierHelper.guessName(path.path.typeName);
}
function haxeLanguageServer_protocol_Extensions_hasMandatoryTypeParameters(type) {
	if(haxeLanguageServer_protocol_DotPath_getDotPath2(type.path) == "Dynamic") {
		return false;
	}
	if(type.params != null) {
		return type.params.length > 0;
	} else {
		return false;
	}
}
function haxeLanguageServer_protocol_Extensions_isFinalField(field) {
	if(!haxeLanguageServer_protocol_Extensions_hasMeta(field.meta,":final")) {
		return field.isFinal;
	} else {
		return true;
	}
}
function haxeLanguageServer_protocol_Extensions_isFinalType(type) {
	if(!haxeLanguageServer_protocol_Extensions_hasMeta(type.meta,":final")) {
		return type.isFinal;
	} else {
		return true;
	}
}
var js_node_buffer_Buffer = require("buffer").Buffer;
class haxeLanguageServer_server_DisplayRequest {
	constructor(label,args,token,cancellable,stdin,handler) {
		this.label = label;
		this.args = args;
		this.token = token;
		this.cancellable = cancellable;
		this.stdin = stdin;
		this.handler = handler;
		this.creationTime = new Date().getTime();
	}
	prepareBody() {
		if(this.stdin != null) {
			this.args.push("-D");
			this.args.push("display-stdin");
		}
		let lenBuf = js_node_buffer_Buffer.alloc(4);
		let chunks = [lenBuf];
		let length = 0;
		let _g = 0;
		let _g1 = this.args;
		while(_g < _g1.length) {
			let buf = js_node_buffer_Buffer.from(_g1[_g++] + "\n");
			chunks.push(buf);
			length += buf.length;
		}
		if(this.stdin != null) {
			chunks.push(haxeLanguageServer_server_DisplayRequest.stdinSepBuf);
			let buf = js_node_buffer_Buffer.from(this.stdin);
			chunks.push(buf);
			length += buf.length + haxeLanguageServer_server_DisplayRequest.stdinSepBuf.length;
		}
		lenBuf.writeInt32LE(length,0);
		return js_node_buffer_Buffer.concat(chunks,length + 4);
	}
	onData(data) {
		if(this.token != null && this.token.canceled) {
			let _g = this.handler;
			switch(_g._hx_index) {
			case 0:
				_g.callback(haxeLanguageServer_server_DisplayResult.DCancelled);
				break;
			case 1:
				_g.callback(haxeLanguageServer_server_DisplayResult.DCancelled);
				break;
			}
			return;
		}
		let _g = this.handler;
		switch(_g._hx_index) {
		case 0:
			_g.callback(haxeLanguageServer_server_DisplayResult.DResult(data));
			break;
		case 1:
			this.processResult(data,_g.callback,_g.errback);
			break;
		}
	}
	processResult(data,callback,errback) {
		let buf_b = "";
		let hasError = false;
		let _g = 0;
		let _g1 = data.split("\n");
		while(_g < _g1.length) {
			let line = _g1[_g];
			++_g;
			switch(line.charCodeAt(0)) {
			case 1:
				haxe_Log.trace("Haxe print:\n" + StringTools.replace(line.substring(1),"\x01","\n"),{ fileName : "src/haxeLanguageServer/server/DisplayRequest.hx", lineNumber : 83, className : "haxeLanguageServer.server.DisplayRequest", methodName : "processResult"});
				break;
			case 2:
				hasError = true;
				break;
			default:
				buf_b += line == null ? "null" : "" + line;
				buf_b += String.fromCodePoint(10);
			}
		}
		let data1 = StringTools.trim(buf_b);
		if(hasError) {
			errback(data1);
			return;
		}
		try {
			callback(haxeLanguageServer_server_DisplayResult.DResult(data1));
		} catch( _g ) {
			errback(jsonrpc_ErrorUtils.errorToString(haxe_Exception.caught(_g),"Exception while handling Haxe completion response: "));
		}
	}
}
haxeLanguageServer_server_DisplayRequest.__name__ = "haxeLanguageServer.server.DisplayRequest";
Object.assign(haxeLanguageServer_server_DisplayRequest.prototype, {
	__class__: haxeLanguageServer_server_DisplayRequest
});
var haxeLanguageServer_server_DisplayResult = $hxEnums["haxeLanguageServer.server.DisplayResult"] = { __ename__:true,__constructs__:null
	,DCancelled: {_hx_name:"DCancelled",_hx_index:0,__enum__:"haxeLanguageServer.server.DisplayResult",toString:$estr}
	,DResult: ($_=function(msg) { return {_hx_index:1,msg:msg,__enum__:"haxeLanguageServer.server.DisplayResult",toString:$estr}; },$_._hx_name="DResult",$_.__params__ = ["msg"],$_)
};
haxeLanguageServer_server_DisplayResult.__constructs__ = [haxeLanguageServer_server_DisplayResult.DCancelled,haxeLanguageServer_server_DisplayResult.DResult];
class haxeLanguageServer_server_HaxeConnection {
	constructor($process,logger,onMessage,onExit) {
		if(haxeLanguageServer_server_HaxeConnection._hx_skip_constructor) {
			return;
		}
		this._hx_constructor($process,logger,onMessage,onExit);
	}
	_hx_constructor($process,logger,onMessage,onExit) {
		this.nextMessageLength = -1;
		this.buffer = new haxeLanguageServer_server_MessageBuffer();
		this.process = $process;
		this.logger = logger;
		this.onMessage = onMessage;
		let _gthis = this;
		$process.on("exit",function(_,_1) {
			onExit(_gthis);
		});
	}
	send(data) {
	}
	kill() {
		this.process.removeAllListeners();
		this.process.kill();
	}
	getLastErrorOutput() {
		return "";
	}
	onStdout(buf) {
		this.logger(buf.toString().replace(haxeLanguageServer_server_HaxeConnection.reTrailingNewline.r,""));
	}
	onData(data) {
		this.buffer.append(data);
		while(true) {
			if(this.nextMessageLength == -1) {
				let length = this.buffer.tryReadLength();
				if(length == -1) {
					return;
				}
				this.nextMessageLength = length;
			}
			let msg = this.buffer.tryReadContent(this.nextMessageLength);
			if(msg == null) {
				return;
			}
			this.nextMessageLength = -1;
			this.onMessage(msg);
		}
	}
}
haxeLanguageServer_server_HaxeConnection.__name__ = "haxeLanguageServer.server.HaxeConnection";
Object.assign(haxeLanguageServer_server_HaxeConnection.prototype, {
	__class__: haxeLanguageServer_server_HaxeConnection
});
class haxeLanguageServer_server_StdioConnection extends haxeLanguageServer_server_HaxeConnection {
	constructor($process,logger,onMessage,onExit) {
		super($process,logger,onMessage,onExit);
		$process.stdout.on("data",$bind(this,this.onStdout));
		$process.stderr.on("data",$bind(this,this.onData));
	}
	send(data) {
		this.process.stdin.write(data);
	}
	getLastErrorOutput() {
		return this.buffer.getContent();
	}
	static start(path,$arguments,spawnOptions,logger,onMessage,onExit,callback) {
		haxe_Log.trace("Using --wait stdio",{ fileName : "src/haxeLanguageServer/server/HaxeConnection.hx", lineNumber : 78, className : "haxeLanguageServer.server.StdioConnection", methodName : "start"});
		let $process = js_node_ChildProcess.spawn(path,$arguments.concat(["--wait","stdio"]),spawnOptions);
		callback(new haxeLanguageServer_server_StdioConnection($process,logger,onMessage,onExit));
	}
}
haxeLanguageServer_server_StdioConnection.__name__ = "haxeLanguageServer.server.StdioConnection";
haxeLanguageServer_server_StdioConnection.__super__ = haxeLanguageServer_server_HaxeConnection;
Object.assign(haxeLanguageServer_server_StdioConnection.prototype, {
	__class__: haxeLanguageServer_server_StdioConnection
});
class haxeLanguageServer_server_SocketConnection extends haxeLanguageServer_server_HaxeConnection {
	constructor($process,logger,onMessage,onExit) {
		haxeLanguageServer_server_HaxeConnection._hx_skip_constructor = true;
		super();
		haxeLanguageServer_server_HaxeConnection._hx_skip_constructor = false;
		this._hx_constructor($process,logger,onMessage,onExit);
	}
	_hx_constructor($process,logger,onMessage,onExit) {
		this.lastErrorOutput = "";
		super._hx_constructor($process,logger,onMessage,onExit);
		$process.stdout.on("data",$bind(this,this.onStdout));
		$process.stderr.on("data",$bind(this,this.onStderr));
	}
	setup(socket) {
		this.socket = socket;
		socket.on("data",$bind(this,this.onData));
	}
	send(data) {
		let _v_ = this.socket;
		if(_v_ != null) {
			_v_.write(data);
		}
	}
	kill() {
		if(this.socket != null) {
			this.socket.on("error",function(_) {
			});
		}
		super.kill();
	}
	onStderr(buf) {
		this.lastErrorOutput = buf.toString();
		this.logger(this.lastErrorOutput.replace(haxeLanguageServer_server_HaxeConnection.reTrailingNewline.r,""));
	}
	getLastErrorOutput() {
		return this.lastErrorOutput;
	}
	static start(path,$arguments,spawnOptions,logger,onMessage,onExit,callback) {
		haxe_Log.trace("Using --server-connect",{ fileName : "src/haxeLanguageServer/server/HaxeConnection.hx", lineNumber : 122, className : "haxeLanguageServer.server.SocketConnection", methodName : "start"});
		let server = js_node_Net.createServer();
		server.listen(0,function() {
			let port = server.address().port;
			let $process = js_node_ChildProcess.spawn(path,$arguments.concat(["--server-connect","127.0.0.1:" + port]),spawnOptions);
			let connection = new haxeLanguageServer_server_SocketConnection($process,logger,onMessage,onExit);
			server.on("connection",function(socket) {
				haxe_Log.trace("Haxe connected!",{ fileName : "src/haxeLanguageServer/server/HaxeConnection.hx", lineNumber : 129, className : "haxeLanguageServer.server.SocketConnection", methodName : "start"});
				server.close();
				connection.setup(socket);
				callback(connection);
			});
		});
	}
}
haxeLanguageServer_server_SocketConnection.__name__ = "haxeLanguageServer.server.SocketConnection";
haxeLanguageServer_server_SocketConnection.__super__ = haxeLanguageServer_server_HaxeConnection;
Object.assign(haxeLanguageServer_server_SocketConnection.prototype, {
	__class__: haxeLanguageServer_server_SocketConnection
});
class haxeLanguageServer_server_HaxeServer {
	constructor(context) {
		this.protocolVersion = { major : 0, minor : 0, patch : 0, pre : null, build : null};
		this.haxeVersion = { major : 0, minor : 0, patch : 0, pre : null, build : null};
		this.supportedMethods = [];
		this.crashes = 0;
		this.starting = false;
		this.context = context;
	}
	checkHaxeVersion(haxePath,spawnOptions) {
		let checkRun = js_node_ChildProcess.spawnSync(haxePath,["-version"],spawnOptions);
		if(checkRun.error != null) {
			if(checkRun.error.message.includes("ENOENT")) {
				if(haxePath == "haxe") {
					let _this = this.context.languageServerProtocol;
					let params = { type : 1, message : "Could not find Haxe in PATH. Is it installed?"};
					let message = { jsonrpc : "2.0", method : "window/showMessage"};
					if(params != null) {
						message.params = params;
					}
					_this.writeMessage(message,null);
					if(_this.didSendNotification != null) {
						_this.didSendNotification(message);
					}
					return false;
				} else {
					let _this = this.context.languageServerProtocol;
					let params = { type : 1, message : "Path to Haxe executable is not valid: '" + haxePath + "'. Please check your settings."};
					let message = { jsonrpc : "2.0", method : "window/showMessage"};
					if(params != null) {
						message.params = params;
					}
					_this.writeMessage(message,null);
					if(_this.didSendNotification != null) {
						_this.didSendNotification(message);
					}
					return false;
				}
			}
			let s = "Error starting Haxe server: " + haxeLanguageServer_helper_StringHelper.clean(checkRun.error.message);
			let _this = this.context.languageServerProtocol;
			let params = { type : 1, message : s};
			let message = { jsonrpc : "2.0", method : "window/showMessage"};
			if(params != null) {
				message.params = params;
			}
			_this.writeMessage(message,null);
			if(_this.didSendNotification != null) {
				_this.didSendNotification(message);
			}
			return false;
		}
		let output = haxeLanguageServer_helper_StringHelper.clean(StringTools.trim(checkRun.stderr.toString()));
		if(output == "") {
			output = haxeLanguageServer_helper_StringHelper.clean(StringTools.trim(checkRun.stdout.toString()));
		}
		if(checkRun.status != 0) {
			let _this = this.context.languageServerProtocol;
			let params = { type : 1, message : output == "" ? "`haxe -version` exited with error code " + checkRun.status : "Haxe version check failed: \"" + output + "\""};
			let message = { jsonrpc : "2.0", method : "window/showMessage"};
			if(params != null) {
				message.params = params;
			}
			_this.writeMessage(message,null);
			if(_this.didSendNotification != null) {
				_this.didSendNotification(message);
			}
			return false;
		}
		let haxeVersion = haxeLanguageServer_helper_SemVer.parse(output);
		if(haxeVersion == null) {
			let s = "Error parsing Haxe version " + JSON.stringify(output);
			let _this = this.context.languageServerProtocol;
			let params = { type : 1, message : s};
			let message = { jsonrpc : "2.0", method : "window/showMessage"};
			if(params != null) {
				message.params = params;
			}
			_this.writeMessage(message,null);
			if(_this.didSendNotification != null) {
				_this.didSendNotification(message);
			}
			return false;
		} else {
			this.haxeVersion = haxeVersion;
		}
		if(!haxeLanguageServer_helper_SemVer.isEqualOrGreaterThan(haxeVersion,{ major : 3, minor : 4, patch : 0, pre : null, build : null})) {
			let _this = this.context.languageServerProtocol;
			let params = { type : 1, message : "Unsupported Haxe version! Minimum required: 3.4.0. Found: " + (haxeVersion == null ? "null" : haxeLanguageServer_helper_SemVer.toString(haxeVersion)) + "."};
			let message = { jsonrpc : "2.0", method : "window/showMessage"};
			if(params != null) {
				message.params = params;
			}
			_this.writeMessage(message,null);
			if(_this.didSendNotification != null) {
				_this.didSendNotification(message);
			}
			return false;
		}
		return true;
	}
	mergeEnvs(from,to) {
		let _g_keys = Reflect.fields(from);
		let _g_index = 0;
		while(_g_index < _g_keys.length) {
			let key = _g_keys[_g_index++];
			let _g_value = from[key];
			let key1 = key;
			if(Sys.systemName() == "Windows") {
				let _g = 0;
				let _g1 = Reflect.fields(to);
				while(_g < _g1.length) {
					let initialKey = _g1[_g];
					++_g;
					if(key.toLowerCase() == initialKey.toLowerCase()) {
						key1 = initialKey;
						break;
					}
				}
			}
			to[key1] = _g_value;
		}
	}
	start(callback) {
		if(this.hasNonCancellableRequests() || this.starting) {
			this.startRequest = callback;
			return;
		}
		this.supportedMethods = [];
		this.startRequest = null;
		this.stop();
		let config = this.context.config.displayServer;
		let env = { };
		this.mergeEnvs(process.env,env);
		this.mergeEnvs(config.env,env);
		let spawnOptions = { env : env, cwd : this.context.workspacePath};
		if(!this.checkHaxeVersion(config.path,spawnOptions)) {
			return;
		}
		this.starting = true;
		let _gthis = this;
		let onHaxeStarted = function(connection) {
			_gthis.haxeConnection = connection;
			let onInitComplete = function() {
				_gthis.stopProgress();
				_gthis.buildCompletionCache();
				if(callback != null) {
					callback();
				}
			};
			_gthis.context.callHaxeMethod("initialize",{ supportsResolve : true, exclude : _gthis.context.config.user.exclude, maxCompletionItems : _gthis.context.config.user.maxCompletionItems},null,function(result) {
				if(result.haxeVersion.major == 4 && result.haxeVersion.minor == 0 && result.haxeVersion.pre != null) {
					let _this = _gthis.context.languageServerProtocol;
					let params = { haxe4Preview : true, version : haxeLanguageServer_helper_SemVer.toString(_gthis.haxeVersion)};
					let message = { jsonrpc : "2.0", method : "haxe/didDetectOldHaxeVersion"};
					if(params != null) {
						message.params = params;
					}
					_this.writeMessage(message,null);
					if(_this.didSendNotification != null) {
						_this.didSendNotification(message);
					}
				}
				_gthis.protocolVersion = result.protocolVersion;
				_gthis.supportedMethods = result.methods;
				_gthis.configure();
				onInitComplete();
				return null;
			},function(error) {
				if(error.startsWith("Error: Invalid format")) {
					haxe_Log.trace("Haxe version does not support JSON-RPC, using legacy --display API.",{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 156, className : "haxeLanguageServer.server.HaxeServer", methodName : "start"});
					let _this = _gthis.context.languageServerProtocol;
					let params = { haxe4Preview : _gthis.haxeVersion.major == 4, version : haxeLanguageServer_helper_SemVer.toString(_gthis.haxeVersion)};
					let message = { jsonrpc : "2.0", method : "haxe/didDetectOldHaxeVersion"};
					if(params != null) {
						message.params = params;
					}
					_this.writeMessage(message,null);
					if(_this.didSendNotification != null) {
						_this.didSendNotification(message);
					}
				} else {
					haxe_Log.trace(error,{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 162, className : "haxeLanguageServer.server.HaxeServer", methodName : "start"});
				}
				onInitComplete();
			});
			let displayPort = _gthis.context.config.user.displayPort;
			if(_gthis.socketListener == null && displayPort != null) {
				if(displayPort == "auto") {
					_gthis.getAvailablePort(6000).then($bind(_gthis,_gthis.startSocketServer));
				} else {
					_gthis.startSocketServer(displayPort);
				}
			} else {
				_gthis.starting = false;
				_gthis.checkRestart();
			}
		};
		let useSocket = config.useSocket;
		if(this.haxeVersion.major < 4) {
			useSocket = false;
		}
		if(this.haxeVersion.major == 4 && this.haxeVersion.minor == 0 && this.haxeVersion.pre != null) {
			useSocket = false;
		}
		if(sys_FileSystem.exists(haxe_io_Path.join([this.context.workspacePath,".haxerc"]))) {
			useSocket = false;
		}
		haxe_Log.trace("Haxe Path: " + config.path,{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 192, className : "haxeLanguageServer.server.HaxeServer", methodName : "start"});
		spawnOptions.env["HAXE_COMPLETION_SERVER"] = "1";
		(useSocket ? haxeLanguageServer_server_SocketConnection.start : haxeLanguageServer_server_StdioConnection.start)(config.path,config.arguments,spawnOptions,$bind(this,this.log),$bind(this,this.onMessage),$bind(this,this.onExit),onHaxeStarted);
	}
	log(msg) {
		haxe_Log.trace(msg,{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 198, className : "haxeLanguageServer.server.HaxeServer", methodName : "log"});
		this.context.serverRecording.onServerLog(msg);
	}
	configure() {
		this.context.callHaxeMethod("server/configure",{ noModuleChecks : true, print : this.context.config.displayServer.print, populateCacheFromDisplay : this.context.config.user.populateCacheFromDisplay, legacyCompletion : this.context.config.user.useLegacyCompletion},null,function(_) {
			return null;
		},function(error) {
			haxe_Log.trace("Error during " + "server/configure" + " " + error,{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 209, className : "haxeLanguageServer.server.HaxeServer", methodName : "configure"});
		});
	}
	buildCompletionCache() {
		if(!this.context.config.user.buildCompletionCache || this.context.config.displayArguments == null) {
			return;
		}
		this.startProgress("Building Cache");
		let _gthis = this;
		let tmp = haxeLanguageServer_server_ResultHandler.Processed(function(_) {
			_gthis.stopProgress();
			if(_gthis.supports("server/readClassPaths")) {
				_gthis.readClassPaths();
			} else {
				haxe_Log.trace("Done.",{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 227, className : "haxeLanguageServer.server.HaxeServer", methodName : "buildCompletionCache"});
			}
		},function(error) {
			if(_gthis.context.config.user.enableCompletionCacheWarning) {
				let _this = _gthis.context.languageServerProtocol;
				let message = { jsonrpc : "2.0", method : "haxe/cacheBuildFailed"};
				_this.writeMessage(message,null);
				if(_this.didSendNotification != null) {
					_this.didSendNotification(message);
				}
			}
			_gthis.stopProgress();
			haxe_Log.trace("Failed - try fixing the error(s) and restarting the language server:\n\n" + haxeLanguageServer_helper_StringHelper.clean(error),{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 234, className : "haxeLanguageServer.server.HaxeServer", methodName : "buildCompletionCache"});
		});
		this.process("cache build",["--no-output","--each","--no-output"].concat(this.context.config.displayArguments),null,true,null,tmp);
	}
	readClassPaths() {
		this.startProgress("Parsing Classpaths");
		let _gthis = this;
		this.context.callHaxeMethod("server/readClassPaths",null,null,function(result) {
			_gthis.stopProgress();
			haxe_Log.trace("Done.",{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 242, className : "haxeLanguageServer.server.HaxeServer", methodName : "readClassPaths"});
			if(result.files == null) {
				return null;
			}
			return result.files + " files";
		},function(error) {
			_gthis.stopProgress();
			haxe_Log.trace("Failed - " + haxeLanguageServer_helper_StringHelper.clean(error),{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 249, className : "haxeLanguageServer.server.HaxeServer", methodName : "readClassPaths"});
		});
	}
	hasNonCancellableRequests() {
		if(this.currentRequest != null && !this.currentRequest.cancellable) {
			return true;
		}
		let request = this.requestsHead;
		while(request != null) {
			if(!request.cancellable) {
				return true;
			}
			request = request.next;
		}
		return false;
	}
	getAvailablePort(startingAt) {
		let getNextAvailablePort = null;
		getNextAvailablePort = function(currentPort,cb) {
			let server = js_node_Net.createServer();
			server.listen(currentPort,"localhost",function() {
				let _g = cb;
				let a1 = currentPort;
				let getNextAvailablePort = function() {
					_g(a1);
				};
				server.once("close",getNextAvailablePort);
				server.close();
			});
			server.on("error",function(_) {
				getNextAvailablePort(currentPort + 1,cb);
			});
		};
		return new Promise(function(resolve,reject) {
			getNextAvailablePort(startingAt,resolve);
		});
	}
	startSocketServer(port) {
		if(this.socketListener != null) {
			this.socketListener.close();
		}
		let _gthis = this;
		this.socketListener = js_node_Net.createServer(function(socket) {
			haxe_Log.trace("Client connected",{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 286, className : "haxeLanguageServer.server.HaxeServer", methodName : "startSocketServer"});
			socket.on("data",function(data) {
				let s = data.toString();
				let split = s.split("\n");
				split.pop();
				let callback = function(result) {
					switch(result._hx_index) {
					case 0:
						break;
					case 1:
						socket.write(result.msg);
						break;
					}
					socket.end();
					socket.destroy();
					haxe_Log.trace("Client disconnected",{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 299, className : "haxeLanguageServer.server.HaxeServer", methodName : "startSocketServer"});
				};
				_gthis.context.resetInvalidatedFiles();
				_gthis.process("compilation",split,null,false,null,haxeLanguageServer_server_ResultHandler.Raw(callback));
			});
			socket.on("error",function(err) {
				haxe_Log.trace("Socket error: " + Std.string(err),{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 305, className : "haxeLanguageServer.server.HaxeServer", methodName : "startSocketServer"});
			});
		});
		this.socketListener.listen(port,"localhost");
		haxe_Log.trace("Listening on port " + port,{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 309, className : "haxeLanguageServer.server.HaxeServer", methodName : "startSocketServer"});
		let _this = this.context.languageServerProtocol;
		let params = { port : port};
		let message = { jsonrpc : "2.0", method : "haxe/didChangeDisplayPort"};
		if(params != null) {
			message.params = params;
		}
		_this.writeMessage(message,null);
		if(_this.didSendNotification != null) {
			_this.didSendNotification(message);
		}
		this.starting = false;
		this.checkRestart();
	}
	stop() {
		if(this.haxeConnection != null) {
			this.haxeConnection.kill();
			this.haxeConnection = null;
		}
		this.stopProgress();
		let request = this.requestsHead;
		while(request != null) {
			let _g = request.handler;
			switch(_g._hx_index) {
			case 0:
				_g.callback(haxeLanguageServer_server_DisplayResult.DCancelled);
				break;
			case 1:
				_g.callback(haxeLanguageServer_server_DisplayResult.DCancelled);
				break;
			}
			request = request.next;
		}
		this.requestsHead = this.requestsTail = this.currentRequest = null;
		this.updateRequestQueue();
	}
	startProgress(title) {
		this.stopProgress();
		this.stopProgressCallback = this.context.startProgress(title);
	}
	stopProgress() {
		if(this.stopProgressCallback != null) {
			this.stopProgressCallback();
		}
		this.stopProgressCallback = null;
	}
	restart(reason,callback) {
		haxe_Log.trace("Haxe server restart requested: " + reason,{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 348, className : "haxeLanguageServer.server.HaxeServer", methodName : "restart"});
		this.start(function() {
			haxe_Log.trace("Restarted Haxe server: " + reason,{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 350, className : "haxeLanguageServer.server.HaxeServer", methodName : "restart"});
			if(callback != null) {
				callback();
			}
		});
	}
	onExit(connection) {
		this.stopProgress();
		this.crashes++;
		if(this.crashes < 3) {
			this.restart("Haxe process was killed");
			return;
		}
		let haxeResponse = connection.getLastErrorOutput();
		let invalidOptionRegex = new EReg("unknown option [`'](.*?)'.","");
		if(invalidOptionRegex.match(haxeResponse)) {
			let option = invalidOptionRegex.matched(1);
			let _this = this.context.languageServerProtocol;
			let params = { type : 1, message : "Invalid compiler argument '" + option + "' detected. Please verify \"haxe.configurations\" and \"haxe.displayServer.arguments\"."};
			let message = { jsonrpc : "2.0", method : "window/showMessage"};
			if(params != null) {
				message.params = params;
			}
			_this.writeMessage(message,null);
			if(_this.didSendNotification != null) {
				_this.didSendNotification(message);
			}
			return;
		}
		let _this = this.context.languageServerProtocol;
		let message = { jsonrpc : "2.0", method : "haxe/haxeKeepsCrashing"};
		_this.writeMessage(message,null);
		if(_this.didSendNotification != null) {
			_this.didSendNotification(message);
		}
		haxe_Log.trace("\nError message from the compiler:\n",{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 377, className : "haxeLanguageServer.server.HaxeServer", methodName : "onExit"});
		haxe_Log.trace(haxeResponse,{ fileName : "src/haxeLanguageServer/server/HaxeServer.hx", lineNumber : 378, className : "haxeLanguageServer.server.HaxeServer", methodName : "onExit"});
	}
	onMessage(msg) {
		if(this.currentRequest != null) {
			let request = this.currentRequest;
			this.context.serverRecording.onServerMessage(request,msg);
			this.currentRequest = null;
			request.onData(msg);
			this.updateRequestQueue();
			this.checkQueue();
		}
	}
	process(label,args,token,cancellable,stdin,handler) {
		let request = new haxeLanguageServer_server_DisplayRequest(label,args,token,cancellable,stdin,handler);
		let _gthis = this;
		if(token != null) {
			token.callback = function() {
				if(request == _gthis.currentRequest) {
					return;
				}
				_gthis.context.serverRecording.onDisplayRequestCancelled(request);
				if(request == _gthis.requestsHead) {
					_gthis.requestsHead = request.next;
				}
				if(request == _gthis.requestsTail) {
					_gthis.requestsTail = request.prev;
				}
				if(request.prev != null) {
					request.prev.next = request.next;
				}
				if(request.next != null) {
					request.next.prev = request.prev;
				}
				let _g = request.handler;
				switch(_g._hx_index) {
				case 0:
					_g.callback(haxeLanguageServer_server_DisplayResult.DCancelled);
					break;
				case 1:
					_g.callback(haxeLanguageServer_server_DisplayResult.DCancelled);
					break;
				}
				_gthis.updateRequestQueue();
			};
		}
		if(this.requestsHead == null || this.requestsTail == null) {
			this.requestsHead = this.requestsTail = request;
		} else {
			this.requestsTail.next = request;
			request.prev = this.requestsTail;
			this.requestsTail = request;
		}
		if(this.currentRequest != null) {
			this.context.serverRecording.onDisplayRequestQueued(request);
		}
		this.checkQueue();
		this.updateRequestQueue();
	}
	checkRestart() {
		if(this.startRequest != null) {
			this.start(this.startRequest);
			return;
		}
	}
	checkQueue() {
		this.checkRestart();
		if(this.currentRequest != null) {
			return;
		}
		if(this.requestsHead != null && this.haxeConnection != null) {
			this.currentRequest = this.requestsHead;
			this.requestsHead = this.currentRequest.next;
			this.updateRequestQueue();
			this.context.serverRecording.onDisplayRequest(this.currentRequest);
			this.haxeConnection.send(this.currentRequest.prepareBody());
		}
	}
	supports(method) {
		return this.supportedMethods.includes(method);
	}
	updateRequestQueue() {
		if(!this.context.config.sendMethodResults) {
			return;
		}
		let queue = [];
		let request = this.currentRequest;
		while(request != null) {
			queue.push(request.label);
			request = request.next;
		}
		let _this = this.context.languageServerProtocol;
		let params = { queue : queue};
		let message = { jsonrpc : "2.0", method : "haxe/didChangeRequestQueue"};
		if(params != null) {
			message.params = params;
		}
		_this.writeMessage(message,null);
		if(_this.didSendNotification != null) {
			_this.didSendNotification(message);
		}
	}
}
haxeLanguageServer_server_HaxeServer.__name__ = "haxeLanguageServer.server.HaxeServer";
Object.assign(haxeLanguageServer_server_HaxeServer.prototype, {
	__class__: haxeLanguageServer_server_HaxeServer
});
class haxeLanguageServer_server_MessageBuffer {
	constructor() {
		this.index = 0;
		this.buffer = js_node_buffer_Buffer.alloc(8192);
	}
	append(chunk) {
		if(this.buffer.length - this.index >= chunk.length) {
			chunk.copy(this.buffer,this.index,0,chunk.length);
		} else {
			let newSize = (Math.ceil((this.index + chunk.length) / 8192) + 1) * 8192;
			if(this.index == 0) {
				this.buffer = js_node_buffer_Buffer.alloc(newSize);
				chunk.copy(this.buffer,0,0,chunk.length);
			} else {
				this.buffer = js_node_buffer_Buffer.concat([this.buffer.slice(0,this.index),chunk],newSize);
			}
		}
		this.index += chunk.length;
	}
	tryReadLength() {
		if(this.index < 4) {
			return -1;
		}
		let length = this.buffer.readInt32LE(0);
		this.buffer = this.buffer.slice(4);
		this.index -= 4;
		return length;
	}
	tryReadContent(length) {
		if(this.index < length) {
			return null;
		}
		let result = this.buffer.toString("utf-8",0,length);
		this.buffer.copy(this.buffer,0,length);
		this.index -= length;
		return result;
	}
	getContent() {
		return this.buffer.toString("utf-8",0,this.index);
	}
}
haxeLanguageServer_server_MessageBuffer.__name__ = "haxeLanguageServer.server.MessageBuffer";
Object.assign(haxeLanguageServer_server_MessageBuffer.prototype, {
	__class__: haxeLanguageServer_server_MessageBuffer
});
var haxeLanguageServer_server_ResultHandler = $hxEnums["haxeLanguageServer.server.ResultHandler"] = { __ename__:true,__constructs__:null
	,Raw: ($_=function(callback) { return {_hx_index:0,callback:callback,__enum__:"haxeLanguageServer.server.ResultHandler",toString:$estr}; },$_._hx_name="Raw",$_.__params__ = ["callback"],$_)
	,Processed: ($_=function(callback,errback) { return {_hx_index:1,callback:callback,errback:errback,__enum__:"haxeLanguageServer.server.ResultHandler",toString:$estr}; },$_._hx_name="Processed",$_.__params__ = ["callback","errback"],$_)
};
haxeLanguageServer_server_ResultHandler.__constructs__ = [haxeLanguageServer_server_ResultHandler.Raw,haxeLanguageServer_server_ResultHandler.Processed];
class haxeLanguageServer_server_ServerRecording {
	constructor() {
		this.config = haxeLanguageServer_Configuration.DefaultUserSettings.serverRecording;
		this.recordingPath = "";
		this.fsEventIndex = 1;
		this.startTime = -1;
		this.ready = false;
	}
	get_enabled() {
		if(this.ready) {
			return this.config.enabled;
		} else {
			return false;
		}
	}
	onInitialize(context) {
		this.restart(context);
	}
	restartServer(reason,context) {
		this.restart(context,context.initialized ? reason : null);
	}
	export(params,token,resolve,reject) {
		if(!this.get_enabled()) {
			let reject1 = reject;
			let data = null;
			let this1 = { code : -32603, message : "Was not recording haxe server"};
			if(data != null) {
				this1.data = data;
			}
			reject1(this1);
			return;
		}
		this.appendLines(this.makeEntry("#","Export requested ..."));
		let dest;
		if((params != null ? params.dest : null) == null) {
			dest = this.config.path;
		} else {
			if(params == null) {
				throw new safety_NullPointerException("Null pointer in .sure() call");
			}
			dest = params.dest;
		}
		if(!sys_FileSystem.isDirectory(dest)) {
			this.appendLines(this.makeEntry("#","Failed to export to " + dest));
			let reject1 = reject;
			let data = null;
			let this1 = { code : -32602, message : "Server recording export path should be a directory"};
			if(data != null) {
				this1.data = data;
			}
			reject1(this1);
			return;
		}
		let recordingKey = DateTools.format(new Date(),"%Y%m%d-%H%M%S");
		let _gthis = this;
		try {
			let path = haxe_io_Path.join([dest,recordingKey]);
			this.appendLines(this.makeEntry("#","Exporting to " + path + " ..."));
			sys_FileSystem.createDirectory(path);
			let vcsState = haxeLanguageServer_server_ServerRecordingTools_getVcsState(haxe_io_Path.join([this.get_recordingPath(),"end.patch"]),haxe_io_Path.join([path,"endUntracked"]),this.config);
			if(vcsState._hx_index == 1) {
				vcsState.untrackedCopy.then(function(_) {
					_gthis.appendLines(_gthis.makeEntry("#","Untracked files copied successfully"));
				}).catch(function(err) {
					_gthis.appendLines(_gthis.makeEntry("#","Warning: error while saving untracked file: " + err.message));
				});
			}
			haxeLanguageServer_helper_FsHelper.cp(this.get_recordingPath(),path).then(function(_) {
				resolve("Exported server recording to " + path);
			}).catch(function(err) {
				let reject1 = reject;
				let this1 = { code : -32603, message : Std.string(err)};
				if(err != null) {
					this1.data = err;
				}
				reject1(this1);
			});
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g);
			let reject1 = reject;
			let data = null;
			let this1 = { code : -32603, message : _g1.get_message()};
			if(data != null) {
				this1.data = data;
			}
			reject1(this1);
		}
	}
	onDisplayRequestQueued(request) {
		if(this.config == null || !this.config.enabled) {
			return;
		}
		this.appendLines(this.makeEntry("-","serverRequestQueued",this.extractRequestId(request.args),request.label));
	}
	onDisplayRequestCancelled(request) {
		if(this.config == null || !this.config.enabled) {
			return;
		}
		this.appendLines(this.makeEntry("-","serverRequestCancelled",this.extractRequestId(request.args),request.label),JSON.stringify(request.args));
	}
	onDisplayRequest(request) {
		if(!this.get_enabled()) {
			return;
		}
		let delta = new Date().getTime() - request.creationTime;
		let id = this.extractRequestId(request.args);
		if(delta > 5) {
			this.appendLines(this.makeEntry("#","Request has been queued for " + delta + " ms"));
		}
		this.appendLines(this.makeEntry(">","serverRequest",id,request.label),JSON.stringify(request.args));
	}
	onServerLog(message) {
		if(!this.get_enabled()) {
			return;
		}
		this.appendLines(this.makeEntry("<","serverLog"),"<<EOF",message,"EOF");
	}
	onServerMessage(request,message) {
		if(!this.get_enabled()) {
			return;
		}
		this.appendLines(this.makeEntry("#","Request total time: " + (new Date().getTime() - request.creationTime) + " ms"));
		let _g = this;
		let request1 = request;
		let _g1 = this;
		let request2 = request;
		request.processResult(message,function(response) {
			_g.onServerResponse(request1,response);
		},function(error) {
			_g1.onServerError(request2,error);
		});
	}
	onServerResponse(request,response) {
		if(!this.get_enabled()) {
			return;
		}
		switch(response._hx_index) {
		case 0:
			break;
		case 1:
			let _gmsg = response.msg;
			switch(request.label) {
			case "cache build":case "compilation":
				this.appendLines(this.makeEntry("<","compilationResult"),"<<EOF",haxeLanguageServer_helper_StringHelper.clean(_gmsg),"EOF");
				break;
			default:
				this.appendLines(this.makeEntry("<","serverResponse",this.extractRequestId(request.args),request.label),_gmsg);
			}
			break;
		}
	}
	onServerError(request,error) {
		if(!this.get_enabled()) {
			return;
		}
		switch(request.label) {
		case "cache build":case "compilation":
			this.appendLines(this.makeEntry("<","compilationError"),"<<EOF",error,"EOF");
			break;
		default:
			this.appendLines(this.makeEntry("<","serverError",this.extractRequestId(request.args),request.label),"<<EOF",error,"EOF");
		}
	}
	onDidChangeTextDocument(event) {
		if(!this.get_enabled()) {
			return;
		}
		this.appendLines(this.makeEntry("-","didChangeTextDocument"),JSON.stringify(event));
	}
	onFileEvent(event) {
		let kind;
		switch(event.type) {
		case 1:
			kind = "fileCreated";
			break;
		case 2:
			kind = "fileChanged";
			break;
		case 3:
			kind = "fileDeleted";
			break;
		}
		let this1 = haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(event.uri);
		let id;
		switch(event.type) {
		case 1:case 2:
			let stat = js_node_Fs.statSync(this1);
			id = stat.size == 0 ? 0 : this.fsEventIndex++;
			break;
		case 3:
			id = 0;
			break;
		}
		this.appendLines(this.makeEntry("-",kind,id),"\"" + haxeLanguageServer_extensions_DocumentUriExtensions_toFsPath(event.uri) + "\"");
		if(id > 0) {
			this.ensureFileContentsDir();
			haxeLanguageServer_helper_FsHelper.cp(this1,haxe_io_Path.join([this.get_recordingPath(),"files","" + id + ".contents"]));
		}
	}
	restart(context,reason) {
		this.ready = false;
		this.recordingPath = "";
		this.startTime = -1;
		this.fsEventIndex = 1;
		let tmp = context.config.user;
		let config = tmp != null ? tmp.serverRecording : null;
		if(config == null) {
			return;
		}
		this.config = config;
		if(!config.enabled) {
			return;
		}
		let _gthis = this;
		haxeLanguageServer_helper_FsHelper.rmdir(this.get_recordingPath()).then(function(_) {
			_gthis.start(context,reason);
		}).catch(function(_) {
			let _this = context.languageServerProtocol;
			let params = { type : 2, message : "Server recording disabled: could not remove previous files."};
			let message = { jsonrpc : "2.0", method : "window/showMessage"};
			if(params != null) {
				message.params = params;
			}
			_this.writeMessage(message,null);
			if(_this.didSendNotification != null) {
				_this.didSendNotification(message);
			}
		});
	}
	start(context,restartReason) {
		let now = new Date();
		let workspace = context.workspacePath;
		try {
			sys_FileSystem.createDirectory(this.get_recordingPath());
		} catch( _g ) {
			let _this = context.languageServerProtocol;
			let params = { type : 2, message : "Server recording disabled: could not create recording directory."};
			let message = { jsonrpc : "2.0", method : "window/showMessage"};
			if(params != null) {
				message.params = params;
			}
			_this.writeMessage(message,null);
			if(_this.didSendNotification != null) {
				_this.didSendNotification(message);
			}
			return;
		}
		try {
			this.writeLines(this.makeEntry("#","See https://github.com/kLabz/haxerepro for instructions"));
		} catch( _g ) {
			let _this = context.languageServerProtocol;
			let params = { type : 2, message : "Server recording disabled: could not write server logs file."};
			let message = { jsonrpc : "2.0", method : "window/showMessage"};
			if(params != null) {
				message.params = params;
			}
			_this.writeMessage(message,null);
			if(_this.didSendNotification != null) {
				_this.didSendNotification(message);
			}
			return;
		}
		if(restartReason != null) {
			this.appendLines(this.makeEntry("#","Restart reason: " + restartReason));
		}
		this.appendLines(this.makeEntry("-","userConfig"),JSON.stringify(context.config.user),this.makeEntry("-","serverRecordingConfig"),JSON.stringify({ watch : this.config.watch, exclude : this.config.exclude, excludeUntracked : this.config.excludeUntracked, version : 1.2}),this.makeEntry("-","displayServer"),JSON.stringify(context.config.displayServer),this.makeEntry("-","displayArguments"),JSON.stringify(context.config.displayArguments),this.makeEntry("-","haxe"),haxeLanguageServer_helper_SemVer.toFullVersion(context.haxeServer.haxeVersion),this.makeEntry("-","root",null,workspace));
		let vcsState = haxeLanguageServer_server_ServerRecordingTools_getVcsState(haxe_io_Path.join([this.get_recordingPath(),"status.patch"]),haxe_io_Path.join([this.get_recordingPath(),"untracked"]),this.config);
		let _gthis = this;
		switch(vcsState._hx_index) {
		case 0:
			this.appendLines(this.makeEntry("#","Could not detect version control, initial state not guaranteed."));
			break;
		case 1:
			this.appendLines(this.makeEntry("-","checkoutGitRef"),vcsState.ref);
			if(vcsState.hasPatch) {
				this.appendLines(this.makeEntry("-","applyGitPatch"));
			}
			if(vcsState.hasUntracked) {
				this.appendLines(this.makeEntry("-","addGitUntracked"));
				vcsState.untrackedCopy.then(function(_) {
					_gthis.appendLines(_gthis.makeEntry("#","Untracked files copied successfully"));
				}).catch(function(err) {
					_gthis.appendLines(_gthis.makeEntry("#","Warning: error while saving untracked file: " + err.message));
				});
			}
			break;
		case 2:
			this.appendLines(this.makeEntry("-","checkoutSvnRevision"),vcsState.rev);
			if(vcsState.hasPatch) {
				this.appendLines(this.makeEntry("-","applySvnPatch"));
			}
			break;
		}
		this.appendLines(this.makeEntry("-","start"),this.makeEntry("#","Started " + DateTools.format(now,"%Y-%m-%d %H:%M:%S")));
		this.startTime = now.getTime();
		this.ready = true;
	}
	writeLines(...lines) {
		this.print(function(f) {
			return new sys_io_FileOutput(js_node_Fs.openSync(f,"w"));
		},...lines);
	}
	appendLines(...lines) {
		this.print(function(f) {
			return new sys_io_FileOutput(js_node_Fs.openSync(f,"a"));
		},...lines);
	}
	makeEntry(dir,command,id,name) {
		return this.withTiming("" + dir + " " + command + (id == null ? "" : " " + id) + (name == null ? "" : " \"" + name + "\""));
	}
	withTiming(msg) {
		if(this.startTime == -1) {
			return msg;
		}
		return "+" + Math.round((new Date().getTime() - this.startTime) / 10) / 10 + "s " + msg;
	}
	ensureFileContentsDir() {
		let path = haxe_io_Path.join([this.get_recordingPath(),"files"]);
		if(!sys_FileSystem.exists(path)) {
			sys_FileSystem.createDirectory(path);
		}
	}
	print(open,...lines) {
		if(lines.length == 0) {
			return;
		}
		let f = open(haxe_io_Path.join([this.get_recordingPath(),"repro.log"]));
		let _g_current = 0;
		while(_g_current < lines.length) f.writeString("" + lines[_g_current++] + "\n");
		f.close();
	}
	get_recordingPath() {
		if(this.recordingPath == "") {
			this.recordingPath = haxe_io_Path.join([this.config.path,"current"]);
		}
		return this.recordingPath;
	}
	extractRequestId(args) {
		let len = args.length;
		if(len < 2 || args[len - 2] != "--display") {
			return null;
		}
		try {
			return JSON.parse(args[len - 1]).id;
		} catch( _g ) {
			return null;
		}
	}
}
haxeLanguageServer_server_ServerRecording.__name__ = "haxeLanguageServer.server.ServerRecording";
Object.assign(haxeLanguageServer_server_ServerRecording.prototype, {
	__class__: haxeLanguageServer_server_ServerRecording
});
var haxeLanguageServer_server_VcsState = $hxEnums["haxeLanguageServer.server.VcsState"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"haxeLanguageServer.server.VcsState",toString:$estr}
	,Git: ($_=function(ref,hasPatch,hasUntracked,untrackedCopy) { return {_hx_index:1,ref:ref,hasPatch:hasPatch,hasUntracked:hasUntracked,untrackedCopy:untrackedCopy,__enum__:"haxeLanguageServer.server.VcsState",toString:$estr}; },$_._hx_name="Git",$_.__params__ = ["ref","hasPatch","hasUntracked","untrackedCopy"],$_)
	,Svn: ($_=function(rev,hasPatch) { return {_hx_index:2,rev:rev,hasPatch:hasPatch,__enum__:"haxeLanguageServer.server.VcsState",toString:$estr}; },$_._hx_name="Svn",$_.__params__ = ["rev","hasPatch"],$_)
};
haxeLanguageServer_server_VcsState.__constructs__ = [haxeLanguageServer_server_VcsState.None,haxeLanguageServer_server_VcsState.Git,haxeLanguageServer_server_VcsState.Svn];
function haxeLanguageServer_server_ServerRecordingTools_hasCommand(bin) {
	try {
		haxeLanguageServer_server_ServerRecordingTools_command(bin,[]);
		return true;
	} catch( _g ) {
		return false;
	}
}
function haxeLanguageServer_server_ServerRecordingTools_command(cmd,args) {
	let p = js_node_ChildProcess.spawnSync(cmd,args);
	return { code : p.status, out : StringTools.trim((p.status == 0 ? p.stdout : p.stderr).toString())};
}
function haxeLanguageServer_server_ServerRecordingTools_getVcsState(patchOutput,untrackedDestination,config) {
	let ret = haxeLanguageServer_server_VcsState.None;
	ret = haxeLanguageServer_server_ServerRecordingTools_getGitState(patchOutput,untrackedDestination,config);
	if(ret._hx_index == 0) {
		ret = haxeLanguageServer_server_ServerRecordingTools_getSvnState(patchOutput,config);
	}
	return ret;
}
function haxeLanguageServer_server_ServerRecordingTools_getGitState(patchOutput,untrackedDestination,config) {
	if(!haxeLanguageServer_server_ServerRecordingTools_hasCommand("git")) {
		return haxeLanguageServer_server_VcsState.None;
	}
	let revision = haxeLanguageServer_server_ServerRecordingTools_command("git",["rev-parse","HEAD"]);
	if(revision.code != 0) {
		return haxeLanguageServer_server_VcsState.None;
	}
	haxeLanguageServer_server_ServerRecordingTools_command("git",haxeLanguageServer_server_ServerRecordingTools_applyGitExcludes(["diff","--output",patchOutput,"--patch"],config));
	let hasUntracked = false;
	let p = Promise.resolve();
	if(!config.excludeUntracked) {
		let _this = haxeLanguageServer_server_ServerRecordingTools_command("git",haxeLanguageServer_server_ServerRecordingTools_applyGitExcludes(["status","--porcelain"],config)).out.split("\n");
		let _g = [];
		let _g1 = 0;
		while(_g1 < _this.length) {
			let v = _this[_g1];
			++_g1;
			if(v.startsWith("?? ")) {
				_g.push(v);
			}
		}
		let result = new Array(_g.length);
		let _g2 = 0;
		let _g3 = _g.length;
		while(_g2 < _g3) {
			let i = _g2++;
			result[i] = HxOverrides.substr(_g[i],3,null);
		}
		let _g4 = [];
		let _g5 = 0;
		while(_g5 < result.length) {
			let v = result[_g5];
			++_g5;
			if(v != haxeLanguageServer_server_ServerRecordingTools_recordingRelativeRoot(config) && v != ".haxelib" && v != "dump") {
				_g4.push(v);
			}
		}
		if(_g4.length > 0) {
			hasUntracked = true;
			sys_FileSystem.createDirectory(untrackedDestination);
			let promises = [];
			let _g = 0;
			while(_g < _g4.length) {
				let f = _g4[_g];
				++_g;
				if(f.startsWith("\"")) {
					f = HxOverrides.substr(f,1,null);
				}
				if(f.endsWith("\"")) {
					f = HxOverrides.substr(f,0,f.length - 1);
				}
				promises.push(haxeLanguageServer_helper_FsHelper.cp(f,haxe_io_Path.join([untrackedDestination,f])));
			}
			p = Promise.all(promises).then(function(_) {
				return;
			});
		}
	}
	return haxeLanguageServer_server_VcsState.Git(revision.out,true,hasUntracked,p);
}
function haxeLanguageServer_server_ServerRecordingTools_applyGitExcludes(args,config) {
	if(config.exclude.length == 0) {
		return args;
	}
	args.push("--");
	args.push(".");
	let _g = 0;
	let _g1 = config.exclude;
	while(_g < _g1.length) args.push(":^" + _g1[_g++]);
	return args;
}
function haxeLanguageServer_server_ServerRecordingTools_getSvnState(patchOutput,config) {
	if(!haxeLanguageServer_server_ServerRecordingTools_hasCommand("svn")) {
		return haxeLanguageServer_server_VcsState.None;
	}
	let revision = haxeLanguageServer_server_ServerRecordingTools_command("svn",["info","--show-item","revision"]);
	if(revision.code != 0) {
		return haxeLanguageServer_server_VcsState.None;
	}
	let hasExcludes = config.exclude.length > 0;
	let status = haxeLanguageServer_server_ServerRecordingTools_command("svn",["status"]);
	let untracked = [];
	if(!config.excludeUntracked) {
		let _g = [];
		let _g1 = 0;
		let _g2 = status.out.split("\n");
		while(_g1 < _g2.length) {
			let line = _g2[_g1];
			++_g1;
			if(HxOverrides.cca(line,0) != 63) {
				continue;
			}
			let entry = StringTools.trim(HxOverrides.substr(line,1,null));
			if(hasExcludes) {
				let excluded = false;
				let _g = 0;
				let _g1 = config.exclude;
				while(_g < _g1.length) if(entry.startsWith(_g1[_g++])) {
					excluded = true;
					break;
				}
				if(excluded) {
					continue;
				}
			}
			_g.push(entry);
		}
		untracked = _g;
	}
	let _g = 0;
	while(_g < untracked.length) haxeLanguageServer_server_ServerRecordingTools_command("svn",["add",untracked[_g++]]);
	let patch = haxeLanguageServer_server_ServerRecordingTools_command("svn",["diff","--depth=infinity","--patch-compatible"]);
	let hasPatch = StringTools.trim(patch.out).length > 0;
	if(hasPatch) {
		js_node_Fs.writeFileSync(patchOutput,patch.out);
	}
	let _g1 = 0;
	while(_g1 < untracked.length) haxeLanguageServer_server_ServerRecordingTools_command("svn",["rm","--keep-local",untracked[_g1++]]);
	return haxeLanguageServer_server_VcsState.Svn(revision.out,hasPatch);
}
function haxeLanguageServer_server_ServerRecordingTools_recordingRelativeRoot(config) {
	let ret = haxe_io_Path.isAbsolute(config.path) ? "" : config.path;
	if(ret.startsWith("./") || ret.startsWith("../")) {
		ret = "";
	}
	return ret.split("/")[0] + "/";
}
class haxeLanguageServer_tokentree_PositionAnalyzer {
	constructor(document) {
		this.document = document;
	}
	resolve(pos) {
		let tokens = this.document.get_tokens();
		if(tokens == null) {
			return null;
		}
		let found = false;
		let result = null;
		let _gthis = this;
		tokens.tree.filterCallback(function(token,_) {
			if(found) {
				return tokentree_FilterResult.SkipSubtree;
			}
			let _this = _gthis.document;
			let pos1 = tokens.getPos(token);
			let endOffset = pos1.max;
			let offsetKind = 1;
			if(haxeLanguageServer_extensions_RangeExtensions_containsPos({ start : _this.positionAt(pos1.min,offsetKind), end : _this.positionAt(endOffset,offsetKind)},pos)) {
				result = token;
				found = true;
				return tokentree_FilterResult.SkipSubtree;
			}
			let _this1 = _gthis.document;
			let pos2 = tokens.getTreePos(token);
			let endOffset1 = pos2.max;
			let offsetKind1 = 1;
			if(haxeLanguageServer_extensions_RangeExtensions_containsPos({ start : _this1.positionAt(pos2.min,offsetKind1), end : _this1.positionAt(endOffset1,offsetKind1)},pos)) {
				result = token;
				return tokentree_FilterResult.GoDeeper;
			}
			return tokentree_FilterResult.SkipSubtree;
		});
		return result;
	}
	static getStringKind(token,document,pos) {
		let tokens = document.get_tokens();
		if(token == null || tokens == null) {
			return haxeLanguageServer_tokentree_StringKind.None;
		}
		let _g = token.tok;
		if(_g._hx_index == 2) {
			if(_g.c._hx_index == 2) {
				let startPos = document.positionAt(tokens.getPos(token).min);
				switch(document.getText({ start : startPos, end : { line : startPos.line, character : startPos.character + 1}})) {
				case "\"":
					return haxeLanguageServer_tokentree_StringKind.DoubleQuote;
				case "'":
					return haxeLanguageServer_tokentree_StringKind.SingleQuote;
				default:
					return haxeLanguageServer_tokentree_StringKind.None;
				}
			} else {
				return haxeLanguageServer_tokentree_StringKind.None;
			}
		} else {
			return haxeLanguageServer_tokentree_StringKind.None;
		}
	}
	static getContext(token,document,completionPosition) {
		let tokens = document.get_tokens();
		if(token == null || tokens == null) {
			return haxeLanguageServer_tokentree_TokenContext.Root(haxeLanguageServer_tokentree_RootPosition.BeforePackage);
		}
		let typeToken = null;
		let fieldToken = null;
		let hasBlockParent = false;
		let parent = token;
		_hx_loop1: while(parent != null && parent != null && parent.tok != null) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				let _gk = _g.k;
				let tmp;
				if(_g._hx_index == 1) {
					switch(_g.k._hx_index) {
					case 1:case 26:case 28:case 32:case 40:
						tmp = true;
						break;
					default:
						tmp = false;
					}
				} else {
					tmp = false;
				}
				if(tmp && hasBlockParent) {
					typeToken = parent;
					break _hx_loop1;
				} else {
					switch(_gk._hx_index) {
					case 0:case 2:case 42:
						if(!tokentree_utils_TokenTreeCheckUtils.isModifier(token)) {
							fieldToken = parent;
						}
						break;
					default:
					}
				}
				break;
			case 18:
				if(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent) == tokentree_utils_BrOpenType.Block) {
					hasBlockParent = true;
				} else {
					let tmp;
					if(_g._hx_index == 1) {
						switch(_g.k._hx_index) {
						case 1:case 26:case 28:case 32:case 40:
							tmp = true;
							break;
						default:
							tmp = false;
						}
					} else {
						tmp = false;
					}
					if(tmp && hasBlockParent) {
						typeToken = parent;
						break _hx_loop1;
					}
				}
				break;
			default:
				let tmp1;
				if(_g._hx_index == 1) {
					switch(_g.k._hx_index) {
					case 1:case 26:case 28:case 32:case 40:
						tmp1 = true;
						break;
					default:
						tmp1 = false;
					}
				} else {
					tmp1 = false;
				}
				if(tmp1 && hasBlockParent) {
					typeToken = parent;
					break _hx_loop1;
				}
			}
			parent = tokentree_TokenTreeAccessHelper.parent(parent);
		}
		let getFieldKind = function() {
			let _v_ = fieldToken;
			let _g = _v_ == null ? null : _v_.tok;
			if(_g == null) {
				throw haxe_Exception.thrown("assert false");
			} else if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:
					return haxeLanguageServer_tokentree_FieldKind.Function;
				case 2:
					return haxeLanguageServer_tokentree_FieldKind.Var;
				case 42:
					return haxeLanguageServer_tokentree_FieldKind.Final;
				default:
					throw haxe_Exception.thrown("assert false");
				}
			} else {
				throw haxe_Exception.thrown("assert false");
			}
		};
		if(typeToken != null) {
			let tmp;
			if(typeToken != null) {
				let _g = typeToken.tok;
				if(_g._hx_index == 1) {
					switch(_g.k._hx_index) {
					case 1:
						tmp = tokentree_utils_TokenTreeCheckUtils.isTypeMacroClass(typeToken) ? haxeLanguageServer_tokentree_TypeKind.MacroClass : haxeLanguageServer_tokentree_TypeKind.Class;
						break;
					case 26:
						tmp = tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract(typeToken) ? haxeLanguageServer_tokentree_TypeKind.EnumAbstract : haxeLanguageServer_tokentree_TypeKind.Enum;
						break;
					case 28:
						tmp = haxeLanguageServer_tokentree_TypeKind.Interface;
						break;
					case 32:
						tmp = haxeLanguageServer_tokentree_TypeKind.Typedef;
						break;
					case 40:
						tmp = tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract(typeToken) ? haxeLanguageServer_tokentree_TypeKind.EnumAbstract : haxeLanguageServer_tokentree_TypeKind.Abstract;
						break;
					default:
						tmp = null;
					}
				} else {
					tmp = null;
				}
			} else {
				tmp = null;
			}
			return haxeLanguageServer_tokentree_TokenContext.Type({ kind : tmp, field : fieldToken != null ? { isStatic : tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.child(fieldToken,0),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdStatic)) != null, kind : getFieldKind()} : null});
		}
		if(typeToken == null && fieldToken != null) {
			return haxeLanguageServer_tokentree_TokenContext.ModuleLevelStatic(getFieldKind());
		}
		let pos = haxeLanguageServer_tokentree_RootPosition.BeforePackage;
		let root = tokens.tree;
		if(root.children == null) {
			return haxeLanguageServer_tokentree_TokenContext.Root(pos);
		}
		let _g = 0;
		let _g1 = root.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let pos1 = tokens.getPos(child);
			let endOffset = pos1.max;
			let offsetKind = 1;
			let childPos_start = document.positionAt(pos1.min,offsetKind);
			document.positionAt(endOffset,offsetKind);
			if(haxeLanguageServer_extensions_PositionExtensions_isAfter(childPos_start,completionPosition)) {
				break;
			}
			let _g2 = child.tok;
			if(_g2._hx_index == 1) {
				switch(_g2.k._hx_index) {
				case 34:
					pos = haxeLanguageServer_tokentree_RootPosition.BeforeFirstImport;
					break;
				case 13:case 36:
					pos = haxeLanguageServer_tokentree_RootPosition.BeforeFirstType;
					break;
				default:
					let tmp;
					if(_g2._hx_index == 1) {
						switch(_g2.k._hx_index) {
						case 1:case 26:case 28:case 32:case 40:
							tmp = true;
							break;
						default:
							tmp = false;
						}
					} else {
						tmp = false;
					}
					if(tmp) {
						pos = haxeLanguageServer_tokentree_RootPosition.AfterFirstType;
					}
				}
			} else {
				let tmp;
				if(_g2._hx_index == 1) {
					switch(_g2.k._hx_index) {
					case 1:case 26:case 28:case 32:case 40:
						tmp = true;
						break;
					default:
						tmp = false;
					}
				} else {
					tmp = false;
				}
				if(tmp) {
					pos = haxeLanguageServer_tokentree_RootPosition.AfterFirstType;
				}
			}
		}
		return haxeLanguageServer_tokentree_TokenContext.Root(pos);
	}
}
haxeLanguageServer_tokentree_PositionAnalyzer.__name__ = "haxeLanguageServer.tokentree.PositionAnalyzer";
Object.assign(haxeLanguageServer_tokentree_PositionAnalyzer.prototype, {
	__class__: haxeLanguageServer_tokentree_PositionAnalyzer
});
var haxeLanguageServer_tokentree_StringKind = $hxEnums["haxeLanguageServer.tokentree.StringKind"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"haxeLanguageServer.tokentree.StringKind",toString:$estr}
	,SingleQuote: {_hx_name:"SingleQuote",_hx_index:1,__enum__:"haxeLanguageServer.tokentree.StringKind",toString:$estr}
	,DoubleQuote: {_hx_name:"DoubleQuote",_hx_index:2,__enum__:"haxeLanguageServer.tokentree.StringKind",toString:$estr}
};
haxeLanguageServer_tokentree_StringKind.__constructs__ = [haxeLanguageServer_tokentree_StringKind.None,haxeLanguageServer_tokentree_StringKind.SingleQuote,haxeLanguageServer_tokentree_StringKind.DoubleQuote];
var haxeLanguageServer_tokentree_TokenContext = $hxEnums["haxeLanguageServer.tokentree.TokenContext"] = { __ename__:true,__constructs__:null
	,Root: ($_=function(pos) { return {_hx_index:0,pos:pos,__enum__:"haxeLanguageServer.tokentree.TokenContext",toString:$estr}; },$_._hx_name="Root",$_.__params__ = ["pos"],$_)
	,Type: ($_=function(type) { return {_hx_index:1,type:type,__enum__:"haxeLanguageServer.tokentree.TokenContext",toString:$estr}; },$_._hx_name="Type",$_.__params__ = ["type"],$_)
	,ModuleLevelStatic: ($_=function(kind) { return {_hx_index:2,kind:kind,__enum__:"haxeLanguageServer.tokentree.TokenContext",toString:$estr}; },$_._hx_name="ModuleLevelStatic",$_.__params__ = ["kind"],$_)
};
haxeLanguageServer_tokentree_TokenContext.__constructs__ = [haxeLanguageServer_tokentree_TokenContext.Root,haxeLanguageServer_tokentree_TokenContext.Type,haxeLanguageServer_tokentree_TokenContext.ModuleLevelStatic];
var haxeLanguageServer_tokentree_RootPosition = $hxEnums["haxeLanguageServer.tokentree.RootPosition"] = { __ename__:true,__constructs__:null
	,BeforePackage: {_hx_name:"BeforePackage",_hx_index:0,__enum__:"haxeLanguageServer.tokentree.RootPosition",toString:$estr}
	,BeforeFirstImport: {_hx_name:"BeforeFirstImport",_hx_index:1,__enum__:"haxeLanguageServer.tokentree.RootPosition",toString:$estr}
	,BeforeFirstType: {_hx_name:"BeforeFirstType",_hx_index:2,__enum__:"haxeLanguageServer.tokentree.RootPosition",toString:$estr}
	,AfterFirstType: {_hx_name:"AfterFirstType",_hx_index:3,__enum__:"haxeLanguageServer.tokentree.RootPosition",toString:$estr}
};
haxeLanguageServer_tokentree_RootPosition.__constructs__ = [haxeLanguageServer_tokentree_RootPosition.BeforePackage,haxeLanguageServer_tokentree_RootPosition.BeforeFirstImport,haxeLanguageServer_tokentree_RootPosition.BeforeFirstType,haxeLanguageServer_tokentree_RootPosition.AfterFirstType];
var haxeLanguageServer_tokentree_TypeKind = $hxEnums["haxeLanguageServer.tokentree.TypeKind"] = { __ename__:true,__constructs__:null
	,Class: {_hx_name:"Class",_hx_index:0,__enum__:"haxeLanguageServer.tokentree.TypeKind",toString:$estr}
	,Interface: {_hx_name:"Interface",_hx_index:1,__enum__:"haxeLanguageServer.tokentree.TypeKind",toString:$estr}
	,Enum: {_hx_name:"Enum",_hx_index:2,__enum__:"haxeLanguageServer.tokentree.TypeKind",toString:$estr}
	,EnumAbstract: {_hx_name:"EnumAbstract",_hx_index:3,__enum__:"haxeLanguageServer.tokentree.TypeKind",toString:$estr}
	,Abstract: {_hx_name:"Abstract",_hx_index:4,__enum__:"haxeLanguageServer.tokentree.TypeKind",toString:$estr}
	,Typedef: {_hx_name:"Typedef",_hx_index:5,__enum__:"haxeLanguageServer.tokentree.TypeKind",toString:$estr}
	,MacroClass: {_hx_name:"MacroClass",_hx_index:6,__enum__:"haxeLanguageServer.tokentree.TypeKind",toString:$estr}
};
haxeLanguageServer_tokentree_TypeKind.__constructs__ = [haxeLanguageServer_tokentree_TypeKind.Class,haxeLanguageServer_tokentree_TypeKind.Interface,haxeLanguageServer_tokentree_TypeKind.Enum,haxeLanguageServer_tokentree_TypeKind.EnumAbstract,haxeLanguageServer_tokentree_TypeKind.Abstract,haxeLanguageServer_tokentree_TypeKind.Typedef,haxeLanguageServer_tokentree_TypeKind.MacroClass];
var haxeLanguageServer_tokentree_FieldKind = $hxEnums["haxeLanguageServer.tokentree.FieldKind"] = { __ename__:true,__constructs__:null
	,Var: {_hx_name:"Var",_hx_index:0,__enum__:"haxeLanguageServer.tokentree.FieldKind",toString:$estr}
	,Final: {_hx_name:"Final",_hx_index:1,__enum__:"haxeLanguageServer.tokentree.FieldKind",toString:$estr}
	,Function: {_hx_name:"Function",_hx_index:2,__enum__:"haxeLanguageServer.tokentree.FieldKind",toString:$estr}
};
haxeLanguageServer_tokentree_FieldKind.__constructs__ = [haxeLanguageServer_tokentree_FieldKind.Var,haxeLanguageServer_tokentree_FieldKind.Final,haxeLanguageServer_tokentree_FieldKind.Function];
class haxeLanguageServer_tokentree_TokenTreeManager {
	constructor(bytes,list,tree) {
		this.bytes = bytes;
		this.list = list;
		this.tree = tree;
	}
	getPos(tokenTree) {
		if(this.tokenCharacterRanges == null) {
			this.tokenCharacterRanges = new haxe_ds_IntMap();
			let offset = 0;
			let _g = 0;
			let _g1 = this.list.length;
			while(_g < _g1) {
				let i = _g++;
				let token = this.list[i];
				let _g1 = token.tok;
				let offset1;
				switch(_g1._hx_index) {
				case 1:
					let _gc = _g1.c;
					switch(_gc._hx_index) {
					case 2:
						let _gs = _gc.s;
						offset1 = _gs.length - js_node_buffer_Buffer.byteLength(_gs);
						break;
					case 4:
						let _gr = _gc.r;
						offset1 = _gr.length - js_node_buffer_Buffer.byteLength(_gr);
						break;
					default:
						offset1 = 0;
					}
					break;
				case 3:
					let _gs1 = _g1.s;
					offset1 = _gs1.length - js_node_buffer_Buffer.byteLength(_gs1);
					break;
				case 4:
					let _gs2 = _g1.s;
					offset1 = _gs2.length - js_node_buffer_Buffer.byteLength(_gs2);
					break;
				default:
					offset1 = 0;
				}
				offset += offset1;
				if(offset != 0) {
					this.tokenCharacterRanges.h[i] = { file : token.pos.file, min : token.pos.min + offset, max : token.pos.max + offset};
				}
			}
		}
		let pos = this.tokenCharacterRanges.h[tokenTree.index];
		if(pos == null) {
			return tokenTree.pos;
		} else {
			return pos;
		}
	}
	getTreePos(tokenTree) {
		let pos = this.getPos(tokenTree);
		let children = tokenTree.children;
		if(pos == null || children == null) {
			return pos;
		}
		if(children.length <= 0) {
			return pos;
		}
		let fullPos = { file : pos.file, min : pos.min, max : pos.max};
		let _g = 0;
		while(_g < children.length) {
			let childPos = this.getTreePos(children[_g++]);
			if(childPos == null) {
				continue;
			}
			if(childPos.min < fullPos.min) {
				fullPos.min = childPos.min;
			}
			if(childPos.max > fullPos.max) {
				fullPos.max = childPos.max;
			}
		}
		return fullPos;
	}
	getTokenAtOffset(off) {
		if(this.list.length <= 0) {
			return null;
		}
		if(off < 0) {
			return null;
		}
		if(off > this.list[this.list.length - 1].pos.max) {
			return null;
		}
		if(this.tokenCharacterRanges == null) {
			this.tokenCharacterRanges = new haxe_ds_IntMap();
			let offset = 0;
			let _g = 0;
			let _g1 = this.list.length;
			while(_g < _g1) {
				let i = _g++;
				let token = this.list[i];
				let _g1 = token.tok;
				let offset1;
				switch(_g1._hx_index) {
				case 1:
					let _gc = _g1.c;
					switch(_gc._hx_index) {
					case 2:
						let _gs = _gc.s;
						offset1 = _gs.length - js_node_buffer_Buffer.byteLength(_gs);
						break;
					case 4:
						let _gr = _gc.r;
						offset1 = _gr.length - js_node_buffer_Buffer.byteLength(_gr);
						break;
					default:
						offset1 = 0;
					}
					break;
				case 3:
					let _gs1 = _g1.s;
					offset1 = _gs1.length - js_node_buffer_Buffer.byteLength(_gs1);
					break;
				case 4:
					let _gs2 = _g1.s;
					offset1 = _gs2.length - js_node_buffer_Buffer.byteLength(_gs2);
					break;
				default:
					offset1 = 0;
				}
				offset += offset1;
				if(offset != 0) {
					this.tokenCharacterRanges.h[i] = { file : token.pos.file, min : token.pos.min + offset, max : token.pos.max + offset};
				}
			}
		}
		let _g = 0;
		let _g1 = this.list.length;
		while(_g < _g1) {
			let index = _g++;
			let range = this.tokenCharacterRanges.h[index];
			if(range == null) {
				range = this.list[index].pos;
			}
			if(range.max < off) {
				continue;
			}
			if(off < range.min) {
				return null;
			}
			return this.findTokenAtIndex(this.tree,index);
		}
		return null;
	}
	findTokenAtIndex(parent,index) {
		if(parent.children == null) {
			return null;
		}
		let _g = 0;
		let _g1 = parent.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			if(child.index == index) {
				return child;
			}
			let token = this.findTokenAtIndex(child,index);
			if(token != null) {
				return token;
			}
		}
		return null;
	}
	static create(content) {
		let bytes = haxe_io_Bytes.ofString(content);
		let tokens = haxeLanguageServer_tokentree_TokenTreeManager.createTokens(bytes);
		return new haxeLanguageServer_tokentree_TokenTreeManager(bytes,tokens,haxeLanguageServer_tokentree_TokenTreeManager.createTokenTree(bytes,tokens));
	}
	static createTokens(bytes) {
		try {
			let tokens = [];
			let lexer = new haxeparser_HaxeLexer(bytes);
			let t = lexer.token(haxeparser_HaxeLexer.tok);
			while(t.tok != haxeparser_TokenDef.Eof) {
				tokens.push(t);
				t = lexer.token(haxeparser_HaxeLexer.tok);
			}
			return tokens;
		} catch( _g ) {
			throw haxe_Exception.thrown("failed to create tokens: " + Std.string(haxe_Exception.caught(_g)));
		}
	}
	static createTokenTree(bytes,tokens) {
		try {
			tokentree_TokenStream.MODE = tokentree_TokenStreamMode.Relaxed;
			return tokentree_TokenTreeBuilder.buildTokenTree(tokens,bytes);
		} catch( _g ) {
			throw haxe_Exception.thrown("failed to create token tree: " + Std.string(haxe_Exception.caught(_g)));
		}
	}
}
haxeLanguageServer_tokentree_TokenTreeManager.__name__ = "haxeLanguageServer.tokentree.TokenTreeManager";
Object.assign(haxeLanguageServer_tokentree_TokenTreeManager.prototype, {
	__class__: haxeLanguageServer_tokentree_TokenTreeManager
});
var haxeparser_Keyword = $hxEnums["haxeparser.Keyword"] = { __ename__:true,__constructs__:null
	,KwdFunction: {_hx_name:"KwdFunction",_hx_index:0,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdClass: {_hx_name:"KwdClass",_hx_index:1,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdVar: {_hx_name:"KwdVar",_hx_index:2,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdIf: {_hx_name:"KwdIf",_hx_index:3,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdElse: {_hx_name:"KwdElse",_hx_index:4,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdWhile: {_hx_name:"KwdWhile",_hx_index:5,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDo: {_hx_name:"KwdDo",_hx_index:6,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFor: {_hx_name:"KwdFor",_hx_index:7,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdBreak: {_hx_name:"KwdBreak",_hx_index:8,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdContinue: {_hx_name:"KwdContinue",_hx_index:9,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdReturn: {_hx_name:"KwdReturn",_hx_index:10,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdExtends: {_hx_name:"KwdExtends",_hx_index:11,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdImplements: {_hx_name:"KwdImplements",_hx_index:12,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdImport: {_hx_name:"KwdImport",_hx_index:13,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdSwitch: {_hx_name:"KwdSwitch",_hx_index:14,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCase: {_hx_name:"KwdCase",_hx_index:15,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDefault: {_hx_name:"KwdDefault",_hx_index:16,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdStatic: {_hx_name:"KwdStatic",_hx_index:17,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPublic: {_hx_name:"KwdPublic",_hx_index:18,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPrivate: {_hx_name:"KwdPrivate",_hx_index:19,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTry: {_hx_name:"KwdTry",_hx_index:20,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCatch: {_hx_name:"KwdCatch",_hx_index:21,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdNew: {_hx_name:"KwdNew",_hx_index:22,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdThis: {_hx_name:"KwdThis",_hx_index:23,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdThrow: {_hx_name:"KwdThrow",_hx_index:24,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdExtern: {_hx_name:"KwdExtern",_hx_index:25,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdEnum: {_hx_name:"KwdEnum",_hx_index:26,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdIn: {_hx_name:"KwdIn",_hx_index:27,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdInterface: {_hx_name:"KwdInterface",_hx_index:28,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdUntyped: {_hx_name:"KwdUntyped",_hx_index:29,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCast: {_hx_name:"KwdCast",_hx_index:30,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdOverride: {_hx_name:"KwdOverride",_hx_index:31,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTypedef: {_hx_name:"KwdTypedef",_hx_index:32,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDynamic: {_hx_name:"KwdDynamic",_hx_index:33,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPackage: {_hx_name:"KwdPackage",_hx_index:34,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdInline: {_hx_name:"KwdInline",_hx_index:35,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdUsing: {_hx_name:"KwdUsing",_hx_index:36,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdNull: {_hx_name:"KwdNull",_hx_index:37,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTrue: {_hx_name:"KwdTrue",_hx_index:38,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFalse: {_hx_name:"KwdFalse",_hx_index:39,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdAbstract: {_hx_name:"KwdAbstract",_hx_index:40,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdMacro: {_hx_name:"KwdMacro",_hx_index:41,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFinal: {_hx_name:"KwdFinal",_hx_index:42,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdOperator: {_hx_name:"KwdOperator",_hx_index:43,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdOverload: {_hx_name:"KwdOverload",_hx_index:44,__enum__:"haxeparser.Keyword",toString:$estr}
};
haxeparser_Keyword.__constructs__ = [haxeparser_Keyword.KwdFunction,haxeparser_Keyword.KwdClass,haxeparser_Keyword.KwdVar,haxeparser_Keyword.KwdIf,haxeparser_Keyword.KwdElse,haxeparser_Keyword.KwdWhile,haxeparser_Keyword.KwdDo,haxeparser_Keyword.KwdFor,haxeparser_Keyword.KwdBreak,haxeparser_Keyword.KwdContinue,haxeparser_Keyword.KwdReturn,haxeparser_Keyword.KwdExtends,haxeparser_Keyword.KwdImplements,haxeparser_Keyword.KwdImport,haxeparser_Keyword.KwdSwitch,haxeparser_Keyword.KwdCase,haxeparser_Keyword.KwdDefault,haxeparser_Keyword.KwdStatic,haxeparser_Keyword.KwdPublic,haxeparser_Keyword.KwdPrivate,haxeparser_Keyword.KwdTry,haxeparser_Keyword.KwdCatch,haxeparser_Keyword.KwdNew,haxeparser_Keyword.KwdThis,haxeparser_Keyword.KwdThrow,haxeparser_Keyword.KwdExtern,haxeparser_Keyword.KwdEnum,haxeparser_Keyword.KwdIn,haxeparser_Keyword.KwdInterface,haxeparser_Keyword.KwdUntyped,haxeparser_Keyword.KwdCast,haxeparser_Keyword.KwdOverride,haxeparser_Keyword.KwdTypedef,haxeparser_Keyword.KwdDynamic,haxeparser_Keyword.KwdPackage,haxeparser_Keyword.KwdInline,haxeparser_Keyword.KwdUsing,haxeparser_Keyword.KwdNull,haxeparser_Keyword.KwdTrue,haxeparser_Keyword.KwdFalse,haxeparser_Keyword.KwdAbstract,haxeparser_Keyword.KwdMacro,haxeparser_Keyword.KwdFinal,haxeparser_Keyword.KwdOperator,haxeparser_Keyword.KwdOverload];
var haxeparser_TokenDef = $hxEnums["haxeparser.TokenDef"] = { __ename__:true,__constructs__:null
	,Eof: {_hx_name:"Eof",_hx_index:0,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Const: ($_=function(c) { return {_hx_index:1,c:c,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="Const",$_.__params__ = ["c"],$_)
	,Kwd: ($_=function(k) { return {_hx_index:2,k:k,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="Kwd",$_.__params__ = ["k"],$_)
	,Comment: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="Comment",$_.__params__ = ["s"],$_)
	,CommentLine: ($_=function(s) { return {_hx_index:4,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="CommentLine",$_.__params__ = ["s"],$_)
	,Binop: ($_=function(op) { return {_hx_index:5,op:op,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="Binop",$_.__params__ = ["op"],$_)
	,Unop: ($_=function(op) { return {_hx_index:6,op:op,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="Unop",$_.__params__ = ["op"],$_)
	,Semicolon: {_hx_name:"Semicolon",_hx_index:7,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Comma: {_hx_name:"Comma",_hx_index:8,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BrOpen: {_hx_name:"BrOpen",_hx_index:9,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BrClose: {_hx_name:"BrClose",_hx_index:10,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BkOpen: {_hx_name:"BkOpen",_hx_index:11,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BkClose: {_hx_name:"BkClose",_hx_index:12,__enum__:"haxeparser.TokenDef",toString:$estr}
	,POpen: {_hx_name:"POpen",_hx_index:13,__enum__:"haxeparser.TokenDef",toString:$estr}
	,PClose: {_hx_name:"PClose",_hx_index:14,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Dot: {_hx_name:"Dot",_hx_index:15,__enum__:"haxeparser.TokenDef",toString:$estr}
	,DblDot: {_hx_name:"DblDot",_hx_index:16,__enum__:"haxeparser.TokenDef",toString:$estr}
	,QuestionDot: {_hx_name:"QuestionDot",_hx_index:17,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Arrow: {_hx_name:"Arrow",_hx_index:18,__enum__:"haxeparser.TokenDef",toString:$estr}
	,IntInterval: ($_=function(s) { return {_hx_index:19,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="IntInterval",$_.__params__ = ["s"],$_)
	,Sharp: ($_=function(s) { return {_hx_index:20,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="Sharp",$_.__params__ = ["s"],$_)
	,Question: {_hx_name:"Question",_hx_index:21,__enum__:"haxeparser.TokenDef",toString:$estr}
	,At: {_hx_name:"At",_hx_index:22,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Dollar: ($_=function(s) { return {_hx_index:23,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_._hx_name="Dollar",$_.__params__ = ["s"],$_)
	,Spread: {_hx_name:"Spread",_hx_index:24,__enum__:"haxeparser.TokenDef",toString:$estr}
};
haxeparser_TokenDef.__constructs__ = [haxeparser_TokenDef.Eof,haxeparser_TokenDef.Const,haxeparser_TokenDef.Kwd,haxeparser_TokenDef.Comment,haxeparser_TokenDef.CommentLine,haxeparser_TokenDef.Binop,haxeparser_TokenDef.Unop,haxeparser_TokenDef.Semicolon,haxeparser_TokenDef.Comma,haxeparser_TokenDef.BrOpen,haxeparser_TokenDef.BrClose,haxeparser_TokenDef.BkOpen,haxeparser_TokenDef.BkClose,haxeparser_TokenDef.POpen,haxeparser_TokenDef.PClose,haxeparser_TokenDef.Dot,haxeparser_TokenDef.DblDot,haxeparser_TokenDef.QuestionDot,haxeparser_TokenDef.Arrow,haxeparser_TokenDef.IntInterval,haxeparser_TokenDef.Sharp,haxeparser_TokenDef.Question,haxeparser_TokenDef.At,haxeparser_TokenDef.Dollar,haxeparser_TokenDef.Spread];
var haxeparser_Constant = $hxEnums["haxeparser.Constant"] = { __ename__:true,__constructs__:null
	,CInt: ($_=function(v,s) { return {_hx_index:0,v:v,s:s,__enum__:"haxeparser.Constant",toString:$estr}; },$_._hx_name="CInt",$_.__params__ = ["v","s"],$_)
	,CFloat: ($_=function(f,s) { return {_hx_index:1,f:f,s:s,__enum__:"haxeparser.Constant",toString:$estr}; },$_._hx_name="CFloat",$_.__params__ = ["f","s"],$_)
	,CString: ($_=function(s,kind) { return {_hx_index:2,s:s,kind:kind,__enum__:"haxeparser.Constant",toString:$estr}; },$_._hx_name="CString",$_.__params__ = ["s","kind"],$_)
	,CIdent: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxeparser.Constant",toString:$estr}; },$_._hx_name="CIdent",$_.__params__ = ["s"],$_)
	,CRegexp: ($_=function(r,opt) { return {_hx_index:4,r:r,opt:opt,__enum__:"haxeparser.Constant",toString:$estr}; },$_._hx_name="CRegexp",$_.__params__ = ["r","opt"],$_)
	,CMarkup: ($_=function(s) { return {_hx_index:5,s:s,__enum__:"haxeparser.Constant",toString:$estr}; },$_._hx_name="CMarkup",$_.__params__ = ["s"],$_)
};
haxeparser_Constant.__constructs__ = [haxeparser_Constant.CInt,haxeparser_Constant.CFloat,haxeparser_Constant.CString,haxeparser_Constant.CIdent,haxeparser_Constant.CRegexp,haxeparser_Constant.CMarkup];
class haxeparser_TokenDefPrinter {
	static toString(def) {
		switch(def._hx_index) {
		case 0:
			return "<eof>";
		case 1:
			return haxeparser_TokenDefPrinter.constToString(def.c);
		case 2:
			let _gk = def.k;
			return HxOverrides.substr($hxEnums[_gk.__enum__].__constructs__[_gk._hx_index]._hx_name,3,null).toLowerCase();
		case 3:
			return "/*" + def.s + "*/";
		case 4:
			return "//" + def.s;
		case 5:
			return new haxe_macro_Printer("").printBinop(def.op);
		case 6:
			return new haxe_macro_Printer("").printUnop(def.op);
		case 7:
			return ";";
		case 8:
			return ",";
		case 9:
			return "{";
		case 10:
			return "}";
		case 11:
			return "[";
		case 12:
			return "]";
		case 13:
			return "(";
		case 14:
			return ")";
		case 15:
			return ".";
		case 16:
			return ":";
		case 17:
			return "?.";
		case 18:
			return "->";
		case 19:
			return "" + def.s + "...";
		case 20:
			return "#" + def.s;
		case 21:
			return "?";
		case 22:
			return "@";
		case 23:
			return "$" + def.s;
		case 24:
			return "...";
		}
	}
	static constToString($const) {
		switch($const._hx_index) {
		case 0:
			let _gv = $const.v;
			let _gs = $const.s;
			if(_gs == null) {
				return _gv;
			} else {
				return "" + _gv + _gs;
			}
			break;
		case 1:
			let _gf = $const.f;
			let _gs1 = $const.s;
			if(_gs1 == null) {
				return _gf;
			} else {
				return "" + _gf + _gs1;
			}
			break;
		case 2:
			let _gs2 = $const.s;
			let _gkind = $const.kind;
			if(_gkind == null) {
				return "\"" + _gs2 + "\"";
			} else {
				switch(_gkind._hx_index) {
				case 0:
					return "\"" + _gs2 + "\"";
				case 1:
					return "'" + _gs2 + "'";
				}
			}
			break;
		case 3:
			return $const.s;
		case 4:
			return "~/" + $const.r + "/" + $const.opt;
		case 5:
			return $const.s;
		}
	}
}
haxeparser_TokenDefPrinter.__name__ = "haxeparser.TokenDefPrinter";
class haxeparser_Token {
	constructor(tok,pos) {
		this.tok = tok;
		this.pos = pos;
	}
	toString() {
		return haxeparser_TokenDefPrinter.toString(this.tok);
	}
}
haxeparser_Token.__name__ = "haxeparser.Token";
Object.assign(haxeparser_Token.prototype, {
	__class__: haxeparser_Token
});
var haxeparser_LexerErrorMsg = $hxEnums["haxeparser.LexerErrorMsg"] = { __ename__:true,__constructs__:null
	,UnterminatedString: {_hx_name:"UnterminatedString",_hx_index:0,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnterminatedRegExp: {_hx_name:"UnterminatedRegExp",_hx_index:1,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnclosedComment: {_hx_name:"UnclosedComment",_hx_index:2,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnterminatedEscapeSequence: {_hx_name:"UnterminatedEscapeSequence",_hx_index:3,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,InvalidEscapeSequence: ($_=function(c) { return {_hx_index:4,c:c,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}; },$_._hx_name="InvalidEscapeSequence",$_.__params__ = ["c"],$_)
	,UnknownEscapeSequence: ($_=function(c) { return {_hx_index:5,c:c,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}; },$_._hx_name="UnknownEscapeSequence",$_.__params__ = ["c"],$_)
	,UnclosedCode: {_hx_name:"UnclosedCode",_hx_index:6,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
};
haxeparser_LexerErrorMsg.__constructs__ = [haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_LexerErrorMsg.UnterminatedRegExp,haxeparser_LexerErrorMsg.UnclosedComment,haxeparser_LexerErrorMsg.UnterminatedEscapeSequence,haxeparser_LexerErrorMsg.InvalidEscapeSequence,haxeparser_LexerErrorMsg.UnknownEscapeSequence,haxeparser_LexerErrorMsg.UnclosedCode];
class haxeparser_LexerError {
	constructor(msg,pos) {
		this.msg = msg;
		this.pos = pos;
	}
}
haxeparser_LexerError.__name__ = "haxeparser.LexerError";
Object.assign(haxeparser_LexerError.prototype, {
	__class__: haxeparser_LexerError
});
class hxparse_Lexer {
	constructor(input,sourceName) {
		if(sourceName == null) {
			sourceName = "<null>";
		}
		this.current = "";
		this.input = input;
		this.source = sourceName;
		this.pos = 0;
	}
	token(ruleset) {
		if(this.pos == this.input.length) {
			if(ruleset.eofFunction != null) {
				return ruleset.eofFunction(this);
			} else {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			}
		}
		let state = ruleset.state;
		let lastMatch = null;
		let lastMatchPos = this.pos;
		let start = this.pos;
		do {
			if(state.finalId > -1) {
				lastMatch = state;
				lastMatchPos = this.pos;
			}
			if(this.pos == this.input.length) {
				break;
			}
			let i = this.input.b[this.pos];
			++this.pos;
			state = state.trans[i];
		} while(state != null);
		this.pos = lastMatchPos;
		this.current = this.input.getString(start,this.pos - start);
		if(lastMatch == null || lastMatch.finalId == -1) {
			let code = this.input.b[this.pos];
			throw haxe_Exception.thrown(new hxparse_UnexpectedChar(String.fromCodePoint(code),new hxparse_Position(this.source,this.pos - this.current.length,this.pos)));
		}
		return ruleset.functions[lastMatch.finalId](this);
	}
	static buildRuleset(rules,name) {
		if(name == null) {
			name = "";
		}
		let cases = [];
		let functions = [];
		let eofFunction = null;
		let _g = 0;
		while(_g < rules.length) {
			let rule = rules[_g];
			++_g;
			if(rule.rule == "") {
				eofFunction = rule.func;
			} else {
				cases.push(hxparse_LexEngine.parse(rule.rule));
				functions.push(rule.func);
			}
		}
		return new hxparse_Ruleset(new hxparse_LexEngine(cases).firstState(),functions,eofFunction,name);
	}
}
hxparse_Lexer.__name__ = "hxparse.Lexer";
Object.assign(hxparse_Lexer.prototype, {
	__class__: hxparse_Lexer
});
class hxparse_RuleBuilder {
}
hxparse_RuleBuilder.__name__ = "hxparse.RuleBuilder";
hxparse_RuleBuilder.__isInterface__ = true;
class hxparse__$LexEngine_CharRange {
	constructor(min,max) {
		this.min = min;
		this.max = max;
	}
}
hxparse__$LexEngine_CharRange.__name__ = "hxparse._LexEngine.CharRange";
Object.assign(hxparse__$LexEngine_CharRange.prototype, {
	__class__: hxparse__$LexEngine_CharRange
});
class hxparse_LexEngine {
	constructor(patterns) {
		this.nodes = [];
		this.finals = [];
		this.states = [];
		this.hstates = new haxe_ds_StringMap();
		this.uid = 0;
		let pid = 0;
		let _g = 0;
		while(_g < patterns.length) {
			let p = patterns[_g++];
			let id = pid++;
			let f = new hxparse__$LexEngine_Node(this.uid++,id);
			let n = this.initNode(p,f,id);
			this.nodes.push(n);
			this.finals.push(f);
		}
		this.makeState(this.addNodes([],this.nodes));
	}
	firstState() {
		return this.states[0];
	}
	makeState(nodes) {
		let buf_b = "";
		let _g = 0;
		while(_g < nodes.length) {
			buf_b += Std.string(nodes[_g++].id);
			buf_b += String.fromCodePoint(45);
		}
		let key = buf_b;
		let s = this.hstates.h[key];
		if(s != null) {
			return s;
		}
		s = new hxparse_State();
		this.states.push(s);
		this.hstates.h[key] = s;
		let trans = this.getTransitions(nodes);
		let _g1 = 0;
		while(_g1 < trans.length) {
			let t = trans[_g1];
			++_g1;
			let target = this.makeState(t.n);
			let _g = 0;
			let _g2 = t.chars;
			while(_g < _g2.length) {
				let chr = _g2[_g];
				++_g;
				let _g1 = chr.min;
				let _g3 = chr.max + 1;
				while(_g1 < _g3) s.trans[_g1++] = target;
			}
		}
		let _gthis = this;
		let setFinal = function() {
			let _g = 0;
			let _g1 = _gthis.finals;
			while(_g < _g1.length) {
				let f = _g1[_g++];
				let _g2 = 0;
				while(_g2 < nodes.length) {
					let n = nodes[_g2];
					++_g2;
					if(n == f) {
						s.finalId = n.pid;
						return;
					}
				}
			}
		};
		if(s.finalId == -1) {
			setFinal();
		}
		return s;
	}
	getTransitions(nodes) {
		let tl = [];
		let _g = 0;
		while(_g < nodes.length) {
			let _g1 = 0;
			let _g2 = nodes[_g++].trans;
			while(_g1 < _g2.length) tl.push(_g2[_g1++]);
		}
		tl.sort(function(t1,t2) {
			return t1.n.id - t2.n.id;
		});
		let t0 = tl[0];
		let _g1 = 1;
		let _g2 = tl.length;
		while(_g1 < _g2) {
			let i = _g1++;
			let t1 = tl[i];
			if(t0.n == t1.n) {
				tl[i - 1] = null;
				t1 = { chars : hxparse_LexEngine.cunion(t0.chars,t1.chars), n : t1.n};
				tl[i] = t1;
			}
			t0 = t1;
		}
		while(HxOverrides.remove(tl,null)) {
		}
		let allChars = hxparse_LexEngine.EMPTY;
		let allStates = new haxe_ds_List();
		let _g3 = 0;
		while(_g3 < tl.length) {
			let t = tl[_g3];
			++_g3;
			let states = new haxe_ds_List();
			states.push({ chars : hxparse_LexEngine.cdiff(t.chars,allChars), n : [t.n]});
			let _g_head = allStates.h;
			while(_g_head != null) {
				let val = _g_head.item;
				_g_head = _g_head.next;
				let nodes = val.n.slice();
				nodes.push(t.n);
				states.push({ chars : hxparse_LexEngine.cinter(val.chars,t.chars), n : nodes});
				states.push({ chars : hxparse_LexEngine.cdiff(val.chars,t.chars), n : val.n});
			}
			let _g_head1 = states.h;
			while(_g_head1 != null) {
				let val = _g_head1.item;
				_g_head1 = _g_head1.next;
				if(val.chars.length == 0) {
					states.remove(val);
				}
			}
			allChars = hxparse_LexEngine.cunion(allChars,t.chars);
			allStates = states;
		}
		let states = [];
		let _g_head = allStates.h;
		while(_g_head != null) {
			let val = _g_head.item;
			_g_head = _g_head.next;
			states.push({ chars : val.chars, n : this.addNodes([],val.n)});
		}
		states.sort(function(s1,s2) {
			let a = s1.chars.length;
			let b = s2.chars.length;
			let _g = 0;
			let _g1 = a < b ? a : b;
			while(_g < _g1) {
				let i = _g++;
				let a = s1.chars[i];
				let b = s2.chars[i];
				if(a.min != b.min) {
					return b.min - a.min;
				}
				if(a.max != b.max) {
					return b.max - a.max;
				}
			}
			if(a < b) {
				return b - a;
			}
			return 0;
		});
		return states;
	}
	addNode(nodes,n) {
		let _g = 0;
		while(_g < nodes.length) if(n == nodes[_g++]) {
			return;
		}
		nodes.push(n);
		this.addNodes(nodes,n.epsilon);
	}
	addNodes(nodes,add) {
		let _g = 0;
		while(_g < add.length) this.addNode(nodes,add[_g++]);
		return nodes;
	}
	initNode(p,finalId,pid) {
		switch(p._hx_index) {
		case 0:
			return finalId;
		case 1:
			let n = new hxparse__$LexEngine_Node(this.uid++,pid);
			n.trans.push({ chars : p.c, n : finalId});
			return n;
		case 2:
			let n1 = new hxparse__$LexEngine_Node(this.uid++,pid);
			let an = this.initNode(p.p,n1,pid);
			n1.epsilon.push(an);
			n1.epsilon.push(finalId);
			return n1;
		case 3:
			let n2 = new hxparse__$LexEngine_Node(this.uid++,pid);
			let an1 = this.initNode(p.p,n2,pid);
			n2.epsilon.push(an1);
			n2.epsilon.push(finalId);
			return an1;
		case 4:
			return this.initNode(p.p1,this.initNode(p.p2,finalId,pid),pid);
		case 5:
			let n3 = new hxparse__$LexEngine_Node(this.uid++,pid);
			n3.epsilon.push(this.initNode(p.p1,finalId,pid));
			n3.epsilon.push(this.initNode(p.p2,finalId,pid));
			return n3;
		case 6:
			return this.initNode(p.p,finalId,pid);
		}
	}
	static parse(pattern) {
		let p = hxparse_LexEngine.parseInner(haxe_io_Bytes.ofString(pattern));
		if(p == null) {
			throw haxe_Exception.thrown("Invalid pattern '" + pattern + "'");
		}
		return p.pattern;
	}
	static next(a,b) {
		if(a == hxparse__$LexEngine_Pattern.Empty) {
			return b;
		} else {
			return hxparse__$LexEngine_Pattern.Next(a,b);
		}
	}
	static plus(r) {
		if(r._hx_index == 4) {
			return hxparse__$LexEngine_Pattern.Next(r.p1,hxparse_LexEngine.plus(r.p2));
		} else {
			return hxparse__$LexEngine_Pattern.Plus(r);
		}
	}
	static star(r) {
		if(r._hx_index == 4) {
			return hxparse__$LexEngine_Pattern.Next(r.p1,hxparse_LexEngine.star(r.p2));
		} else {
			return hxparse__$LexEngine_Pattern.Star(r);
		}
	}
	static opt(r) {
		if(r._hx_index == 4) {
			return hxparse__$LexEngine_Pattern.Next(r.p1,hxparse_LexEngine.opt(r.p2));
		} else {
			return hxparse__$LexEngine_Pattern.Choice(r,hxparse__$LexEngine_Pattern.Empty);
		}
	}
	static cinter(c1,c2) {
		return hxparse_LexEngine.ccomplement(hxparse_LexEngine.cunion(hxparse_LexEngine.ccomplement(c1),hxparse_LexEngine.ccomplement(c2)));
	}
	static cdiff(c1,c2) {
		return hxparse_LexEngine.ccomplement(hxparse_LexEngine.cunion(hxparse_LexEngine.ccomplement(c1),c2));
	}
	static ccomplement(c) {
		let first = c[0];
		let start = first != null && first.min == -1 ? c.shift().max + 1 : -1;
		let out = [];
		let _g = 0;
		while(_g < c.length) {
			let k = c[_g];
			++_g;
			out.push(new hxparse__$LexEngine_CharRange(start,k.min - 1));
			start = k.max + 1;
		}
		if(start <= 255) {
			out.push(new hxparse__$LexEngine_CharRange(start,255));
		}
		return out;
	}
	static cunion(ca,cb) {
		let i = 0;
		let j = 0;
		let out = [];
		i = 1;
		let a = ca[0];
		j = 1;
		let b = cb[0];
		while(true) {
			if(a == null) {
				out.push(b);
				while(j < cb.length) out.push(cb[j++]);
				break;
			}
			if(b == null) {
				out.push(a);
				while(i < ca.length) out.push(ca[i++]);
				break;
			}
			if(a.min <= b.min) {
				if(a.max + 1 < b.min) {
					out.push(a);
					a = ca[i++];
				} else if(a.max < b.max) {
					b = new hxparse__$LexEngine_CharRange(a.min,b.max);
					a = ca[i++];
				} else {
					b = cb[j++];
				}
			} else {
				let tmp = ca;
				ca = cb;
				cb = tmp;
				let tmp1 = j;
				j = i;
				i = tmp1;
				let tmp2 = a;
				a = b;
				b = tmp2;
			}
		}
		return out;
	}
	static parseInner(pattern,i,pDepth) {
		if(pDepth == null) {
			pDepth = 0;
		}
		if(i == null) {
			i = 0;
		}
		let readChar = function() {
			i += 1;
			let c = pattern.b[i - 1];
			if(c != c) {
				c = 92;
			} else if(c == 120) {
				c = Std.parseInt("0x" + pattern.getString(i,2));
				i += 2;
			} else if(c >= 48 && c <= 57) {
				let v = c - 48;
				while(true) {
					let cNext = pattern.b[i];
					if(cNext >= 48 && cNext <= 57) {
						v = v * 10 + (cNext - 48);
						i += 1;
					} else {
						break;
					}
				}
				c = v;
			}
			return c;
		};
		let r = hxparse__$LexEngine_Pattern.Empty;
		let l = pattern.length;
		while(i < l) {
			i += 1;
			let c = pattern.b[i - 1];
			if(c > 255) {
				throw haxe_Exception.thrown(c);
			}
			switch(c) {
			case 40:
				let r2 = hxparse_LexEngine.parseInner(pattern,i,pDepth + 1);
				i = r2.pos;
				r = hxparse_LexEngine.next(r,r2.pattern);
				break;
			case 41:
				if(r == hxparse__$LexEngine_Pattern.Empty) {
					throw haxe_Exception.thrown("Empty group");
				}
				return { pattern : hxparse__$LexEngine_Pattern.Group(r), pos : i};
			case 42:
				if(r != hxparse__$LexEngine_Pattern.Empty) {
					r = hxparse_LexEngine.star(r);
				} else {
					r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
				}
				break;
			case 43:
				if(r != hxparse__$LexEngine_Pattern.Empty) {
					r = hxparse_LexEngine.plus(r);
				} else {
					r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
				}
				break;
			case 46:
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match(hxparse_LexEngine.ALL_CHARS));
				break;
			case 63:
				if(r != hxparse__$LexEngine_Pattern.Empty) {
					r = hxparse_LexEngine.opt(r);
				} else {
					r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
				}
				break;
			case 91:
				if(pattern.length > 1) {
					let range = 0;
					let acc = [];
					let not = pattern.b[i] == 94;
					if(not) {
						i += 1;
					}
					while(true) {
						i += 1;
						let c = pattern.b[i - 1];
						if(c == 93) {
							if(range != 0) {
								return null;
							}
							break;
						} else if(c == 45) {
							if(range != 0) {
								return null;
							}
							let last = acc.pop();
							if(last == null) {
								acc.push(new hxparse__$LexEngine_CharRange(c,c));
							} else {
								if(last.min != last.max) {
									return null;
								}
								range = last.min;
							}
						} else {
							if(c == 92) {
								c = readChar();
							}
							if(range == 0) {
								acc.push(new hxparse__$LexEngine_CharRange(c,c));
							} else {
								acc.push(new hxparse__$LexEngine_CharRange(range,c));
								range = 0;
							}
						}
					}
					let g = [];
					let _g = 0;
					while(_g < acc.length) g = hxparse_LexEngine.cunion(g,[acc[_g++]]);
					if(not) {
						g = hxparse_LexEngine.cdiff(hxparse_LexEngine.ALL_CHARS,g);
					}
					r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match(g));
				} else {
					r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
				}
				break;
			case 92:
				c = readChar();
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
				break;
			case 124:
				if(r != hxparse__$LexEngine_Pattern.Empty) {
					let r2 = hxparse_LexEngine.parseInner(pattern,i);
					return { pattern : hxparse__$LexEngine_Pattern.Choice(r,r2.pattern), pos : r2.pos};
				} else {
					r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
				}
				break;
			default:
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
		}
		if(pDepth != 0) {
			throw haxe_Exception.thrown("Found unclosed parenthesis while parsing \"" + Std.string(pattern) + "\"");
		}
		return { pattern : r, pos : i};
	}
}
hxparse_LexEngine.__name__ = "hxparse.LexEngine";
Object.assign(hxparse_LexEngine.prototype, {
	__class__: hxparse_LexEngine
});
var hxparse__$LexEngine_Pattern = $hxEnums["hxparse._LexEngine.Pattern"] = { __ename__:true,__constructs__:null
	,Empty: {_hx_name:"Empty",_hx_index:0,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}
	,Match: ($_=function(c) { return {_hx_index:1,c:c,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_._hx_name="Match",$_.__params__ = ["c"],$_)
	,Star: ($_=function(p) { return {_hx_index:2,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_._hx_name="Star",$_.__params__ = ["p"],$_)
	,Plus: ($_=function(p) { return {_hx_index:3,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_._hx_name="Plus",$_.__params__ = ["p"],$_)
	,Next: ($_=function(p1,p2) { return {_hx_index:4,p1:p1,p2:p2,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_._hx_name="Next",$_.__params__ = ["p1","p2"],$_)
	,Choice: ($_=function(p1,p2) { return {_hx_index:5,p1:p1,p2:p2,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_._hx_name="Choice",$_.__params__ = ["p1","p2"],$_)
	,Group: ($_=function(p) { return {_hx_index:6,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_._hx_name="Group",$_.__params__ = ["p"],$_)
};
hxparse__$LexEngine_Pattern.__constructs__ = [hxparse__$LexEngine_Pattern.Empty,hxparse__$LexEngine_Pattern.Match,hxparse__$LexEngine_Pattern.Star,hxparse__$LexEngine_Pattern.Plus,hxparse__$LexEngine_Pattern.Next,hxparse__$LexEngine_Pattern.Choice,hxparse__$LexEngine_Pattern.Group];
class hxparse__$LexEngine_Node {
	constructor(id,pid) {
		this.id = id;
		this.pid = pid;
		this.trans = [];
		this.epsilon = [];
	}
}
hxparse__$LexEngine_Node.__name__ = "hxparse._LexEngine.Node";
Object.assign(hxparse__$LexEngine_Node.prototype, {
	__class__: hxparse__$LexEngine_Node
});
class hxparse_Ruleset {
	constructor(state,functions,eofFunction,name) {
		if(name == null) {
			name = "";
		}
		this.state = state;
		this.functions = functions;
		this.eofFunction = eofFunction;
		this.name = name;
	}
}
hxparse_Ruleset.__name__ = "hxparse.Ruleset";
Object.assign(hxparse_Ruleset.prototype, {
	__class__: hxparse_Ruleset
});
class hxparse_Position {
	constructor(source,min,max) {
		this.psource = source;
		this.pmin = min;
		this.pmax = max;
	}
	toString() {
		return "" + this.psource + ":characters " + this.pmin + "-" + this.pmax;
	}
	getLinePosition(input) {
		let lineMin = 1;
		let lineMax = 1;
		let posMin = 0;
		let posMax = 0;
		let cur = 0;
		while(cur < this.pmin) {
			if(input.b[cur] == 10) {
				++lineMin;
				posMin = cur + 1;
			}
			++cur;
		}
		lineMax = lineMin;
		posMax = posMin;
		posMin = cur - posMin;
		while(cur < this.pmax) {
			if(input.b[cur] == 10) {
				++lineMax;
				posMax = cur + 1;
			}
			++cur;
		}
		posMax = cur - posMax;
		return { lineMin : lineMin, lineMax : lineMax, posMin : posMin, posMax : posMax};
	}
	format(input) {
		let linePos = this.getLinePosition(input);
		if(linePos.lineMin != linePos.lineMax) {
			return "" + this.psource + ":lines " + linePos.lineMin + "-" + linePos.lineMax;
		} else {
			return "" + this.psource + ":" + linePos.lineMin + ": characters " + linePos.posMin + "-" + linePos.posMax;
		}
	}
}
hxparse_Position.__name__ = "hxparse.Position";
Object.assign(hxparse_Position.prototype, {
	__class__: hxparse_Position
});
class haxeparser_HaxeLexer extends hxparse_Lexer {
	constructor(input,sourceName) {
		super(input,sourceName);
	}
	static mkPos(p) {
		return { file : p.psource, min : p.pmin, max : p.pmax};
	}
	static mk(lexer,td) {
		return new haxeparser_Token(td,haxeparser_HaxeLexer.mkPos(new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos)));
	}
	static inlineMarkup(lexer) {
		let tagName = HxOverrides.substr(lexer.current,1,null);
		let startPos = lexer.pos - lexer.current.length;
		let text = lexer.input.getString(startPos,lexer.input.length - startPos);
		let startTag = "<" + tagName;
		let endTag = "</" + tagName + ">";
		let normalLt = function() {
			lexer.pos = startPos + 1;
			lexer.current = "<";
			return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLt));
		};
		let depth = 0;
		let index = 0;
		while(true) {
			let indexStartTag = text.indexOf(startTag,index);
			let indexEndTag = text.indexOf(endTag,index);
			if(indexStartTag == -1 && indexEndTag == -1) {
				return normalLt();
			}
			if(indexStartTag == -1) {
				indexStartTag = indexEndTag + 1;
			}
			if(indexEndTag == -1) {
				indexEndTag = indexStartTag + 1;
			}
			if(indexStartTag < indexEndTag) {
				index = indexStartTag + startTag.length;
				switch(text.charAt(index)) {
				case " ":case "/":case ">":
					break;
				default:
					continue;
				}
				++depth;
				let indexSelfClosing = text.indexOf("/>",index);
				let indexTagClosing = text.indexOf(">",index);
				let indexOpenTag = text.indexOf("<",index);
				if(indexSelfClosing == -1 && indexTagClosing == -1 && indexOpenTag == -1) {
					return normalLt();
				}
				if(indexSelfClosing == -1) {
					indexSelfClosing = (Math.max(indexTagClosing,indexOpenTag) | 0) + 1;
				}
				if(indexTagClosing == -1) {
					indexTagClosing = (Math.max(indexSelfClosing,indexOpenTag) | 0) + 1;
				}
				if(indexOpenTag == -1) {
					indexOpenTag = (Math.max(indexSelfClosing,indexTagClosing) | 0) + 1;
				}
				if(indexSelfClosing < indexTagClosing && indexSelfClosing < indexOpenTag) {
					index = indexSelfClosing + 2;
					--depth;
				}
				if(indexTagClosing < indexSelfClosing && indexTagClosing < indexOpenTag) {
					index = indexTagClosing + 1;
				}
				if(indexOpenTag < indexSelfClosing && indexOpenTag < indexTagClosing) {
					index = indexOpenTag;
				}
			}
			if(indexEndTag < indexStartTag) {
				index = indexEndTag + endTag.length;
				--depth;
			}
			if(depth <= 0) {
				break;
			}
		}
		text = HxOverrides.substr(text,0,index);
		let textBytes = haxe_io_Bytes.ofString(text);
		let endPos = startPos + textBytes.length;
		lexer.current = text;
		lexer.pos = endPos;
		return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxeparser_Constant.CMarkup(text)));
	}
	static splitSuffix(value,pivot,isInt) {
		let literal = HxOverrides.substr(value,0,pivot);
		let suffix = HxOverrides.substr(value,pivot,null);
		if(literal.endsWith("_")) {
			literal = HxOverrides.substr(literal,0,literal.length - 1);
		}
		if(isInt) {
			return haxeparser_TokenDef.Const(haxeparser_Constant.CInt(literal,suffix));
		}
		return haxeparser_TokenDef.Const(haxeparser_Constant.CFloat(literal,suffix));
	}
	static splitIntSuffix(value) {
		let index = value.indexOf("i");
		if(index <= 0) {
			index = value.indexOf("u");
		}
		if(index <= 0) {
			return haxeparser_TokenDef.Const(haxeparser_Constant.CInt(value));
		}
		return haxeparser_HaxeLexer.splitSuffix(value,index,true);
	}
	static splitFloatSuffix(value) {
		let index = value.indexOf("f");
		if(index <= 0) {
			return haxeparser_TokenDef.Const(haxeparser_Constant.CFloat(value));
		}
		return haxeparser_HaxeLexer.splitSuffix(value,index,false);
	}
	static unescape(s,pos) {
		let b_b = "";
		let i = 0;
		let esc = false;
		while(s.length != i) {
			let c = HxOverrides.cca(s,i);
			if(esc) {
				let iNext = i + 1;
				let _hx_tmp;
				if(c == null) {
					_hx_tmp = c >= 48 && c <= 51;
					if(_hx_tmp == true) {
						iNext += 2;
					} else {
						let c1 = c;
						throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnknownEscapeSequence("\\" + String.fromCodePoint(c1)),{ file : pos.file, min : pos.min + i, max : pos.min + i + 1}));
					}
				} else {
					switch(c) {
					case 34:case 39:case 92:
						b_b += String.fromCodePoint(c);
						break;
					case 110:
						b_b += "\n";
						break;
					case 114:
						b_b += "\r";
						break;
					case 116:
						b_b += "\t";
						break;
					case 117:
						_hx_tmp = c >= 48 && c <= 51;
						if(_hx_tmp == true) {
							iNext += 2;
						} else {
							let c;
							if(s.charAt(i + 1) == "{") {
								let endIndex = s.indexOf("}",i + 3);
								if(endIndex == -1) {
									throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedEscapeSequence,{ file : pos.file, min : pos.min + i, max : pos.min + i + 2}));
								}
								let l = endIndex - (i + 2);
								let chars = HxOverrides.substr(s,i + 2,l);
								if(!new EReg("^[0-9a-fA-F]+$","").match(chars)) {
									throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u{" + chars + "}"),{ file : pos.file, min : pos.min + i, max : pos.min + i + (3 + l)}));
								}
								c = Std.parseInt("0x" + chars);
								if(c > 1114111) {
									throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u{" + chars + "}"),{ file : pos.file, min : pos.min + i, max : pos.min + i + (3 + l)}));
								}
								iNext += 2 + l;
							} else {
								let chars = HxOverrides.substr(s,i + 1,4);
								if(!new EReg("^[0-9a-fA-F]{4}$","").match(chars)) {
									throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u" + chars),{ file : pos.file, min : pos.min + i, max : pos.min + i + 5}));
								}
								c = Std.parseInt("0x" + chars);
								iNext += 4;
							}
							b_b += String.fromCodePoint(c);
						}
						break;
					case 120:
						_hx_tmp = c >= 48 && c <= 51;
						if(_hx_tmp == true) {
							iNext += 2;
						} else {
							let chars = HxOverrides.substr(s,i + 1,2);
							if(!new EReg("^[0-9a-fA-F]{2}$","").match(chars)) {
								throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\x" + chars),{ file : pos.file, min : pos.min + i, max : pos.min + i + 3}));
							}
							let c = Std.parseInt("0x" + chars);
							b_b += String.fromCodePoint(c);
							iNext += 2;
						}
						break;
					default:
						_hx_tmp = c >= 48 && c <= 51;
						if(_hx_tmp == true) {
							iNext += 2;
						} else {
							let c1 = c;
							throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnknownEscapeSequence("\\" + String.fromCodePoint(c1)),{ file : pos.file, min : pos.min + i, max : pos.min + i + 1}));
						}
					}
				}
				esc = false;
				i = iNext;
			} else if(c == null) {
				b_b += String.fromCodePoint(c);
				++i;
			} else if(c == 92) {
				++i;
				esc = true;
			} else {
				b_b += String.fromCodePoint(c);
				++i;
			}
		}
		return b_b;
	}
}
haxeparser_HaxeLexer.__name__ = "haxeparser.HaxeLexer";
haxeparser_HaxeLexer.__interfaces__ = [hxparse_RuleBuilder];
haxeparser_HaxeLexer.__super__ = hxparse_Lexer;
Object.assign(haxeparser_HaxeLexer.prototype, {
	__class__: haxeparser_HaxeLexer
});
class hxjsonast_Error {
	constructor(message,pos) {
		this.message = message;
		this.pos = pos;
	}
}
hxjsonast_Error.__name__ = "hxjsonast.Error";
Object.assign(hxjsonast_Error.prototype, {
	__class__: hxjsonast_Error
});
class hxjsonast_Json {
	constructor(value,pos) {
		this.value = value;
		this.pos = pos;
	}
}
hxjsonast_Json.__name__ = "hxjsonast.Json";
Object.assign(hxjsonast_Json.prototype, {
	__class__: hxjsonast_Json
});
var hxjsonast_JsonValue = $hxEnums["hxjsonast.JsonValue"] = { __ename__:true,__constructs__:null
	,JString: ($_=function(s) { return {_hx_index:0,s:s,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_._hx_name="JString",$_.__params__ = ["s"],$_)
	,JNumber: ($_=function(s) { return {_hx_index:1,s:s,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_._hx_name="JNumber",$_.__params__ = ["s"],$_)
	,JObject: ($_=function(fields) { return {_hx_index:2,fields:fields,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_._hx_name="JObject",$_.__params__ = ["fields"],$_)
	,JArray: ($_=function(values) { return {_hx_index:3,values:values,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_._hx_name="JArray",$_.__params__ = ["values"],$_)
	,JBool: ($_=function(b) { return {_hx_index:4,b:b,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_._hx_name="JBool",$_.__params__ = ["b"],$_)
	,JNull: {_hx_name:"JNull",_hx_index:5,__enum__:"hxjsonast.JsonValue",toString:$estr}
};
hxjsonast_JsonValue.__constructs__ = [hxjsonast_JsonValue.JString,hxjsonast_JsonValue.JNumber,hxjsonast_JsonValue.JObject,hxjsonast_JsonValue.JArray,hxjsonast_JsonValue.JBool,hxjsonast_JsonValue.JNull];
class hxjsonast_JObjectField {
	constructor(name,namePos,value) {
		this.name = name;
		this.namePos = namePos;
		this.value = value;
	}
}
hxjsonast_JObjectField.__name__ = "hxjsonast.JObjectField";
Object.assign(hxjsonast_JObjectField.prototype, {
	__class__: hxjsonast_JObjectField
});
class hxjsonast_Parser {
	constructor(source,filename) {
		this.source = source;
		this.filename = filename;
		this.pos = 0;
	}
	doParse() {
		let result = this.parseRec();
		let c;
		while(true) {
			c = this.source.charCodeAt(this.pos++);
			if(!(c == c)) {
				break;
			}
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			default:
				this.invalidChar();
			}
		}
		return result;
	}
	parseRec() {
		while(true) {
			let c = this.source.charCodeAt(this.pos++);
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			case 34:
				let save = this.pos;
				return new hxjsonast_Json(hxjsonast_JsonValue.JString(this.parseString()),new hxjsonast_Position(this.filename,save - 1,this.pos));
			case 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
				let start = this.pos - 1;
				let minus = c == 45;
				let digit = !minus;
				let zero = c == 48;
				let point = false;
				let e = false;
				let pm = false;
				let end = false;
				do switch(this.source.charCodeAt(this.pos++)) {
				case 43:case 45:
					if(!e || pm) {
						this.invalidNumber(start);
					}
					digit = false;
					pm = true;
					break;
				case 46:
					if(minus || point || e) {
						this.invalidNumber(start);
					}
					digit = false;
					point = true;
					break;
				case 48:
					if(zero && !point) {
						this.invalidNumber(start);
					}
					if(minus) {
						minus = false;
						zero = true;
					}
					digit = true;
					break;
				case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
					if(zero && !point) {
						this.invalidNumber(start);
					}
					if(minus) {
						minus = false;
					}
					digit = true;
					zero = false;
					break;
				case 69:case 101:
					if(minus || zero || e) {
						this.invalidNumber(start);
					}
					digit = false;
					e = true;
					break;
				default:
					if(!digit) {
						this.invalidNumber(start);
					}
					this.pos--;
					end = true;
				} while(!end);
				return new hxjsonast_Json(hxjsonast_JsonValue.JNumber(HxOverrides.substr(this.source,start,this.pos - start)),new hxjsonast_Position(this.filename,start,this.pos));
			case 91:
				let values = [];
				let comma = null;
				let startPos = this.pos - 1;
				while(true) switch(this.source.charCodeAt(this.pos++)) {
				case 9:case 10:case 13:case 32:
					break;
				case 44:
					if(comma) {
						comma = false;
					} else {
						this.invalidChar();
					}
					break;
				case 93:
					if(comma == false) {
						this.invalidChar();
					}
					return new hxjsonast_Json(hxjsonast_JsonValue.JArray(values),new hxjsonast_Position(this.filename,startPos,this.pos));
				default:
					if(comma) {
						this.invalidChar();
					}
					this.pos--;
					values.push(this.parseRec());
					comma = true;
				}
				break;
			case 102:
				let save1 = this.pos;
				if(this.source.charCodeAt(this.pos++) != 97 || this.source.charCodeAt(this.pos++) != 108 || this.source.charCodeAt(this.pos++) != 115 || this.source.charCodeAt(this.pos++) != 101) {
					this.pos = save1;
					this.invalidChar();
				}
				return new hxjsonast_Json(hxjsonast_JsonValue.JBool(false),new hxjsonast_Position(this.filename,save1 - 1,this.pos));
			case 110:
				let save2 = this.pos;
				if(this.source.charCodeAt(this.pos++) != 117 || this.source.charCodeAt(this.pos++) != 108 || this.source.charCodeAt(this.pos++) != 108) {
					this.pos = save2;
					this.invalidChar();
				}
				return new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position(this.filename,save2 - 1,this.pos));
			case 116:
				let save3 = this.pos;
				if(this.source.charCodeAt(this.pos++) != 114 || this.source.charCodeAt(this.pos++) != 117 || this.source.charCodeAt(this.pos++) != 101) {
					this.pos = save3;
					this.invalidChar();
				}
				return new hxjsonast_Json(hxjsonast_JsonValue.JBool(true),new hxjsonast_Position(this.filename,save3 - 1,this.pos));
			case 123:
				let fields = [];
				let names_h = Object.create(null);
				let field = null;
				let fieldPos = null;
				let comma1 = null;
				let startPos1 = this.pos - 1;
				while(true) switch(this.source.charCodeAt(this.pos++)) {
				case 9:case 10:case 13:case 32:
					break;
				case 34:
					if(field != null || comma1) {
						this.invalidChar();
					}
					let fieldStartPos = this.pos - 1;
					field = this.parseString();
					fieldPos = new hxjsonast_Position(this.filename,fieldStartPos,this.pos);
					if(Object.prototype.hasOwnProperty.call(names_h,field)) {
						throw haxe_Exception.thrown(new hxjsonast_Error("Duplicate field name \"" + field + "\"",fieldPos));
					} else {
						names_h[field] = true;
					}
					break;
				case 44:
					if(comma1) {
						comma1 = false;
					} else {
						this.invalidChar();
					}
					break;
				case 58:
					if(field == null) {
						this.invalidChar();
					}
					fields.push(new hxjsonast_JObjectField(field,fieldPos,this.parseRec()));
					field = null;
					fieldPos = null;
					comma1 = true;
					break;
				case 125:
					if(field != null || comma1 == false) {
						this.invalidChar();
					}
					return new hxjsonast_Json(hxjsonast_JsonValue.JObject(fields),new hxjsonast_Position(this.filename,startPos1,this.pos));
				default:
					this.invalidChar();
				}
				break;
			default:
				this.invalidChar();
			}
		}
	}
	parseString() {
		let start = this.pos;
		let buf = null;
		while(true) {
			let c = this.source.charCodeAt(this.pos++);
			if(c == 34) {
				break;
			}
			if(c == 92) {
				if(buf == null) {
					buf = new StringBuf();
				}
				let s = this.source;
				let len = this.pos - start - 1;
				buf.b += len == null ? HxOverrides.substr(s,start,null) : HxOverrides.substr(s,start,len);
				c = this.source.charCodeAt(this.pos++);
				switch(c) {
				case 34:case 47:case 92:
					buf.b += String.fromCodePoint(c);
					break;
				case 98:
					buf.b += String.fromCodePoint(8);
					break;
				case 102:
					buf.b += String.fromCodePoint(12);
					break;
				case 110:
					buf.b += String.fromCodePoint(10);
					break;
				case 114:
					buf.b += String.fromCodePoint(13);
					break;
				case 116:
					buf.b += String.fromCodePoint(9);
					break;
				case 117:
					let uc = Std.parseInt("0x" + HxOverrides.substr(this.source,this.pos,4));
					this.pos += 4;
					buf.b += String.fromCodePoint(uc);
					break;
				default:
					throw haxe_Exception.thrown(new hxjsonast_Error("Invalid escape sequence \\" + String.fromCodePoint(c),new hxjsonast_Position(this.filename,this.pos - 2,this.pos)));
				}
				start = this.pos;
			} else if(c != c) {
				this.pos--;
				throw haxe_Exception.thrown(new hxjsonast_Error("Unclosed string",new hxjsonast_Position(this.filename,start - 1,this.pos)));
			}
		}
		if(buf == null) {
			return HxOverrides.substr(this.source,start,this.pos - start - 1);
		} else {
			let s = this.source;
			let len = this.pos - start - 1;
			buf.b += len == null ? HxOverrides.substr(s,start,null) : HxOverrides.substr(s,start,len);
			return buf.b;
		}
	}
	invalidChar() {
		this.pos--;
		throw haxe_Exception.thrown(new hxjsonast_Error("Invalid character: " + this.source.charAt(this.pos),new hxjsonast_Position(this.filename,this.pos,this.pos + 1)));
	}
	invalidNumber(start) {
		throw haxe_Exception.thrown(new hxjsonast_Error("Invalid number: " + this.source.substring(start,this.pos),new hxjsonast_Position(this.filename,start,this.pos)));
	}
}
hxjsonast_Parser.__name__ = "hxjsonast.Parser";
Object.assign(hxjsonast_Parser.prototype, {
	__class__: hxjsonast_Parser
});
class hxjsonast_Position {
	constructor(file,min,max) {
		this.file = file;
		this.min = min;
		this.max = max;
	}
}
hxjsonast_Position.__name__ = "hxjsonast.Position";
Object.assign(hxjsonast_Position.prototype, {
	__class__: hxjsonast_Position
});
class hxparse_ParserError {
	constructor(pos) {
		this.pos = pos;
	}
	toString() {
		return "Parser error";
	}
}
hxparse_ParserError.__name__ = "hxparse.ParserError";
Object.assign(hxparse_ParserError.prototype, {
	__class__: hxparse_ParserError
});
class hxparse_State {
	constructor() {
		this.finalId = -1;
		this.trans = new Array(256);
	}
}
hxparse_State.__name__ = "hxparse.State";
Object.assign(hxparse_State.prototype, {
	__class__: hxparse_State
});
class hxparse_UnexpectedChar extends hxparse_ParserError {
	constructor(char,pos) {
		super(pos);
		this.char = char;
	}
	toString() {
		return "Unexpected " + this.char;
	}
}
hxparse_UnexpectedChar.__name__ = "hxparse.UnexpectedChar";
hxparse_UnexpectedChar.__super__ = hxparse_ParserError;
Object.assign(hxparse_UnexpectedChar.prototype, {
	__class__: hxparse_UnexpectedChar
});
var js_node_ChildProcess = require("child_process");
var js_node_Fs = require("fs");
var js_node_Net = require("net");
var js_node_Path = require("path");
class js_node_buffer__$Buffer_Helper {
	static bytesOfBuffer(b) {
		let o = Object.create(haxe_io_Bytes.prototype);
		o.length = b.byteLength;
		o.b = b;
		b.bufferValue = b;
		b.hxBytes = o;
		b.bytes = b;
		return o;
	}
}
js_node_buffer__$Buffer_Helper.__name__ = "js.node.buffer._Buffer.Helper";
var json2object_Error = $hxEnums["json2object.Error"] = { __ename__:true,__constructs__:null
	,IncorrectType: ($_=function(variable,expected,pos) { return {_hx_index:0,variable:variable,expected:expected,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_._hx_name="IncorrectType",$_.__params__ = ["variable","expected","pos"],$_)
	,IncorrectEnumValue: ($_=function(value,expected,pos) { return {_hx_index:1,value:value,expected:expected,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_._hx_name="IncorrectEnumValue",$_.__params__ = ["value","expected","pos"],$_)
	,InvalidEnumConstructor: ($_=function(value,expected,pos) { return {_hx_index:2,value:value,expected:expected,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_._hx_name="InvalidEnumConstructor",$_.__params__ = ["value","expected","pos"],$_)
	,UninitializedVariable: ($_=function(variable,pos) { return {_hx_index:3,variable:variable,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_._hx_name="UninitializedVariable",$_.__params__ = ["variable","pos"],$_)
	,UnknownVariable: ($_=function(variable,pos) { return {_hx_index:4,variable:variable,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_._hx_name="UnknownVariable",$_.__params__ = ["variable","pos"],$_)
	,ParserError: ($_=function(message,pos) { return {_hx_index:5,message:message,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_._hx_name="ParserError",$_.__params__ = ["message","pos"],$_)
	,CustomFunctionException: ($_=function(e,pos) { return {_hx_index:6,e:e,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_._hx_name="CustomFunctionException",$_.__params__ = ["e","pos"],$_)
};
json2object_Error.__constructs__ = [json2object_Error.IncorrectType,json2object_Error.IncorrectEnumValue,json2object_Error.InvalidEnumConstructor,json2object_Error.UninitializedVariable,json2object_Error.UnknownVariable,json2object_Error.ParserError,json2object_Error.CustomFunctionException];
var json2object_InternalError = $hxEnums["json2object.InternalError"] = { __ename__:true,__constructs__:null
	,AbstractNoJsonRepresentation: ($_=function(name) { return {_hx_index:0,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_._hx_name="AbstractNoJsonRepresentation",$_.__params__ = ["name"],$_)
	,CannotGenerateSchema: ($_=function(name) { return {_hx_index:1,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_._hx_name="CannotGenerateSchema",$_.__params__ = ["name"],$_)
	,HandleExpr: {_hx_name:"HandleExpr",_hx_index:2,__enum__:"json2object.InternalError",toString:$estr}
	,ParsingThrow: {_hx_name:"ParsingThrow",_hx_index:3,__enum__:"json2object.InternalError",toString:$estr}
	,UnsupportedAbstractEnumType: ($_=function(name) { return {_hx_index:4,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_._hx_name="UnsupportedAbstractEnumType",$_.__params__ = ["name"],$_)
	,UnsupportedEnumAbstractValue: ($_=function(name) { return {_hx_index:5,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_._hx_name="UnsupportedEnumAbstractValue",$_.__params__ = ["name"],$_)
	,UnsupportedMapKeyType: ($_=function(name) { return {_hx_index:6,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_._hx_name="UnsupportedMapKeyType",$_.__params__ = ["name"],$_)
	,UnsupportedSchemaObjectType: ($_=function(name) { return {_hx_index:7,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_._hx_name="UnsupportedSchemaObjectType",$_.__params__ = ["name"],$_)
	,UnsupportedSchemaType: ($_=function(type) { return {_hx_index:8,type:type,__enum__:"json2object.InternalError",toString:$estr}; },$_._hx_name="UnsupportedSchemaType",$_.__params__ = ["type"],$_)
};
json2object_InternalError.__constructs__ = [json2object_InternalError.AbstractNoJsonRepresentation,json2object_InternalError.CannotGenerateSchema,json2object_InternalError.HandleExpr,json2object_InternalError.ParsingThrow,json2object_InternalError.UnsupportedAbstractEnumType,json2object_InternalError.UnsupportedEnumAbstractValue,json2object_InternalError.UnsupportedMapKeyType,json2object_InternalError.UnsupportedSchemaObjectType,json2object_InternalError.UnsupportedSchemaType];
class json2object_PositionUtils {
	constructor(content) {
		this.linesInfo = [];
		let s = 0;
		let e = 0;
		let i = 0;
		let lineCount = 0;
		while(i < content.length) switch(content.charAt(i)) {
		case "\n":
			e = i;
			this.linesInfo.push({ number : lineCount, start : s, end : e});
			++lineCount;
			++i;
			s = i;
			break;
		case "\r":
			e = i;
			if(content.charAt(i + 1) == "\n") {
				++e;
			}
			this.linesInfo.push({ number : lineCount, start : s, end : e});
			++lineCount;
			i = e + 1;
			s = i;
			break;
		default:
			++i;
		}
		this.linesInfo.push({ number : lineCount, start : s, end : i});
	}
	convertPosition(position) {
		let min = position.min;
		let max = position.max;
		let pos = { file : position.file, min : min + 1, max : max + 1, lines : []};
		let bounds_min = 0;
		let bounds_max = this.linesInfo.length - 1;
		if(min > this.linesInfo[0].end) {
			while(bounds_max > bounds_min) {
				let i = (bounds_min + bounds_max) / 2 | 0;
				let line = this.linesInfo[i];
				if(line.start == min) {
					bounds_min = i;
					bounds_max = i;
				}
				if(line.end < min) {
					bounds_min = i + 1;
				}
				if(line.start > min || line.end >= min && line.start < min) {
					bounds_max = i;
				}
			}
		}
		let _g = bounds_min;
		let _g1 = this.linesInfo.length;
		while(_g < _g1) {
			let line = this.linesInfo[_g++];
			if(line.start <= min && line.end >= max) {
				pos.lines.push({ number : line.number + 1, start : min - line.start + 1, end : max - line.start + 1});
				break;
			}
			if(line.start <= min && min <= line.end) {
				pos.lines.push({ number : line.number + 1, start : min - line.start + 1, end : line.end + 1});
			}
			if(line.start <= max && max <= line.end) {
				pos.lines.push({ number : line.number + 1, start : line.start + 1, end : max - line.start + 1});
			}
			if(line.start >= max || line.end >= max) {
				break;
			}
		}
		return pos;
	}
}
json2object_PositionUtils.__name__ = "json2object.PositionUtils";
Object.assign(json2object_PositionUtils.prototype, {
	__class__: json2object_PositionUtils
});
class jsonrpc__$CancellationToken_CancellationTokenImpl {
	constructor() {
		this.canceled = false;
	}
}
jsonrpc__$CancellationToken_CancellationTokenImpl.__name__ = "jsonrpc._CancellationToken.CancellationTokenImpl";
Object.assign(jsonrpc__$CancellationToken_CancellationTokenImpl.prototype, {
	__class__: jsonrpc__$CancellationToken_CancellationTokenImpl
});
class jsonrpc_ErrorUtils {
	static errorToString(error,intro) {
		let result = intro + Std.string(error);
		let stack = haxe_CallStack.exceptionStack();
		if(stack != null && stack.length > 0) {
			result += "\n" + haxe_CallStack.toString(stack);
		}
		return result;
	}
}
jsonrpc_ErrorUtils.__name__ = "jsonrpc.ErrorUtils";
class jsonrpc_Protocol {
	constructor(writeMessage) {
		this.writeMessage = writeMessage;
		this.requestTokens = new haxe_ds_StringMap();
		this.nextRequestId = 0;
		this.requestHandlers = new haxe_ds_StringMap();
		this.notificationHandlers = new haxe_ds_StringMap();
		this.progressHandlers = new haxe_ds_ObjectMap();
		this.responseCallbacks = new haxe_ds_IntMap();
		let _gthis = this;
		this.onNotification("$/progress",function(params) {
			let handler = _gthis.progressHandlers.h[params.token.__id__];
			if(handler != null) {
				handler(params.value);
			}
		});
	}
	handleMessage(message) {
		if((Object.prototype.hasOwnProperty.call(message,"result") || Object.prototype.hasOwnProperty.call(message,"error")) && Object.prototype.hasOwnProperty.call(message,"id")) {
			this.handleResponse(message);
		} else if(Object.prototype.hasOwnProperty.call(message,"method")) {
			if(Object.prototype.hasOwnProperty.call(message,"id")) {
				this.handleRequest(message);
			} else {
				this.handleNotification(message);
			}
		}
	}
	onRequest(method,handler) {
		this.requestHandlers.h[method] = handler;
	}
	onNotification(method,handler) {
		this.notificationHandlers.h[method] = handler;
	}
	handleRequest(request) {
		let tokenKey = Std.string(request.id);
		let _gthis = this;
		let resolve = function(result) {
			let _this = _gthis.requestTokens;
			if(Object.prototype.hasOwnProperty.call(_this.h,tokenKey)) {
				delete(_this.h[tokenKey]);
			}
			let response = { jsonrpc : "2.0", id : request.id, result : result};
			_gthis.writeMessage(response,null);
			if(_gthis.didRespondToRequest != null) {
				_gthis.didRespondToRequest(request,response);
			}
		};
		let reject = function(error) {
			let _this = _gthis.requestTokens;
			if(Object.prototype.hasOwnProperty.call(_this.h,tokenKey)) {
				delete(_this.h[tokenKey]);
			}
			_gthis.writeMessage({ jsonrpc : "2.0", id : request.id, error : error},null);
		};
		let handler = this.requestHandlers.h[request.method];
		if(handler == null) {
			let reject1 = reject;
			let data = null;
			let this1 = { code : -32601, message : "Unhandled method " + request.method};
			if(data != null) {
				this1.data = data;
			}
			reject1(this1);
			return;
		}
		let tokenSource = new jsonrpc__$CancellationToken_CancellationTokenImpl();
		this.requestTokens.h[tokenKey] = tokenSource;
		try {
			handler(request.params,tokenSource,resolve,reject);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			let _this = this.requestTokens;
			if(Object.prototype.hasOwnProperty.call(_this.h,tokenKey)) {
				delete(_this.h[tokenKey]);
			}
			let message = jsonrpc_ErrorUtils.errorToString(_g1,"Exception while handling request " + request.method + ": ");
			let reject1 = reject;
			let data = null;
			let this1 = { code : -32603, message : message};
			if(data != null) {
				this1.data = data;
			}
			reject1(this1);
			this.logError(message);
		}
	}
	handleNotification(notification) {
		if(notification.method == "$/cancelRequest") {
			let tokenKey = Std.string(notification.params.id);
			let tokenSource = this.requestTokens.h[tokenKey];
			if(tokenSource != null) {
				let _this = this.requestTokens;
				if(Object.prototype.hasOwnProperty.call(_this.h,tokenKey)) {
					delete(_this.h[tokenKey]);
				}
				if(!tokenSource.canceled) {
					tokenSource.canceled = true;
					if(tokenSource.callback != null) {
						tokenSource.callback();
					}
				}
			}
		} else {
			let handler = this.notificationHandlers.h[notification.method];
			if(handler == null) {
				return;
			}
			try {
				handler(notification.params);
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				let _g1 = haxe_Exception.caught(_g).unwrap();
				this.logError(jsonrpc_ErrorUtils.errorToString(_g1,"Exception while processing notification " + notification.method + ": "));
			}
		}
	}
	handleResponse(response) {
		let v = response.id;
		if(!(typeof(v) == "number" && ((v | 0) === v))) {
			this.logError("Got response with non-integer id:\n" + JSON.stringify(response,null,"    "));
			return;
		}
		let handler = this.responseCallbacks.h[response.id];
		if(handler != null) {
			this.responseCallbacks.remove(response.id);
			try {
				if(Object.prototype.hasOwnProperty.call(response,"error")) {
					if(handler.reject != null) {
						handler.reject(response.error);
					}
				} else if(handler.resolve != null) {
					handler.resolve(response.result);
				}
			} catch( _g ) {
				haxe_NativeStackTrace.lastError = _g;
				let _g1 = haxe_Exception.caught(_g).unwrap();
				this.logError(jsonrpc_ErrorUtils.errorToString(_g1,"Exception while handing response " + handler.method + ": "));
			}
		}
	}
	sendRequest(method,params,token,resolve,reject) {
		let id = this.nextRequestId++;
		let request = { jsonrpc : "2.0", id : id, method : method};
		if(params != null) {
			request.params = params;
		}
		this.responseCallbacks.h[id] = new jsonrpc__$Protocol_ResponseCallbackEntry(method,resolve,reject);
		let _gthis = this;
		if(token != null) {
			token.callback = function() {
				let params = { id : id};
				let message = { jsonrpc : "2.0", method : "$/cancelRequest"};
				if(params != null) {
					message.params = params;
				}
				_gthis.writeMessage(message,null);
				if(_gthis.didSendNotification != null) {
					_gthis.didSendNotification(message);
				}
			};
		}
		this.writeMessage(request,token);
	}
	logError(message) {
	}
}
jsonrpc_Protocol.__name__ = "jsonrpc.Protocol";
Object.assign(jsonrpc_Protocol.prototype, {
	__class__: jsonrpc_Protocol
});
class jsonrpc__$Protocol_ResponseCallbackEntry {
	constructor(method,resolve,reject) {
		this.method = method;
		this.resolve = resolve;
		this.reject = reject;
	}
}
jsonrpc__$Protocol_ResponseCallbackEntry.__name__ = "jsonrpc._Protocol.ResponseCallbackEntry";
Object.assign(jsonrpc__$Protocol_ResponseCallbackEntry.prototype, {
	__class__: jsonrpc__$Protocol_ResponseCallbackEntry
});
var jsonrpc_NoData = $hxEnums["jsonrpc.NoData"] = { __ename__:true,__constructs__:null
};
jsonrpc_NoData.__constructs__ = [];
class jsonrpc_node_MessageReader {
	constructor(readable,encoding) {
		if(encoding == null) {
			encoding = "utf-8";
		}
		this.readable = readable;
		this.buffer = new jsonrpc_node__$MessageReader_MessageBuffer(encoding);
	}
	listen(cb) {
		this.nextMessageLength = -1;
		this.callback = cb;
		this.readable.on("data",$bind(this,this.onData));
	}
	onData(data) {
		this.buffer.append(data);
		while(true) {
			if(this.nextMessageLength == -1) {
				let headers = this.buffer.tryReadHeaders();
				if(headers == null) {
					return;
				}
				let contentLength = headers.h["Content-Length"];
				if(contentLength == null) {
					throw haxe_Exception.thrown("Header must provide a Content-Length property.");
				}
				let length = Std.parseInt(contentLength);
				if(length == null) {
					throw haxe_Exception.thrown("Content-Length value must be a number.");
				}
				this.nextMessageLength = length;
			}
			let msg = this.buffer.tryReadContent(this.nextMessageLength);
			if(msg == null) {
				return;
			}
			this.nextMessageLength = -1;
			let json = JSON.parse(msg);
			this.callback(json);
		}
	}
}
jsonrpc_node_MessageReader.__name__ = "jsonrpc.node.MessageReader";
Object.assign(jsonrpc_node_MessageReader.prototype, {
	__class__: jsonrpc_node_MessageReader
});
class jsonrpc_node__$MessageReader_MessageBuffer {
	constructor(encoding) {
		if(encoding == null) {
			encoding = "utf-8";
		}
		this.encoding = encoding;
		this.index = 0;
		this.buffer = js_node_buffer_Buffer.alloc(8192);
	}
	append(chunk) {
		let toAppend;
		if(typeof(chunk) == "string") {
			let str = chunk;
			toAppend = js_node_buffer_Buffer.alloc(str.length);
			toAppend.write(str,0,str.length,this.encoding);
		} else {
			toAppend = chunk;
		}
		if(this.buffer.length - this.index >= toAppend.length) {
			toAppend.copy(this.buffer,this.index,0,toAppend.length);
		} else {
			let newSize = (Math.ceil((this.index + toAppend.length) / 8192) + 1) * 8192;
			if(this.index == 0) {
				this.buffer = js_node_buffer_Buffer.alloc(newSize);
				toAppend.copy(this.buffer,0,0,toAppend.length);
			} else {
				this.buffer = js_node_buffer_Buffer.concat([this.buffer.slice(0,this.index),toAppend],newSize);
			}
		}
		this.index += toAppend.length;
	}
	tryReadHeaders() {
		let current = 0;
		while(current + 3 < this.index && (this.buffer[current] != jsonrpc_node__$MessageReader_MessageBuffer.CR || this.buffer[current + 1] != jsonrpc_node__$MessageReader_MessageBuffer.LF || this.buffer[current + 2] != jsonrpc_node__$MessageReader_MessageBuffer.CR || this.buffer[current + 3] != jsonrpc_node__$MessageReader_MessageBuffer.LF)) ++current;
		if(current + 3 >= this.index) {
			return null;
		}
		let result = new haxe_ds_StringMap();
		let headers = this.buffer.toString("ascii",0,current).split("\r\n");
		let _g = 0;
		while(_g < headers.length) {
			let header = headers[_g];
			++_g;
			let index = header.indexOf(":");
			if(index == -1) {
				throw haxe_Exception.thrown("Message header must separate key and value using :");
			}
			result.h[HxOverrides.substr(header,0,index)] = StringTools.trim(HxOverrides.substr(header,index + 1,null));
		}
		let nextStart = current + 4;
		this.buffer = this.buffer.slice(nextStart);
		this.index -= nextStart;
		return result;
	}
	tryReadContent(length) {
		if(this.index < length) {
			return null;
		}
		let result = this.buffer.toString(this.encoding,0,length);
		this.buffer.copy(this.buffer,0,length);
		this.index -= length;
		return result;
	}
}
jsonrpc_node__$MessageReader_MessageBuffer.__name__ = "jsonrpc.node._MessageReader.MessageBuffer";
Object.assign(jsonrpc_node__$MessageReader_MessageBuffer.prototype, {
	__class__: jsonrpc_node__$MessageReader_MessageBuffer
});
class jsonrpc_node_MessageWriter {
	constructor(writable,encoding) {
		if(encoding == null) {
			encoding = "utf8";
		}
		this.writable = writable;
		this.encoding = encoding;
	}
	write(msg,_) {
		let json = JSON.stringify(msg);
		let contentLength = js_node_buffer_Buffer.byteLength(json,this.encoding);
		this.writable.write("Content-Length: ","ascii");
		this.writable.write("" + contentLength,"ascii");
		this.writable.write("\r\n");
		this.writable.write("\r\n");
		this.writable.write(json,this.encoding);
	}
}
jsonrpc_node_MessageWriter.__name__ = "jsonrpc.node.MessageWriter";
Object.assign(jsonrpc_node_MessageWriter.prototype, {
	__class__: jsonrpc_node_MessageWriter
});
var languageServerProtocol_protocol_Never = $hxEnums["languageServerProtocol.protocol.Never"] = { __ename__:true,__constructs__:null
};
languageServerProtocol_protocol_Never.__constructs__ = [];
class refactor_ITypeList {
}
refactor_ITypeList.__name__ = "refactor.ITypeList";
refactor_ITypeList.__isInterface__ = true;
Object.assign(refactor_ITypeList.prototype, {
	__class__: refactor_ITypeList
});
class refactor_PrintHelper {
	static typeToString(identType) {
		switch(identType._hx_index) {
		case 17:
			let _gisStatic = identType.isStatic;
			return "FieldVar(" + (_gisStatic == null ? "null" : "" + _gisStatic) + ")";
		case 18:
			let _gisStatic1 = identType.isStatic;
			return "Method(" + (_gisStatic1 == null ? "null" : "" + _gisStatic1) + ")";
		case 21:
			return "TypedefField(" + Std.string(identType.fields) + ")";
		case 22:
			return "StructureField(" + Std.string(identType.fieldNames) + ")";
		case 27:
			let _gparams = identType.params;
			let result = new Array(_gparams.length);
			let _g = 0;
			let _g1 = _gparams.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = "\"" + _gparams[i].name + "\"";
			}
			return "EnumField(" + Std.string(result) + ")";
		case 28:
			return "CaseLabel(" + identType.switchIdentifier.name + ")";
		case 33:
			return "ScopedLocal(" + identType.scopeStart + " - " + identType.scopeEnd + ", " + refactor_PrintHelper.scopeTypeToString(identType.scopeType) + ")";
		default:
			return "" + Std.string(identType);
		}
	}
	static scopeTypeToString(scopeType) {
		switch(scopeType._hx_index) {
		case 0:
			let _gparams = scopeType.params;
			let result = new Array(_gparams.length);
			let _g = 0;
			let _g1 = _gparams.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = "\"" + _gparams[i].name + "\"";
			}
			return "Parameter(" + Std.string(result) + ")";
		case 3:
			let _gloopIdentifiers = scopeType.loopIdentifiers;
			let result1 = new Array(_gloopIdentifiers.length);
			let _g2 = 0;
			let _g3 = _gloopIdentifiers.length;
			while(_g2 < _g3) {
				let i = _g2++;
				result1[i] = "\"" + _gloopIdentifiers[i].name + "\"";
			}
			return "ForLoop(" + Std.string(result1) + ")";
		default:
			return "" + Std.string(scopeType);
		}
	}
	static printTypeHint(hintType) {
		switch(hintType._hx_index) {
		case 0:
			let _gtypeParams = hintType.typeParams;
			let tmp = "KnownType(" + hintType.type.name.name + ", ";
			let result = new Array(_gtypeParams.length);
			let _g = 0;
			let _g1 = _gtypeParams.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = _gtypeParams[i].name;
			}
			return tmp + Std.string(result) + ")";
		case 1:
			let _gtypeParams1 = hintType.typeParams;
			let tmp1 = "UnknownType(" + hintType.name + ", ";
			let result1 = new Array(_gtypeParams1.length);
			let _g2 = 0;
			let _g3 = _gtypeParams1.length;
			while(_g2 < _g3) {
				let i = _g2++;
				result1[i] = _gtypeParams1[i].name;
			}
			return tmp1 + Std.string(result1) + ")";
		}
	}
	static printRefactorResult(result) {
		switch(result._hx_index) {
		case 0:
			return "nothing to do";
		case 1:
			return "could not find identifier to rename";
		case 2:
			return "renaming not supported for " + result.name;
		case 3:
			return "dry run - no changes were made";
		case 4:
			return "rename successful";
		}
	}
}
refactor_PrintHelper.__name__ = "refactor.PrintHelper";
class refactor_Refactor {
	static canRename(context) {
		let file = context.fileList.getFile(context.what.fileName);
		if(file == null) {
			return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.NotFound));
		}
		let identifier = file.getIdentifier(context.what.pos);
		if(identifier == null) {
			return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.NotFound));
		}
		let _g = identifier.type;
		switch(_g._hx_index) {
		case 17:
			return Promise.resolve({ name : identifier.name, pos : identifier.pos});
		case 18:
			return Promise.resolve({ name : identifier.name, pos : identifier.pos});
		case 1:case 3:case 11:case 12:case 13:case 14:case 15:case 19:case 20:case 26:case 34:
			return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
		case 21:
			return Promise.resolve({ name : identifier.name, pos : identifier.pos});
		case 22:
			return Promise.resolve({ name : identifier.name, pos : identifier.pos});
		case 0:case 2:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 16:case 23:case 24:case 25:
			return Promise.resolve({ name : identifier.name, pos : identifier.pos});
		case 27:
			return Promise.resolve({ name : identifier.name, pos : identifier.pos});
		case 28:
			return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
		case 29:
			if(_g.isNew) {
				return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
			} else {
				let candidate = refactor_Refactor.findActualWhat(context,file,identifier);
				if(candidate == null) {
					return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
				}
				if(identifier.name.startsWith(candidate.name)) {
					return Promise.resolve({ name : candidate.name, pos : { fileName : identifier.pos.fileName, start : identifier.pos.start, end : identifier.pos.start + context.what.toName.length}});
				}
				if(identifier.name.endsWith(candidate.name)) {
					return Promise.resolve({ name : candidate.name, pos : { fileName : identifier.pos.fileName, start : identifier.pos.end - context.what.toName.length, end : identifier.pos.end}});
				}
				return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
			}
			break;
		case 30:
			let candidate = refactor_Refactor.findActualWhat(context,file,identifier);
			if(candidate == null) {
				return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
			}
			if(identifier.name.startsWith(candidate.name)) {
				return Promise.resolve({ name : candidate.name, pos : { fileName : identifier.pos.fileName, start : identifier.pos.start, end : identifier.pos.start + context.what.toName.length}});
			}
			if(identifier.name.endsWith(candidate.name)) {
				return Promise.resolve({ name : candidate.name, pos : { fileName : identifier.pos.fileName, start : identifier.pos.end - context.what.toName.length, end : identifier.pos.end}});
			}
			return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
		case 31:case 32:
			let candidate1 = refactor_Refactor.findActualWhat(context,file,identifier);
			if(candidate1 == null) {
				return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
			}
			if(identifier.name.startsWith(candidate1.name)) {
				return Promise.resolve({ name : candidate1.name, pos : { fileName : identifier.pos.fileName, start : identifier.pos.start, end : identifier.pos.start + context.what.toName.length}});
			}
			if(identifier.name.endsWith(candidate1.name)) {
				return Promise.resolve({ name : candidate1.name, pos : { fileName : identifier.pos.fileName, start : identifier.pos.end - context.what.toName.length, end : identifier.pos.end}});
			}
			return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
		case 33:
			return Promise.resolve({ name : identifier.name, pos : identifier.pos});
		}
	}
	static rename(context) {
		while(true) {
			let file = context.fileList.getFile(context.what.fileName);
			if(file == null) {
				return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.NotFound));
			}
			let identifier = file.getIdentifier(context.what.pos);
			if(identifier == null) {
				return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.NotFound));
			}
			if(identifier.name == context.what.toName) {
				return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.NotFound));
			}
			let _g = identifier.type;
			switch(_g._hx_index) {
			case 0:
				context.verboseLog("rename package name \"" + identifier.name + "\" to \"" + context.what.toName + "\"",{ fileName : "refactor/Refactor.hx", lineNumber : 72, className : "refactor.Refactor", methodName : "rename"});
				return refactor_rename_RenamePackage.refactorPackageName(context,file,identifier);
			case 2:
				context.verboseLog("rename import alias \"" + identifier.name + "\" to \"" + context.what.toName + "\"",{ fileName : "refactor/Refactor.hx", lineNumber : 77, className : "refactor.Refactor", methodName : "rename"});
				return refactor_rename_RenameImportAlias.refactorImportAlias(context,file,identifier);
			case 1:case 3:
				return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
			case 4:case 5:case 6:case 7:case 8:
				context.verboseLog("rename type name \"" + identifier.name + "\" to \"" + context.what.toName + "\"",{ fileName : "refactor/Refactor.hx", lineNumber : 80, className : "refactor.Refactor", methodName : "rename"});
				return refactor_rename_RenameTypeName.refactorTypeName(context,file,identifier);
			case 9:case 10:
				context.verboseLog("rename module level static \"" + identifier.name + "\" to \"" + context.what.toName + "\"",{ fileName : "refactor/Refactor.hx", lineNumber : 83, className : "refactor.Refactor", methodName : "rename"});
				return refactor_rename_RenameModuleLevelStatic.refactorModuleLevelStatic(context,file,identifier);
			case 16:
				context.verboseLog("rename property \"" + identifier.name + "\" to \"" + context.what.toName + "\"",{ fileName : "refactor/Refactor.hx", lineNumber : 88, className : "refactor.Refactor", methodName : "rename"});
				return refactor_rename_RenameField.refactorField(context,file,identifier,false);
			case 17:
				context.verboseLog("rename field \"" + identifier.name + "\" to \"" + context.what.toName + "\"",{ fileName : "refactor/Refactor.hx", lineNumber : 91, className : "refactor.Refactor", methodName : "rename"});
				return refactor_rename_RenameField.refactorField(context,file,identifier,_g.isStatic);
			case 18:
				context.verboseLog("rename class method \"" + identifier.name + "\" to \"" + context.what.toName + "\"",{ fileName : "refactor/Refactor.hx", lineNumber : 94, className : "refactor.Refactor", methodName : "rename"});
				return refactor_rename_RenameField.refactorField(context,file,identifier,_g.isStatic);
			case 19:
				return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
			case 20:
				return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
			case 21:
				return refactor_rename_RenameAnonStructField.refactorAnonStructField(context,file,identifier,_g.fields);
			case 22:
				return refactor_rename_RenameAnonStructField.refactorStructureField(context,file,identifier,_g.fieldNames);
			case 23:case 24:case 25:
				context.verboseLog("rename interface field \"" + identifier.name + "\" to \"" + context.what.toName + "\"",{ fileName : "refactor/Refactor.hx", lineNumber : 105, className : "refactor.Refactor", methodName : "rename"});
				return refactor_rename_RenameField.refactorField(context,file,identifier,false);
			case 27:
				context.verboseLog("rename enum field \"" + identifier.name + "\" to \"" + context.what.toName + "\"",{ fileName : "refactor/Refactor.hx", lineNumber : 108, className : "refactor.Refactor", methodName : "rename"});
				return refactor_rename_RenameEnumField.refactorEnumField(context,file,identifier);
			case 28:
				return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
			case 29:
				if(_g.isNew) {
					return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
				} else {
					context.verboseLog("rename \"" + identifier.name + "\" at call/access location - trying to find definition",{ fileName : "refactor/Refactor.hx", lineNumber : 113, className : "refactor.Refactor", methodName : "rename"});
					let candidate = refactor_Refactor.findActualWhat(context,file,identifier);
					if(candidate == null) {
						return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
					}
					context.what.pos = candidate.pos.start;
					continue;
				}
				break;
			case 30:
				context.verboseLog("rename \"" + identifier.name + "\" at call/access location - trying to find definition",{ fileName : "refactor/Refactor.hx", lineNumber : 113, className : "refactor.Refactor", methodName : "rename"});
				let candidate = refactor_Refactor.findActualWhat(context,file,identifier);
				if(candidate == null) {
					return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
				}
				context.what.pos = candidate.pos.start;
				continue;
			case 31:case 32:
				context.verboseLog("rename \"" + identifier.name + "\" at call/access location - trying to find definition",{ fileName : "refactor/Refactor.hx", lineNumber : 113, className : "refactor.Refactor", methodName : "rename"});
				let candidate1 = refactor_Refactor.findActualWhat(context,file,identifier);
				if(candidate1 == null) {
					return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
				}
				context.what.pos = candidate1.pos.start;
				continue;
			case 33:
				let tmp = "rename scoped local \"" + identifier.name + "\" (" + refactor_PrintHelper.scopeTypeToString(_g.scopeType) + ") to \"" + context.what.toName + "\"";
				context.verboseLog(tmp,{ fileName : "refactor/Refactor.hx", lineNumber : 123, className : "refactor.Refactor", methodName : "rename"});
				return refactor_rename_RenameScopedLocal.refactorScopedLocal(context,file,identifier,_g.scopeStart,_g.scopeEnd);
			case 11:case 12:case 13:case 14:case 15:case 26:case 34:
				return Promise.reject(refactor_PrintHelper.printRefactorResult(refactor_RefactorResult.Unsupported(identifier.toString())));
			}
		}
	}
	static findActualWhat(context,file,identifier) {
		let parts = identifier.name.split(".");
		if(parts.length <= 0) {
			return null;
		}
		let firstPart = parts.shift();
		let onlyFields = false;
		let offset = 0;
		if(firstPart == "this") {
			firstPart = parts.shift();
			onlyFields = true;
			offset = 5;
		}
		if(context.what.pos > identifier.pos.start + firstPart.length + offset) {
			return null;
		}
		let allUses = file.findAllIdentifiers(function(i) {
			return i.name == firstPart;
		});
		let candidate = null;
		let _g = 0;
		while(_g < allUses.length) {
			let use = allUses[_g];
			++_g;
			let _g1 = use.type;
			switch(_g1._hx_index) {
			case 16:
				if(identifier.defineType.name != use.defineType.name) {
					continue;
				}
				if(candidate == null) {
					candidate = use;
				}
				break;
			case 17:
				if(identifier.defineType.name != use.defineType.name) {
					continue;
				}
				if(candidate == null) {
					candidate = use;
				}
				break;
			case 18:
				if(identifier.defineType.name != use.defineType.name) {
					continue;
				}
				if(candidate == null) {
					candidate = use;
				}
				break;
			case 33:
				let _gscopeStart = _g1.scopeStart;
				let _gscopeEnd = _g1.scopeEnd;
				if(_g1.scopeType._hx_index == 3) {
					if(!onlyFields) {
						if(_gscopeStart < identifier.pos.start && identifier.pos.start < _gscopeEnd) {
							candidate = use;
						}
					} else if(!onlyFields) {
						if(_gscopeStart < identifier.pos.start && identifier.pos.start < _gscopeEnd) {
							candidate = use;
						}
					}
				} else if(!onlyFields) {
					if(_gscopeStart < identifier.pos.start && identifier.pos.start < _gscopeEnd) {
						candidate = use;
					}
				}
				break;
			default:
			}
		}
		return candidate;
	}
}
refactor_Refactor.__name__ = "refactor.Refactor";
var refactor_RefactorResult = $hxEnums["refactor.RefactorResult"] = { __ename__:true,__constructs__:null
	,NoChange: {_hx_name:"NoChange",_hx_index:0,__enum__:"refactor.RefactorResult",toString:$estr}
	,NotFound: {_hx_name:"NotFound",_hx_index:1,__enum__:"refactor.RefactorResult",toString:$estr}
	,Unsupported: ($_=function(name) { return {_hx_index:2,name:name,__enum__:"refactor.RefactorResult",toString:$estr}; },$_._hx_name="Unsupported",$_.__params__ = ["name"],$_)
	,DryRun: {_hx_name:"DryRun",_hx_index:3,__enum__:"refactor.RefactorResult",toString:$estr}
	,Done: {_hx_name:"Done",_hx_index:4,__enum__:"refactor.RefactorResult",toString:$estr}
};
refactor_RefactorResult.__constructs__ = [refactor_RefactorResult.NoChange,refactor_RefactorResult.NotFound,refactor_RefactorResult.Unsupported,refactor_RefactorResult.DryRun,refactor_RefactorResult.Done];
class refactor_cache_IFileCache {
}
refactor_cache_IFileCache.__name__ = "refactor.cache.IFileCache";
refactor_cache_IFileCache.__isInterface__ = true;
Object.assign(refactor_cache_IFileCache.prototype, {
	__class__: refactor_cache_IFileCache
});
class refactor_cache_MemCache {
	constructor() {
		this.clear();
	}
	clear() {
		this.files = new haxe_ds_StringMap();
	}
	storeFile(file) {
		this.files.h[file.name] = file;
	}
	getFile(name,nameMap) {
		let file = this.files.h[name];
		if(file == null) {
			return null;
		}
		let stat = js_node_Fs.statSync(name);
		if(file.fileDate != stat.mtime.getTime() || file.fileSize != stat.size) {
			let _this = this.files;
			if(Object.prototype.hasOwnProperty.call(_this.h,name)) {
				delete(_this.h[name]);
			}
			return null;
		}
		if(file.packageIdentifier != null) {
			nameMap.addIdentifier(file.packageIdentifier);
		}
		let _g = 0;
		let _g1 = file.importList;
		while(_g < _g1.length) {
			let i = _g1[_g];
			++_g;
			nameMap.addIdentifier(i.moduleName);
			if(i.alias != null) {
				nameMap.addIdentifier(i.alias);
			}
		}
		let _g2 = 0;
		let _g3 = file.typeList;
		while(_g2 < _g3.length) {
			let type = _g3[_g2];
			++_g2;
			nameMap.addIdentifier(type.name);
			let _g = 0;
			let _g1 = type.uses;
			while(_g < _g1.length) nameMap.addIdentifier(_g1[_g++]);
		}
		return file;
	}
}
refactor_cache_MemCache.__name__ = "refactor.cache.MemCache";
refactor_cache_MemCache.__interfaces__ = [refactor_cache_IFileCache];
Object.assign(refactor_cache_MemCache.prototype, {
	__class__: refactor_cache_MemCache
});
class refactor_discover_File {
	constructor(name) {
		this.name = name;
		let stat = js_node_Fs.statSync(name);
		this.fileDate = stat.mtime.getTime();
		this.fileSize = stat.size;
	}
	init(packageIdent,imports,types,posForImport) {
		this.packageIdentifier = packageIdent;
		this.importList = imports;
		this.typeList = types;
		this.importInsertPos = posForImport;
	}
	getPackage() {
		if(this.packageIdentifier != null) {
			return this.packageIdentifier.name;
		}
		return "";
	}
	importsModule(packName,moduleName,typeName) {
		if(packName.length <= 0) {
			return refactor_discover_ImportStatus.Global;
		}
		let fullModule = "" + packName + "." + moduleName;
		let fullSubModule = null;
		let isMainModule = true;
		if(moduleName != typeName) {
			fullSubModule = "" + fullModule + "." + typeName;
			isMainModule = false;
		}
		let _g = 0;
		let _g1 = this.importList;
		while(_g < _g1.length) {
			let importEntry = _g1[_g];
			++_g;
			if(importEntry.moduleName.name == fullModule) {
				if(importEntry.alias != null) {
					return refactor_discover_ImportStatus.ImportedWithAlias(importEntry.alias.name);
				}
				return refactor_discover_ImportStatus.Imported;
			}
			if(importEntry.moduleName.name == fullSubModule) {
				if(importEntry.alias != null) {
					return refactor_discover_ImportStatus.ImportedWithAlias(importEntry.alias.name);
				}
				return refactor_discover_ImportStatus.Imported;
			}
			if(isMainModule && importEntry.starImport) {
				if(importEntry.moduleName.name == packName) {
					return refactor_discover_ImportStatus.StarImported;
				}
			}
		}
		if(this.importHxFile == null) {
			if(packName == this.getPackage()) {
				return refactor_discover_ImportStatus.SamePackage;
			}
			if(packName == this.getPackage()) {
				return refactor_discover_ImportStatus.SamePackage;
			}
			return refactor_discover_ImportStatus.None;
		}
		let result = this.importHxFile.importsModule(packName,moduleName,typeName);
		if(result == refactor_discover_ImportStatus.None) {
			if(packName == this.getPackage()) {
				return refactor_discover_ImportStatus.SamePackage;
			}
		}
		return result;
	}
	getMainModulName() {
		return new haxe_io_Path(this.name).file;
	}
	getIdentifier(pos) {
		if(this.packageIdentifier != null && this.packageIdentifier.containsPos(pos)) {
			return this.packageIdentifier;
		}
		let _g = 0;
		let _g1 = this.importList;
		while(_g < _g1.length) {
			let imp = _g1[_g];
			++_g;
			if(imp.alias != null && imp.alias.containsPos(pos)) {
				return imp.alias;
			}
			if(imp.moduleName.containsPos(pos)) {
				return imp.moduleName;
			}
		}
		let _g2 = 0;
		let _g3 = this.typeList;
		while(_g2 < _g3.length) {
			let identifier = _g3[_g2++].findIdentifier(pos);
			if(identifier != null) {
				return identifier;
			}
		}
		return null;
	}
	findAllIdentifiers(matcher) {
		let results = [];
		if(this.packageIdentifier != null && matcher(this.packageIdentifier)) {
			results.push(this.packageIdentifier);
		}
		let _g = 0;
		let _g1 = this.importList;
		while(_g < _g1.length) {
			let imp = _g1[_g];
			++_g;
			if(imp.alias != null && matcher(imp.alias)) {
				results.push(imp.alias);
			}
			if(matcher(imp.moduleName)) {
				results.push(imp.moduleName);
			}
		}
		let _g2 = 0;
		let _g3 = this.typeList;
		while(_g2 < _g3.length) results = results.concat(_g3[_g2++].findAllIdentifiers(matcher));
		results.sort(refactor_discover_Identifier.sortIdentifier);
		return results;
	}
}
refactor_discover_File.__name__ = "refactor.discover.File";
Object.assign(refactor_discover_File.prototype, {
	__class__: refactor_discover_File
});
var refactor_discover_ImportStatus = $hxEnums["refactor.discover.ImportStatus"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"refactor.discover.ImportStatus",toString:$estr}
	,Global: {_hx_name:"Global",_hx_index:1,__enum__:"refactor.discover.ImportStatus",toString:$estr}
	,SamePackage: {_hx_name:"SamePackage",_hx_index:2,__enum__:"refactor.discover.ImportStatus",toString:$estr}
	,Imported: {_hx_name:"Imported",_hx_index:3,__enum__:"refactor.discover.ImportStatus",toString:$estr}
	,ImportedWithAlias: ($_=function(alias) { return {_hx_index:4,alias:alias,__enum__:"refactor.discover.ImportStatus",toString:$estr}; },$_._hx_name="ImportedWithAlias",$_.__params__ = ["alias"],$_)
	,StarImported: {_hx_name:"StarImported",_hx_index:5,__enum__:"refactor.discover.ImportStatus",toString:$estr}
};
refactor_discover_ImportStatus.__constructs__ = [refactor_discover_ImportStatus.None,refactor_discover_ImportStatus.Global,refactor_discover_ImportStatus.SamePackage,refactor_discover_ImportStatus.Imported,refactor_discover_ImportStatus.ImportedWithAlias,refactor_discover_ImportStatus.StarImported];
class refactor_discover_FileList {
	constructor() {
		this.files = [];
	}
	addFile(file) {
		this.files.push(file);
	}
	getFile(fileName) {
		let _g = 0;
		let _g1 = this.files;
		while(_g < _g1.length) {
			let file = _g1[_g];
			++_g;
			if(file.name == fileName) {
				return file;
			}
		}
		return null;
	}
}
refactor_discover_FileList.__name__ = "refactor.discover.FileList";
Object.assign(refactor_discover_FileList.prototype, {
	__class__: refactor_discover_FileList
});
class refactor_discover_Identifier {
	constructor(type,name,pos,nameMap,file,defineType) {
		this.type = type;
		this.name = name;
		this.pos = pos;
		this.file = file;
		this.defineType = defineType;
		this.parent = null;
		this.edited = false;
		if(defineType != null) {
			defineType.addIdentifier(this);
		}
		nameMap.addIdentifier(this);
	}
	reset() {
		this.edited = false;
	}
	addUse(identifier) {
		if(identifier == null) {
			return;
		}
		if(this.uses == null) {
			this.uses = [];
		}
		this.uses.push(identifier);
		identifier.parent = this;
	}
	containsPos(offset) {
		if(this.pos.start <= offset) {
			return this.pos.end >= offset;
		} else {
			return false;
		}
	}
	findIdentifier(offset) {
		if(this.containsPos(offset)) {
			return this;
		}
		if(this.uses == null) {
			return null;
		}
		let _g = 0;
		let _g1 = this.uses;
		while(_g < _g1.length) {
			let identifier = _g1[_g++].findIdentifier(offset);
			if(identifier != null) {
				return identifier;
			}
		}
		return null;
	}
	getTypeHint() {
		if(this.uses == null) {
			return null;
		}
		let _g = 0;
		let _g1 = this.uses;
		while(_g < _g1.length) {
			let use = _g1[_g];
			++_g;
			if(use.type._hx_index == 26) {
				return use;
			}
		}
		return null;
	}
	toString() {
		return "" + this.name + " " + this.pos.fileName + "@" + this.pos.start + "-" + this.pos.end + " (" + refactor_PrintHelper.typeToString(this.type) + ")";
	}
	static sortIdentifier(a,b) {
		if(a.pos.fileName < b.pos.fileName) {
			return -1;
		}
		if(a.pos.fileName > b.pos.fileName) {
			return 1;
		}
		if(a.pos.start < b.pos.start) {
			return -1;
		}
		if(a.pos.start > b.pos.start) {
			return 1;
		}
		return 0;
	}
}
refactor_discover_Identifier.__name__ = "refactor.discover.Identifier";
Object.assign(refactor_discover_Identifier.prototype, {
	__class__: refactor_discover_Identifier
});
var refactor_discover_IdentifierType = $hxEnums["refactor.discover.IdentifierType"] = { __ename__:true,__constructs__:null
	,PackageName: {_hx_name:"PackageName",_hx_index:0,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,ImportModul: {_hx_name:"ImportModul",_hx_index:1,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,ImportAlias: {_hx_name:"ImportAlias",_hx_index:2,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,UsingModul: {_hx_name:"UsingModul",_hx_index:3,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,Abstract: {_hx_name:"Abstract",_hx_index:4,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,Class: {_hx_name:"Class",_hx_index:5,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,Enum: {_hx_name:"Enum",_hx_index:6,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,Interface: {_hx_name:"Interface",_hx_index:7,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,Typedef: {_hx_name:"Typedef",_hx_index:8,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,ModuleLevelStaticVar: {_hx_name:"ModuleLevelStaticVar",_hx_index:9,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,ModuleLevelStaticMethod: {_hx_name:"ModuleLevelStaticMethod",_hx_index:10,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,Extends: {_hx_name:"Extends",_hx_index:11,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,Implements: {_hx_name:"Implements",_hx_index:12,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,AbstractOver: {_hx_name:"AbstractOver",_hx_index:13,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,AbstractFrom: {_hx_name:"AbstractFrom",_hx_index:14,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,AbstractTo: {_hx_name:"AbstractTo",_hx_index:15,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,Property: {_hx_name:"Property",_hx_index:16,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,FieldVar: ($_=function(isStatic) { return {_hx_index:17,isStatic:isStatic,__enum__:"refactor.discover.IdentifierType",toString:$estr}; },$_._hx_name="FieldVar",$_.__params__ = ["isStatic"],$_)
	,Method: ($_=function(isStatic) { return {_hx_index:18,isStatic:isStatic,__enum__:"refactor.discover.IdentifierType",toString:$estr}; },$_._hx_name="Method",$_.__params__ = ["isStatic"],$_)
	,TypedParameter: {_hx_name:"TypedParameter",_hx_index:19,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,TypedefBase: {_hx_name:"TypedefBase",_hx_index:20,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,TypedefField: ($_=function(fields) { return {_hx_index:21,fields:fields,__enum__:"refactor.discover.IdentifierType",toString:$estr}; },$_._hx_name="TypedefField",$_.__params__ = ["fields"],$_)
	,StructureField: ($_=function(fieldNames) { return {_hx_index:22,fieldNames:fieldNames,__enum__:"refactor.discover.IdentifierType",toString:$estr}; },$_._hx_name="StructureField",$_.__params__ = ["fieldNames"],$_)
	,InterfaceProperty: {_hx_name:"InterfaceProperty",_hx_index:23,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,InterfaceVar: {_hx_name:"InterfaceVar",_hx_index:24,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,InterfaceMethod: {_hx_name:"InterfaceMethod",_hx_index:25,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,TypeHint: {_hx_name:"TypeHint",_hx_index:26,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,EnumField: ($_=function(params) { return {_hx_index:27,params:params,__enum__:"refactor.discover.IdentifierType",toString:$estr}; },$_._hx_name="EnumField",$_.__params__ = ["params"],$_)
	,CaseLabel: ($_=function(switchIdentifier) { return {_hx_index:28,switchIdentifier:switchIdentifier,__enum__:"refactor.discover.IdentifierType",toString:$estr}; },$_._hx_name="CaseLabel",$_.__params__ = ["switchIdentifier"],$_)
	,Call: ($_=function(isNew) { return {_hx_index:29,isNew:isNew,__enum__:"refactor.discover.IdentifierType",toString:$estr}; },$_._hx_name="Call",$_.__params__ = ["isNew"],$_)
	,ArrayAccess: ($_=function(posClosing) { return {_hx_index:30,posClosing:posClosing,__enum__:"refactor.discover.IdentifierType",toString:$estr}; },$_._hx_name="ArrayAccess",$_.__params__ = ["posClosing"],$_)
	,Access: {_hx_name:"Access",_hx_index:31,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,ForIterator: {_hx_name:"ForIterator",_hx_index:32,__enum__:"refactor.discover.IdentifierType",toString:$estr}
	,ScopedLocal: ($_=function(scopeStart,scopeEnd,scopeType) { return {_hx_index:33,scopeStart:scopeStart,scopeEnd:scopeEnd,scopeType:scopeType,__enum__:"refactor.discover.IdentifierType",toString:$estr}; },$_._hx_name="ScopedLocal",$_.__params__ = ["scopeStart","scopeEnd","scopeType"],$_)
	,StringConst: {_hx_name:"StringConst",_hx_index:34,__enum__:"refactor.discover.IdentifierType",toString:$estr}
};
refactor_discover_IdentifierType.__constructs__ = [refactor_discover_IdentifierType.PackageName,refactor_discover_IdentifierType.ImportModul,refactor_discover_IdentifierType.ImportAlias,refactor_discover_IdentifierType.UsingModul,refactor_discover_IdentifierType.Abstract,refactor_discover_IdentifierType.Class,refactor_discover_IdentifierType.Enum,refactor_discover_IdentifierType.Interface,refactor_discover_IdentifierType.Typedef,refactor_discover_IdentifierType.ModuleLevelStaticVar,refactor_discover_IdentifierType.ModuleLevelStaticMethod,refactor_discover_IdentifierType.Extends,refactor_discover_IdentifierType.Implements,refactor_discover_IdentifierType.AbstractOver,refactor_discover_IdentifierType.AbstractFrom,refactor_discover_IdentifierType.AbstractTo,refactor_discover_IdentifierType.Property,refactor_discover_IdentifierType.FieldVar,refactor_discover_IdentifierType.Method,refactor_discover_IdentifierType.TypedParameter,refactor_discover_IdentifierType.TypedefBase,refactor_discover_IdentifierType.TypedefField,refactor_discover_IdentifierType.StructureField,refactor_discover_IdentifierType.InterfaceProperty,refactor_discover_IdentifierType.InterfaceVar,refactor_discover_IdentifierType.InterfaceMethod,refactor_discover_IdentifierType.TypeHint,refactor_discover_IdentifierType.EnumField,refactor_discover_IdentifierType.CaseLabel,refactor_discover_IdentifierType.Call,refactor_discover_IdentifierType.ArrayAccess,refactor_discover_IdentifierType.Access,refactor_discover_IdentifierType.ForIterator,refactor_discover_IdentifierType.ScopedLocal,refactor_discover_IdentifierType.StringConst];
var refactor_discover_ScopedLocalType = $hxEnums["refactor.discover.ScopedLocalType"] = { __ename__:true,__constructs__:null
	,Parameter: ($_=function(params) { return {_hx_index:0,params:params,__enum__:"refactor.discover.ScopedLocalType",toString:$estr}; },$_._hx_name="Parameter",$_.__params__ = ["params"],$_)
	,Var: {_hx_name:"Var",_hx_index:1,__enum__:"refactor.discover.ScopedLocalType",toString:$estr}
	,CaseCapture: {_hx_name:"CaseCapture",_hx_index:2,__enum__:"refactor.discover.ScopedLocalType",toString:$estr}
	,ForLoop: ($_=function(loopIdentifiers) { return {_hx_index:3,loopIdentifiers:loopIdentifiers,__enum__:"refactor.discover.ScopedLocalType",toString:$estr}; },$_._hx_name="ForLoop",$_.__params__ = ["loopIdentifiers"],$_)
};
refactor_discover_ScopedLocalType.__constructs__ = [refactor_discover_ScopedLocalType.Parameter,refactor_discover_ScopedLocalType.Var,refactor_discover_ScopedLocalType.CaseCapture,refactor_discover_ScopedLocalType.ForLoop];
var refactor_discover_TypedefFieldType = $hxEnums["refactor.discover.TypedefFieldType"] = { __ename__:true,__constructs__:null
	,Required: ($_=function(identifier) { return {_hx_index:0,identifier:identifier,__enum__:"refactor.discover.TypedefFieldType",toString:$estr}; },$_._hx_name="Required",$_.__params__ = ["identifier"],$_)
	,Optional: ($_=function(identifier) { return {_hx_index:1,identifier:identifier,__enum__:"refactor.discover.TypedefFieldType",toString:$estr}; },$_._hx_name="Optional",$_.__params__ = ["identifier"],$_)
};
refactor_discover_TypedefFieldType.__constructs__ = [refactor_discover_TypedefFieldType.Required,refactor_discover_TypedefFieldType.Optional];
class refactor_discover_NameMap {
	constructor() {
		this.names = new haxe_ds_StringMap();
		this.parts = new haxe_ds_StringMap();
	}
	getIdentifiers(name) {
		let results = this.names.h[name];
		if(results == null) {
			return [];
		}
		results.sort(refactor_discover_Identifier.sortIdentifier);
		return results;
	}
	addIdentifier(identifier) {
		let addToMap = function(map,key) {
			let list = map.h[key];
			if(list == null) {
				map.h[key] = [identifier];
			} else {
				list.push(identifier);
			}
		};
		identifier.reset();
		addToMap(this.names,identifier.name);
		let nameParts = identifier.name.split(".");
		let _g = 0;
		while(_g < nameParts.length) addToMap(this.parts,nameParts[_g++]);
	}
	getStartsWith(prefix) {
		let results = [];
		let h = this.names.h;
		let _g_keys = Object.keys(h);
		let _g_length = _g_keys.length;
		let _g_current = 0;
		while(_g_current < _g_length) {
			let key = _g_keys[_g_current++];
			let _g_value = h[key];
			if(key.startsWith(prefix)) {
				results = results.concat(_g_value);
			}
		}
		results.sort(refactor_discover_Identifier.sortIdentifier);
		return results;
	}
	matchIdentifierPart(name,unused) {
		let results = this.parts.h[name];
		if(results == null) {
			return [];
		}
		if(unused) {
			let _g = [];
			let _g1 = 0;
			let _g2 = results;
			while(_g1 < _g2.length) {
				let v = _g2[_g1];
				++_g1;
				if(!v.edited) {
					_g.push(v);
				}
			}
			results = _g;
			_g.sort(refactor_discover_Identifier.sortIdentifier);
		}
		return results;
	}
}
refactor_discover_NameMap.__name__ = "refactor.discover.NameMap";
Object.assign(refactor_discover_NameMap.prototype, {
	__class__: refactor_discover_NameMap
});
class refactor_discover_TraverseSources {
	static traverseSources(paths,usageContext) {
		let _g = 0;
		while(_g < paths.length) {
			let path = StringTools.trim(paths[_g++]);
			if(!sys_FileSystem.exists(path)) {
				continue;
			}
			if(sys_FileSystem.isDirectory(path)) {
				let _g = [];
				let _g1 = 0;
				let _g2 = js_node_Fs.readdirSync(path);
				while(_g1 < _g2.length) _g.push(haxe_io_Path.join([path,_g2[_g1++]]));
				refactor_discover_TraverseSources.traverseSources(_g,usageContext);
			} else if(path.endsWith(".hx")) {
				usageContext.fileName = path;
				refactor_discover_TraverseSources.collectIdentifierData(usageContext);
			}
		}
	}
	static collectIdentifierData(usageContext) {
		let content = js_node_Fs.readFileSync(usageContext.fileName,{ encoding : "utf8"});
		usageContext.usageCollector.parseFile(haxe_io_Bytes.ofString(content),usageContext);
	}
}
refactor_discover_TraverseSources.__name__ = "refactor.discover.TraverseSources";
class refactor_discover_Type {
	constructor(file) {
		this.file = file;
		this.nameMap = new refactor_discover_NameMap();
		this.uses = [];
	}
	getFullModulName() {
		let modulName = "" + this.file.getMainModulName() + ".";
		if(this.file.getMainModulName() == this.name.name) {
			modulName = "";
		}
		let packageName = this.file.getPackage();
		if(packageName.length <= 0) {
			return modulName + this.name.name;
		}
		return "" + packageName + "." + modulName + this.name.name;
	}
	addIdentifier(identifier) {
		this.nameMap.addIdentifier(identifier);
		this.uses.push(identifier);
	}
	getIdentifiers(search) {
		return this.nameMap.getIdentifiers(search);
	}
	findIdentifier(offset) {
		let identifier = this.name.findIdentifier(offset);
		if(identifier != null) {
			return identifier;
		}
		let _g = 0;
		let _g1 = this.uses;
		while(_g < _g1.length) {
			identifier = _g1[_g++].findIdentifier(offset);
			if(identifier != null) {
				return identifier;
			}
		}
		return null;
	}
	findAllIdentifiers(matcher) {
		let results = [];
		if(matcher(this.name)) {
			results = [this.name];
		}
		let _g = 0;
		let _g1 = this.uses;
		while(_g < _g1.length) {
			let use = _g1[_g];
			++_g;
			if(matcher(use)) {
				results.push(use);
			}
		}
		results.sort(refactor_discover_Identifier.sortIdentifier);
		return results;
	}
	getStartsWith(prefix) {
		return this.nameMap.getStartsWith(prefix);
	}
}
refactor_discover_Type.__name__ = "refactor.discover.Type";
Object.assign(refactor_discover_Type.prototype, {
	__class__: refactor_discover_Type
});
class refactor_discover_TypeList {
	constructor() {
		this.types = [];
	}
	addType(type) {
		this.types.push(type);
	}
	findTypeName(name) {
		let _this = this.types;
		let _g = [];
		let _g1 = 0;
		while(_g1 < _this.length) {
			let v = _this[_g1];
			++_g1;
			if(v.name.name == name) {
				_g.push(v);
			}
		}
		return _g;
	}
	makeTypeHintType(name) {
		let _g = 0;
		let _g1 = this.types;
		while(_g < _g1.length) {
			let type = _g1[_g];
			++_g;
			if(type.getFullModulName() == name) {
				return refactor_rename_TypeHintType.KnownType(type,[]);
			}
		}
		return null;
	}
}
refactor_discover_TypeList.__name__ = "refactor.discover.TypeList";
refactor_discover_TypeList.__interfaces__ = [refactor_ITypeList];
Object.assign(refactor_discover_TypeList.prototype, {
	__class__: refactor_discover_TypeList
});
class refactor_discover_UsageCollector {
	constructor() {
	}
	parseFile(content,context) {
		if(this.isCached(context)) {
			return;
		}
		let root = null;
		try {
			let lexer = new haxeparser_HaxeLexer(content,context.fileName);
			let t = lexer.token(haxeparser_HaxeLexer.tok);
			let tokens = [];
			while(t.tok != haxeparser_TokenDef.Eof) {
				tokens.push(t);
				t = lexer.token(haxeparser_HaxeLexer.tok);
			}
			root = tokentree_TokenTreeBuilder.buildTokenTree(tokens,content,tokentree_TokenTreeEntryPoint.TypeLevel);
			this.parseFileWithTokens(root,context);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g);
			let _g2 = _g1.unwrap();
			if(((_g2) instanceof hxparse_ParserError)) {
				let e = _g2;
				throw haxe_Exception.thrown("failed to parse " + context.fileName + " - ParserError: " + Std.string(e) + " (" + Std.string(e.pos) + ")");
			} else if(((_g2) instanceof haxeparser_LexerError)) {
				let e = _g2;
				throw haxe_Exception.thrown("failed to parse " + context.fileName + " - LexerError: " + Std.string(e.msg) + " (" + Std.string(e.pos) + ")");
			} else {
				throw haxe_Exception.thrown("failed to parse " + context.fileName + " - " + _g1.details());
			}
		}
	}
	parseFileWithTokens(root,context) {
		if(this.isCached(context)) {
			return;
		}
		try {
			let file = new refactor_discover_File(context.fileName);
			context.file = file;
			context.type = null;
			file.init(this.readPackageName(root,context),this.readImports(root,context),this.readTypes(root,context),this.findImportInsertPos(root));
			context.fileList.addFile(file);
			if(context.cache != null) {
				context.cache.storeFile(file);
			}
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g);
			throw haxe_Exception.thrown("failed to parse " + context.fileName + " - " + _g1.details());
		}
	}
	isCached(context) {
		if(context.cache != null) {
			let file = context.cache.getFile(context.fileName,context.nameMap);
			if(file == null) {
				return false;
			}
			context.fileList.addFile(file);
			let _g = 0;
			let _g1 = file.typeList;
			while(_g < _g1.length) context.typeList.addType(_g1[_g++]);
			return true;
		}
		return false;
	}
	updateImportHx(context) {
		let _g = 0;
		let _g1 = context.fileList.files;
		while(_g < _g1.length) {
			let importHxFile = _g1[_g];
			++_g;
			let importHxPath = new haxe_io_Path(importHxFile.name);
			if(importHxPath.file != "import") {
				continue;
			}
			let importHxFolder = importHxPath.dir;
			let _g2 = 0;
			let _g3 = context.fileList.files;
			while(_g2 < _g3.length) {
				let file = _g3[_g2];
				++_g2;
				if(file.name == importHxFile.name) {
					continue;
				}
				if(!new haxe_io_Path(file.name).dir.startsWith(importHxFolder)) {
					continue;
				}
				file.importHxFile = importHxFile;
			}
		}
	}
	findImportInsertPos(root) {
		if(!root.hasChildren()) {
			return 0;
		}
		let pos = 0;
		let _g = 0;
		let _g1 = root.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			if(_g2._hx_index == 1) {
				switch(_g2.k._hx_index) {
				case 34:
					pos = child.getPos().max + 1;
					break;
				case 13:case 36:
					return child.pos.min;
				default:
					return child.pos.min;
				}
			} else {
				return child.pos.min;
			}
		}
		return pos;
	}
	readPackageName(root,context) {
		let packages = root.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 34) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.SkipSubtree;
			}
		});
		if(packages.length != 1) {
			return null;
		}
		return this.makeIdentifier(context,packages[0].getFirstChild(),refactor_discover_IdentifierType.PackageName,null);
	}
	readImports(root,context) {
		let imports = [];
		let importTokens = root.filterCallback(function(token,index) {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 13:case 36:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.SkipSubtree;
				}
				break;
			case 3:
				return tokentree_FilterResult.GoDeeper;
			default:
				return tokentree_FilterResult.SkipSubtree;
			}
		});
		let _g = 0;
		while(_g < importTokens.length) imports.push(this.readImport(importTokens[_g++],context));
		return imports;
	}
	readImport(token,context) {
		let pack = [];
		let alias = null;
		let type;
		let _g = token.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 13:
				type = refactor_discover_IdentifierType.ImportModul;
				break;
			case 36:
				type = refactor_discover_IdentifierType.UsingModul;
				break;
			default:
				type = null;
			}
		} else {
			type = null;
		}
		if(type == null) {
			return null;
		}
		let starImport = false;
		token = token.getFirstChild();
		let pos = this.makePosition(context.fileName,token);
		_hx_loop1: while(true) {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				pack.push(token.toString());
				pos.end = token.pos.max;
				break;
			case 2:
				let _gc = _g.c;
				if(_gc._hx_index == 3) {
					if(_gc.s == "as") {
						alias = this.makeIdentifier(context,token.getFirstChild(),refactor_discover_IdentifierType.ImportAlias,null);
						break _hx_loop1;
					} else {
						pack.push(token.toString());
						pos.end = token.pos.max;
					}
				} else {
					return null;
				}
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 1:
					starImport = true;
					break;
				case 23:
					alias = this.makeIdentifier(context,token.getFirstChild(),refactor_discover_IdentifierType.ImportAlias,null);
					break _hx_loop1;
				default:
					return null;
				}
				break;
			case 10:
				break _hx_loop1;
			case 11:
				break;
			default:
				return null;
			}
			token = token.getFirstChild();
		}
		let importIdentifier = new refactor_discover_Identifier(type,pack.join("."),pos,context.nameMap,context.file,null);
		if(alias != null) {
			importIdentifier.addUse(alias.parent);
		}
		return { moduleName : importIdentifier, alias : alias, starImport : starImport};
	}
	readTypes(root,context) {
		let typeTokens = root.filterCallback(function(token,index) {
			let _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 1:case 2:case 26:case 28:case 32:case 40:case 42:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.SkipSubtree;
				}
				break;
			case 3:
				return tokentree_FilterResult.GoDeeper;
			default:
				return tokentree_FilterResult.SkipSubtree;
			}
		});
		let types = [];
		let _g = 0;
		while(_g < typeTokens.length) types.push(this.readType(typeTokens[_g++],context));
		return types;
	}
	readType(token,context) {
		let type;
		let _g = token.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 0:
				type = refactor_discover_IdentifierType.ModuleLevelStaticMethod;
				break;
			case 1:
				type = refactor_discover_IdentifierType.Class;
				break;
			case 26:
				type = refactor_discover_IdentifierType.Enum;
				break;
			case 28:
				type = refactor_discover_IdentifierType.Interface;
				break;
			case 32:
				type = refactor_discover_IdentifierType.Typedef;
				break;
			case 40:
				type = refactor_discover_IdentifierType.Abstract;
				break;
			case 2:case 42:
				type = refactor_discover_IdentifierType.ModuleLevelStaticVar;
				break;
			default:
				type = null;
			}
		} else {
			type = null;
		}
		if(type == null) {
			return null;
		}
		let nameToken = token.getFirstChild();
		let newType = new refactor_discover_Type(context.file);
		context.type = newType;
		let identifier = this.makeIdentifier(context,nameToken,type,null);
		newType.name = identifier;
		context.typeList.addType(newType);
		switch(type._hx_index) {
		case 4:
			this.addAbstractFields(context,identifier,nameToken);
			break;
		case 5:
			this.addFields(context,identifier,nameToken);
			break;
		case 6:
			this.readEnum(context,identifier,nameToken.getFirstChild());
			break;
		case 7:
			this.addFields(context,identifier,nameToken);
			if(identifier.uses != null) {
				let _g = 0;
				let _g1 = identifier.uses;
				while(_g < _g1.length) {
					let use = _g1[_g];
					++_g;
					switch(use.type._hx_index) {
					case 16:
						use.type = refactor_discover_IdentifierType.InterfaceProperty;
						break;
					case 17:
						use.type = refactor_discover_IdentifierType.InterfaceVar;
						break;
					case 18:
						use.type = refactor_discover_IdentifierType.InterfaceMethod;
						break;
					default:
					}
				}
			}
			break;
		case 8:
			this.readTypedef(context,identifier,nameToken);
			break;
		case 9:
			this.readVarInit(context,identifier,nameToken);
			break;
		case 10:
			this.readMethod(context,identifier,nameToken);
			break;
		default:
		}
		this.readStrings(context,identifier,nameToken);
		return newType;
	}
	readStrings(context,identifier,token) {
		let _gthis = this;
		token.filterCallback(function(token,index) {
			let _g = token.tok;
			if(_g._hx_index == 2) {
				let _gc = _g.c;
				if(_gc._hx_index == 2) {
					let _gs = _gc.s;
					let _gkind = _gc.kind;
					if(_gkind == null) {
						return tokentree_FilterResult.GoDeeper;
					} else {
						switch(_gkind._hx_index) {
						case 0:
							if(new EReg("^[a-z][a-zA-Z0-9]+(\\.[a-z][a-zA-Z0-9]+)*(|\\.[A-Z][a-zA-Z0-9]+)$","").match(_gs)) {
								identifier.addUse(new refactor_discover_Identifier(refactor_discover_IdentifierType.StringConst,_gs,{ fileName : context.fileName, start : token.pos.min + 1, end : token.pos.max - 1},context.nameMap,context.file,context.type));
							}
							return tokentree_FilterResult.SkipSubtree;
						case 1:
							_gthis.readStringInterpolation(context,identifier,token,_gs);
							return tokentree_FilterResult.SkipSubtree;
						}
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
	}
	readStringInterpolation(context,identifier,token,text) {
		let start = 0;
		let index;
		while(true) {
			index = text.indexOf("${",start);
			if(!(index >= 0)) {
				break;
			}
			if(this.isDollarEscaped(text,index)) {
				start = index + 1;
				continue;
			}
			start = index + 1;
			let indexEnd = text.indexOf("}",index + 2);
			let fragment = text.substring(index + 2,indexEnd);
			if(fragment.indexOf("{") >= 0) {
				continue;
			}
			this.readInterpolatedFragment(context,identifier,fragment,token.pos.min + 1 + start + 1);
			start = indexEnd;
		}
		start = 0;
		let nameRegEx = new EReg("^[a-z][a-zA-Z0-9]*","");
		while(true) {
			index = text.indexOf("$",start);
			if(!(index >= 0)) {
				break;
			}
			if(index + 1 >= text.length) {
				break;
			}
			start = index + 1;
			if(nameRegEx.match(HxOverrides.substr(text,start,null))) {
				let matchedText = nameRegEx.matched(0);
				identifier.addUse(new refactor_discover_Identifier(refactor_discover_IdentifierType.Access,matchedText,{ fileName : token.pos.file, start : token.pos.min + start + 1, end : token.pos.min + start + matchedText.length + 1},context.nameMap,context.file,context.type));
			}
		}
	}
	isDollarEscaped(text,index) {
		let escaped = false;
		while(--index >= 0) {
			if(text.charCodeAt(index) != 36) {
				return escaped;
			}
			escaped = !escaped;
		}
		return escaped;
	}
	readInterpolatedFragment(context,identifier,text,offset) {
		let root = null;
		try {
			let content = haxe_io_Bytes.ofString(text);
			let lexer = new haxeparser_HaxeLexer(content,context.fileName);
			let t = lexer.token(haxeparser_HaxeLexer.tok);
			let tokens = [];
			while(t.tok != haxeparser_TokenDef.Eof) {
				t.pos.min += offset;
				t.pos.max += offset;
				tokens.push(t);
				t = lexer.token(haxeparser_HaxeLexer.tok);
			}
			root = tokentree_TokenTreeBuilder.buildTokenTree(tokens,content,tokentree_TokenTreeEntryPoint.ExpressionLevel);
			this.readExpression(context,identifier,root);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g);
			let _g2 = _g1.unwrap();
			if(((_g2) instanceof hxparse_ParserError)) {
				let e = _g2;
				throw haxe_Exception.thrown("failed to parse " + context.fileName + " - ParserError: " + Std.string(e) + " (" + Std.string(e.pos) + ")");
			} else if(((_g2) instanceof haxeparser_LexerError)) {
				let e = _g2;
				throw haxe_Exception.thrown("failed to parse " + context.fileName + " - LexerError: " + Std.string(e.msg) + " (" + Std.string(e.pos) + ")");
			} else {
				throw haxe_Exception.thrown("failed to parse " + context.fileName + " - " + _g1.details());
			}
		}
	}
	readEnum(context,identifier,token) {
		if(!token.hasChildren()) {
			return;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 2:
				if(_g2.c._hx_index == 3) {
					let enumField = this.makeIdentifier(context,child,refactor_discover_IdentifierType.EnumField([]),identifier);
					if(enumField == null) {
						continue;
					}
					if(!child.hasChildren()) {
						continue;
					}
					let pOpen = child.getFirstChild();
					if(!pOpen.matches(tokentree_TokenTreeDef.POpen)) {
						continue;
					}
					enumField.type = refactor_discover_IdentifierType.EnumField(this.readParameter(context,enumField,pOpen,pOpen.pos.max));
				} else {
					continue;
				}
				break;
			case 3:
				switch(_g2.s) {
				case "else":
					this.readEnum(context,identifier,child);
					break;
				case "elseif":case "if":
					this.readExpression(context,identifier,child.getFirstChild());
					let _g3 = 1;
					let _g4 = child.children.length - 1;
					while(_g3 < _g4) {
						let index = _g3++;
						if(child.children[index].tok._hx_index != 3) {
							this.readEnum(context,identifier,child.children[index]);
						}
					}
					break;
				default:
					continue;
				}
				break;
			default:
				continue;
			}
		}
	}
	readTypedef(context,identifier,token) {
		if(!token.hasChildren()) {
			return;
		}
		let assignToken = token.getFirstChild();
		let tmp;
		if(assignToken != null) {
			let _g = assignToken.tok;
			tmp = !(_g._hx_index == 6 && _g.op._hx_index == 4);
		} else {
			tmp = true;
		}
		if(tmp || !assignToken.hasChildren()) {
			return;
		}
		let _g = 0;
		let _g1 = assignToken.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 2:
				if(_g2.c._hx_index == 3) {
					this.makeIdentifier(context,child,refactor_discover_IdentifierType.TypedefBase,identifier);
				}
				break;
			case 18:
				this.readAnonStructure(context,identifier,child);
				break;
			default:
			}
		}
	}
	addFields(context,identifier,token) {
		if(token == null || !token.hasChildren()) {
			return;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 1:
				switch(_g2.k._hx_index) {
				case 0:
					let nameToken = child.getFirstChild();
					this.readMethod(context,this.makeIdentifier(context,nameToken,refactor_discover_IdentifierType.Method(tokentree_TokenTreeAccessHelper.firstOf(nameToken,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdStatic)) != null),identifier),nameToken);
					break;
				case 11:
					this.makeIdentifier(context,child.getFirstChild(),refactor_discover_IdentifierType.Extends,identifier);
					break;
				case 12:
					this.makeIdentifier(context,child.getFirstChild(),refactor_discover_IdentifierType.Implements,identifier);
					break;
				case 2:case 42:
					let nameToken1 = child.getFirstChild();
					this.makeIdentifier(context,nameToken1,refactor_discover_IdentifierType.FieldVar(tokentree_TokenTreeAccessHelper.firstOf(nameToken1,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdStatic)) != null),identifier);
					break;
				default:
				}
				break;
			case 3:
				this.addFields(context,identifier,child);
				break;
			case 18:
				this.addFields(context,identifier,child);
				break;
			default:
			}
		}
	}
	addAbstractFields(context,identifier,token) {
		if(token == null || !token.hasChildren()) {
			return;
		}
		let staticVars = false;
		let block = null;
		let _g = 0;
		let _g1 = token.children;
		_hx_loop1: while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 1:
				if(_g2.k._hx_index == 26) {
					staticVars = true;
				}
				break;
			case 2:
				let _gc = _g2.c;
				if(_gc._hx_index == 3) {
					switch(_gc.s) {
					case "from":
						this.makeIdentifier(context,child.getFirstChild(),refactor_discover_IdentifierType.AbstractFrom,identifier);
						break;
					case "to":
						this.makeIdentifier(context,child.getFirstChild(),refactor_discover_IdentifierType.AbstractTo,identifier);
						break;
					default:
					}
				}
				break;
			case 18:
				block = child;
				break _hx_loop1;
			case 20:
				this.readTypeHint(context,identifier,child,refactor_discover_IdentifierType.AbstractOver);
				break;
			default:
			}
		}
		if(block == null) {
			return;
		}
		let _g2 = 0;
		let _g3 = block.children;
		while(_g2 < _g3.length) {
			let child = _g3[_g2];
			++_g2;
			let _g = child.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:
					let nameToken = child.getFirstChild();
					this.readMethod(context,this.makeIdentifier(context,nameToken,refactor_discover_IdentifierType.Method(tokentree_TokenTreeAccessHelper.firstOf(nameToken,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdStatic)) != null),identifier),nameToken);
					break;
				case 2:case 42:
					let nameToken1 = child.getFirstChild();
					let variable = this.makeIdentifier(context,nameToken1,refactor_discover_IdentifierType.FieldVar(staticVars),identifier);
					if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(nameToken1),tokentree_TokenTreeDef.POpen) != null) {
						variable.type = refactor_discover_IdentifierType.Property;
					}
					break;
				default:
				}
			}
		}
	}
	readVarInit(context,identifier,token) {
		if(!token.hasChildren()) {
			return;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			if(_g2._hx_index == 6) {
				if(_g2.op._hx_index == 4) {
					this.readExpression(context,identifier,child.getFirstChild());
				}
			}
		}
	}
	readMethod(context,identifier,token) {
		let ignore = true;
		let fullPos = token.getPos();
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			switch(child.tok._hx_index) {
			case 12:
				break;
			case 18:
				if(ignore) {
					continue;
				}
				this.readBlock(context,identifier,child);
				break;
			case 20:
				this.readParameter(context,identifier,child,fullPos.max);
				ignore = false;
				break;
			default:
				if(ignore) {
					continue;
				}
				this.readExpression(context,identifier,child);
			}
		}
	}
	readObjectLiteral(context,identifier,token) {
		if(!token.hasChildren()) {
			return;
		}
		let names = [];
		let _g = 0;
		let _g1 = token.children;
		_hx_loop1: while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 2:
				let _gc = _g2.c;
				if(_gc._hx_index == 3) {
					names.push(_gc.s);
					this.readExpression(context,this.makeIdentifier(context,child,refactor_discover_IdentifierType.StructureField(names),identifier),child.getFirstChild());
				} else {
					break _hx_loop1;
				}
				break;
			case 19:
				break _hx_loop1;
			default:
				break _hx_loop1;
			}
		}
	}
	readBlock(context,identifier,token) {
		if(!token.hasChildren()) {
			return;
		}
		let scopeEnd = token.getPos().max;
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 1:
				switch(_g2.k._hx_index) {
				case 0:
					child = child.getFirstChild();
					this.readMethod(context,this.makeIdentifier(context,child,refactor_discover_IdentifierType.ScopedLocal(child.pos.min,scopeEnd,refactor_discover_ScopedLocalType.Var),identifier),child);
					break;
				case 2:
					child = child.getFirstChild();
					this.makeIdentifier(context,child,refactor_discover_IdentifierType.ScopedLocal(child.getPos().max,scopeEnd,refactor_discover_ScopedLocalType.Var),identifier);
					break;
				case 42:
					child = child.getFirstChild();
					this.makeIdentifier(context,child,refactor_discover_IdentifierType.ScopedLocal(child.getPos().max,scopeEnd,refactor_discover_ScopedLocalType.Var),identifier);
					break;
				default:
					this.readExpression(context,identifier,child);
				}
				break;
			case 10:
				break;
			case 11:
				break;
			default:
				this.readExpression(context,identifier,child);
			}
		}
	}
	readExpression(context,identifier,token) {
		if(token == null) {
			return;
		}
		let _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				let scopeEnd = token.parent.getPos().max;
				let child = token.getFirstChild();
				let method = this.makeIdentifier(context,child,refactor_discover_IdentifierType.ScopedLocal(child.pos.min,scopeEnd,refactor_discover_ScopedLocalType.Var),identifier);
				if(method == null) {
					this.readMethod(context,identifier,token);
				} else {
					this.readMethod(context,method,child);
				}
				return;
			case 2:
				let scopeEnd1 = token.parent.getPos().max;
				let token1 = token.getFirstChild();
				this.readVarInit(context,this.makeIdentifier(context,token1,refactor_discover_IdentifierType.ScopedLocal(token1.getPos().max,scopeEnd1,refactor_discover_ScopedLocalType.Var),identifier),token1);
				return;
			case 7:
				this.readFor(context,identifier,token);
				return;
			case 14:
				this.readSwitch(context,identifier,token);
				return;
			case 23:
				this.makeIdentifier(context,token,refactor_discover_IdentifierType.Access,identifier);
				return;
			default:
			}
			break;
		case 2:
			if(_g.c._hx_index == 3) {
				let parent = token.parent;
				if(parent.tok._hx_index == 11) {
					let prev = parent.previousSibling;
					if(prev != null) {
						switch(prev.tok._hx_index) {
						case 17:case 21:
							this.makeIdentifier(context,token,refactor_discover_IdentifierType.ArrayAccess(prev.pos.min),identifier);
							return;
						default:
						}
					}
				} else {
					this.makeIdentifier(context,token,refactor_discover_IdentifierType.Access,identifier);
					return;
				}
			}
			break;
		case 10:
			return;
		case 18:
			switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token)._hx_index) {
			case 0:
				this.readBlock(context,identifier,token);
				break;
			case 1:
				this.readBlock(context,identifier,token);
				break;
			case 2:
				this.readObjectLiteral(context,identifier,token);
				break;
			case 3:
				this.readBlock(context,identifier,token);
				break;
			case 4:
				this.readBlock(context,identifier,token);
				break;
			}
			return;
		default:
		}
		if(token.hasChildren()) {
			let _g = 0;
			let _g1 = token.children;
			while(_g < _g1.length) this.readExpression(context,identifier,_g1[_g++]);
		}
	}
	readSwitch(context,identifier,token) {
		if(!token.hasChildren()) {
			return;
		}
		let index = 0;
		if(identifier != null && identifier.uses != null) {
			index = identifier.uses.length;
		}
		this.readExpression(context,identifier,token.getFirstChild());
		let switchIdent = identifier;
		if(identifier != null && identifier.uses != null && identifier.uses.length > index) {
			switchIdent = identifier.uses[index];
		}
		let this1 = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.BrOpen);
		if(this1 == null || !this1.hasChildren()) {
			return;
		}
		let _g = 0;
		let _g1 = this1.children;
		_hx_loop1: while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			if(_g2._hx_index == 1) {
				switch(_g2.k._hx_index) {
				case 15:
					this.readCase(context,switchIdent,child);
					break;
				case 16:
					if(child.hasChildren()) {
						this.readBlock(context,switchIdent,child.getFirstChild());
					}
					break;
				default:
					break _hx_loop1;
				}
			} else {
				break;
			}
		}
	}
	readFor(context,identifier,token) {
		if(!token.hasChildren()) {
			return;
		}
		let skip = true;
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			if(child.tok._hx_index == 20) {
				let scopeEnd = token.getPos().max;
				this.readForIteration(context,identifier,child.getFirstChild(),scopeEnd);
				skip = false;
			} else {
				if(skip) {
					continue;
				}
				this.readExpression(context,identifier,child);
			}
		}
	}
	readForIteration(context,identifier,token,scopeEnd) {
		let loopIdentifiers = [];
		let this1 = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.PClose);
		let scopeStart = token.pos.min;
		if(this1 != null) {
			scopeStart = this1.pos.max;
		}
		let ident = this.makeIdentifier(context,token,refactor_discover_IdentifierType.ScopedLocal(scopeStart,scopeEnd,refactor_discover_ScopedLocalType.ForLoop(loopIdentifiers)),identifier);
		loopIdentifiers.push(ident);
		if(!token.hasChildren()) {
			return;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			if(_g2._hx_index == 6) {
				if(_g2.op._hx_index == 22) {
					ident = this.makeIdentifier(context,child.getFirstChild(),refactor_discover_IdentifierType.ScopedLocal(scopeStart,scopeEnd,refactor_discover_ScopedLocalType.ForLoop(loopIdentifiers)),identifier);
					loopIdentifiers.push(ident);
				} else {
					this.readExpression(context,ident,child);
					if(ident.uses != null) {
						let _g = 0;
						let _g1 = ident.uses;
						while(_g < _g1.length) {
							let use = _g1[_g];
							++_g;
							if(use.type._hx_index == 31) {
								use.type = refactor_discover_IdentifierType.ForIterator;
							}
							loopIdentifiers.push(use);
						}
					}
				}
			} else {
				this.readExpression(context,ident,child);
				if(ident.uses != null) {
					let _g = 0;
					let _g1 = ident.uses;
					while(_g < _g1.length) {
						let use = _g1[_g];
						++_g;
						if(use.type._hx_index == 31) {
							use.type = refactor_discover_IdentifierType.ForIterator;
						}
						loopIdentifiers.push(use);
					}
				}
			}
		}
	}
	readCase(context,identifier,token) {
		if(!token.hasChildren()) {
			return;
		}
		let scopeEnd = token.getPos().max;
		let _g = 0;
		let _g1 = token.children;
		_hx_loop1: while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 1:
				if(_g2.k._hx_index == 2) {
					child = child.getFirstChild();
					this.makeIdentifier(context,child,refactor_discover_IdentifierType.ScopedLocal(child.pos.min,scopeEnd,refactor_discover_ScopedLocalType.CaseCapture),identifier);
				}
				break;
			case 2:
				if(_g2.c._hx_index == 3) {
					this.readCaseConst(context,identifier,child,scopeEnd);
				}
				break;
			case 12:
				this.readBlock(context,identifier,child);
				break _hx_loop1;
			case 16:
				this.readCaseArray(context,identifier,child,scopeEnd);
				break;
			case 18:
				this.readCaseStructure(context,identifier,child,scopeEnd);
				break;
			default:
			}
		}
	}
	readCaseConst(context,identifier,token,scopeEnd) {
		if(!token.hasChildren()) {
			return;
		}
		let caseIdent = this.makeIdentifier(context,token,refactor_discover_IdentifierType.CaseLabel(identifier),identifier);
		let pOpen = token.filterCallback(function(token,index) {
			if(token.tok._hx_index == 20) {
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		let _g = 0;
		while(_g < pOpen.length) this.readParameter(context,caseIdent,pOpen[_g++],scopeEnd);
	}
	readCaseArray(context,identifier,token,scopeEnd) {
		if(!token.hasChildren()) {
			return;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			this.makeIdentifier(context,child,refactor_discover_IdentifierType.ScopedLocal(child.pos.max,scopeEnd,refactor_discover_ScopedLocalType.CaseCapture),identifier);
		}
	}
	readCaseStructure(context,identifier,token,scopeEnd) {
		if(!token.hasChildren()) {
			return;
		}
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			if(child.tok._hx_index == 2) {
				let field = this.makeIdentifier(context,child,refactor_discover_IdentifierType.StructureField([]),identifier);
				if(field == null) {
					continue;
				}
				if(!child.hasChildren()) {
					continue;
				}
				let valueChild = child.getFirstChild();
				switch(valueChild.tok._hx_index) {
				case 1:
					this.readExpression(context,field,valueChild);
					break;
				case 2:
					this.readExpression(context,field,valueChild);
					break;
				case 4:
					this.readExpression(context,field,valueChild);
					break;
				case 5:
					this.readExpression(context,field,valueChild);
					break;
				case 6:
					this.readExpression(context,field,valueChild);
					break;
				case 16:case 18:
					this.readCaseStructure(context,field,valueChild,scopeEnd);
					continue;
				default:
				}
				if(field.uses != null) {
					let _g = 0;
					let _g1 = field.uses;
					while(_g < _g1.length) {
						let use = _g1[_g];
						++_g;
						use.type = refactor_discover_IdentifierType.ScopedLocal(use.pos.start,scopeEnd,refactor_discover_ScopedLocalType.CaseCapture);
					}
				}
			} else {
				break;
			}
		}
	}
	readParameter(context,identifier,token,scopeEnd) {
		let params = [];
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 2:
				if(_g2.c._hx_index == 3) {
					params.push(this.makeIdentifier(context,child,refactor_discover_IdentifierType.ScopedLocal(child.pos.min,scopeEnd,refactor_discover_ScopedLocalType.Parameter(params)),identifier));
				}
				break;
			case 22:
				child = child.getFirstChild();
				params.push(this.makeIdentifier(context,child,refactor_discover_IdentifierType.ScopedLocal(child.pos.min,scopeEnd,refactor_discover_ScopedLocalType.Parameter(params)),identifier));
				break;
			default:
			}
		}
		return params;
	}
	makePosition(fileName,token) {
		return { fileName : fileName, start : token.pos.min, end : token.pos.max};
	}
	makeIdentifier(context,nameToken,type,parentIdentifier) {
		if(nameToken == null) {
			return null;
		}
		let _g = nameToken.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 23:case 37:
				break;
			default:
				return null;
			}
			break;
		case 2:
			if(_g.c._hx_index != 3) {
				return null;
			}
			break;
		default:
			return null;
		}
		let pos = this.makePosition(context.fileName,nameToken);
		let pack = [];
		let typeParamLt = null;
		let typeHintColon = null;
		let pOpenToken = null;
		let parent = nameToken.parent;
		let lastNamePart = nameToken;
		let findAllNames = null;
		findAllNames = function(parentPart) {
			if(!parentPart.hasChildren()) {
				return;
			}
			let _g = 0;
			let _g1 = parentPart.children;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				let _g2 = child.tok;
				switch(_g2._hx_index) {
				case 1:
					switch(_g2.k._hx_index) {
					case 23:case 37:
						pack.push(child.toString());
						break;
					default:
						continue;
					}
					break;
				case 2:
					pack.push(child.toString());
					break;
				case 5:
					return;
				case 6:
					return;
				case 11:
					break;
				case 20:
					let _g3 = parent.tok;
					if(_g3._hx_index == 1) {
						switch(_g3.k._hx_index) {
						case 0:
							break;
						case 2:case 42:
							type = refactor_discover_IdentifierType.Property;
							break;
						default:
						}
					}
					return;
				default:
					continue;
				}
				lastNamePart = child;
				findAllNames(child);
			}
		};
		pack.push(nameToken.toString());
		findAllNames(nameToken);
		pos.end = lastNamePart.pos.max;
		if(lastNamePart.hasChildren()) {
			let _g = 0;
			let _g1 = lastNamePart.children;
			while(_g < _g1.length) {
				let child = _g1[_g];
				++_g;
				let _g2 = child.tok;
				switch(_g2._hx_index) {
				case 6:
					switch(_g2.op._hx_index) {
					case 4:
						if(!parent.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef))) {
							pOpenToken = child;
						}
						break;
					case 9:
						if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(child)) {
							typeParamLt = child;
						}
						break;
					case 22:
						if(type._hx_index == 33) {
							if(type.scopeType._hx_index != 3) {
								pOpenToken = child;
							}
						} else {
							pOpenToken = child;
						}
						break;
					case 23:
						break;
					default:
						pOpenToken = child;
					}
					break;
				case 12:
					switch(tokentree_utils_TokenTreeCheckUtils.getColonType(child)._hx_index) {
					case 0:
						break;
					case 1:
						typeHintColon = child;
						break;
					case 2:
						typeHintColon = child;
						break;
					case 3:
						break;
					case 4:
						break;
					case 5:
						break;
					case 6:
						break;
					}
					break;
				case 16:
					pOpenToken = child;
					break;
				case 20:
					if(type._hx_index == 31) {
						if(parent.matches(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdNew))) {
							type = refactor_discover_IdentifierType.Call(true);
						} else {
							type = refactor_discover_IdentifierType.Call(false);
						}
						pOpenToken = child;
					}
					break;
				default:
				}
			}
		}
		if(pack.length <= 0) {
			return null;
		}
		let identifier = new refactor_discover_Identifier(type,pack.join("."),pos,context.nameMap,context.file,context.type);
		if(parentIdentifier != null) {
			parentIdentifier.addUse(identifier);
		}
		if(typeParamLt != null) {
			this.addTypeParameter(context,identifier,typeParamLt);
		}
		if(typeHintColon != null) {
			this.readTypeHint(context,identifier,typeHintColon,refactor_discover_IdentifierType.TypeHint);
		}
		if(pOpenToken != null) {
			this.readExpression(context,identifier,pOpenToken);
			if(pOpenToken.nextSibling != null) {
				this.readExpression(context,identifier,pOpenToken.nextSibling);
			}
		}
		return identifier;
	}
	addTypeParameter(context,identifier,token) {
		if(!token.hasChildren()) {
			return;
		}
		let _g = 0;
		let _g1 = token.children;
		_hx_loop1: while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 2:
				if(_g2.c._hx_index == 3) {
					this.makeIdentifier(context,child,refactor_discover_IdentifierType.TypedParameter,identifier);
				}
				break;
			case 6:
				if(_g2.op._hx_index == 7) {
					break _hx_loop1;
				}
				break;
			case 20:
				this.readParameter(context,identifier,child,token.getPos().max);
				break;
			default:
			}
		}
	}
	readTypeHint(context,identifier,token,type) {
		if(!token.hasChildren()) {
			return;
		}
		let _g = 0;
		let _g1 = token.children;
		_hx_loop1: while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 2:
				if(_g2.c._hx_index == 3) {
					this.makeIdentifier(context,child,type,identifier);
				}
				break;
			case 18:
				this.readAnonStructure(context,identifier,child);
				break _hx_loop1;
			default:
			}
		}
	}
	readAnonStructure(context,identifier,token) {
		if(!token.hasChildren()) {
			return;
		}
		let fields = [];
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 1:
				switch(_g2.k._hx_index) {
				case 2:case 42:
					let nameToken = child.getFirstChild();
					let identifier1 = this.makeIdentifier(context,nameToken,refactor_discover_IdentifierType.TypedefField(fields),identifier);
					if(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstOf(nameToken,tokentree_TokenTreeDef.At),tokentree_TokenTreeDef.DblDot),tokentree_TokenTreeDef.Const(haxeparser_Constant.CIdent("optional"))) != null) {
						fields.push(refactor_discover_TypedefFieldType.Optional(identifier1));
					} else {
						fields.push(refactor_discover_TypedefFieldType.Required(identifier1));
					}
					break;
				default:
				}
				break;
			case 2:
				if(_g2.c._hx_index == 3) {
					let identifier1 = this.makeIdentifier(context,child,refactor_discover_IdentifierType.TypedefField(fields),identifier);
					if(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstOf(child,tokentree_TokenTreeDef.At),tokentree_TokenTreeDef.DblDot),tokentree_TokenTreeDef.Const(haxeparser_Constant.CIdent("optional"))) != null) {
						fields.push(refactor_discover_TypedefFieldType.Optional(identifier1));
					} else {
						fields.push(refactor_discover_TypedefFieldType.Required(identifier1));
					}
				}
				break;
			case 22:
				fields.push(refactor_discover_TypedefFieldType.Optional(this.makeIdentifier(context,child.getFirstChild(),refactor_discover_IdentifierType.TypedefField(fields),identifier)));
				break;
			default:
			}
		}
	}
}
refactor_discover_UsageCollector.__name__ = "refactor.discover.UsageCollector";
Object.assign(refactor_discover_UsageCollector.prototype, {
	__class__: refactor_discover_UsageCollector
});
class refactor_edits_Changelist {
	constructor(context) {
		this.changes = new haxe_ds_StringMap();
		this.context = context;
	}
	addChange(fileName,change,identifier) {
		if(identifier != null) {
			if(identifier.edited) {
				return;
			}
			identifier.edited = true;
		}
		let fileChanges = this.changes.h[fileName];
		if(fileChanges == null) {
			this.changes.h[fileName] = [change];
		} else {
			fileChanges.push(change);
		}
	}
	execute() {
		if(!this.context.forRealExecute) {
			return this.dryRun();
		}
		let hasChanges = false;
		let h = this.changes.h;
		let _g_keys = Object.keys(h);
		let _g_length = _g_keys.length;
		let _g_current = 0;
		while(_g_current < _g_length) {
			let key = _g_keys[_g_current++];
			let _g_value = h[key];
			_g_value.sort($bind(this,this.sortFileEdits));
			hasChanges = true;
			let doc = this.context.docFactory(key);
			let _g = 0;
			while(_g < _g_value.length) doc.addChange(_g_value[_g++]);
			doc.endEdits();
		}
		if(hasChanges) {
			return refactor_RefactorResult.Done;
		} else {
			return refactor_RefactorResult.NoChange;
		}
	}
	dryRun() {
		let hasChanges = false;
		let h = this.changes.h;
		let _g_keys = Object.keys(h);
		let _g_length = _g_keys.length;
		let _g_current = 0;
		while(_g_current < _g_length) {
			let key = _g_keys[_g_current++];
			let _g_value = h[key];
			_g_value.sort($bind(this,this.sortFileEdits));
			hasChanges = true;
			process.stdout.write(Std.string("" + key));
			process.stdout.write("\n");
			let _g = 0;
			while(_g < _g_value.length) {
				let edit = _g_value[_g];
				++_g;
				switch(edit._hx_index) {
				case 0:
					process.stdout.write(Std.string("* rename to \"" + edit.newFileName + "\""));
					process.stdout.write("\n");
					break;
				case 1:
					let _gtext = edit.text;
					let _gpos = edit.pos;
					let v = "* replace text with \"" + _gtext + "\" @" + _gpos.start + "-" + _gpos.end;
					process.stdout.write(Std.string(v));
					process.stdout.write("\n");
					this.printDiffLines(_gpos,_gtext);
					break;
				case 2:
					let _gtext1 = edit.text;
					let _gpos1 = edit.pos;
					let v1 = "* insert text \"" + _gtext1 + "\" @" + _gpos1.start + "-" + _gpos1.end;
					process.stdout.write(Std.string(v1));
					process.stdout.write("\n");
					process.stdout.write(Std.string("+++ " + _gtext1));
					process.stdout.write("\n");
					break;
				case 3:
					let _gpos2 = edit.pos;
					let v2 = "* remove text @" + _gpos2.start + "-" + _gpos2.end;
					process.stdout.write(Std.string(v2));
					process.stdout.write("\n");
					this.printDiffLines(_gpos2,null);
					break;
				}
			}
		}
		if(hasChanges) {
			return refactor_RefactorResult.DryRun;
		} else {
			return refactor_RefactorResult.NoChange;
		}
	}
	sortFileEdits(a,b) {
		let offsetA;
		switch(a._hx_index) {
		case 0:
			offsetA = 0;
			break;
		case 1:
			offsetA = a.pos.start;
			break;
		case 2:
			offsetA = a.pos.start;
			break;
		case 3:
			offsetA = a.pos.start;
			break;
		}
		let offsetB;
		switch(b._hx_index) {
		case 0:
			offsetB = 0;
			break;
		case 1:
			offsetB = b.pos.start;
			break;
		case 2:
			offsetB = b.pos.start;
			break;
		case 3:
			offsetB = b.pos.start;
			break;
		}
		if(offsetA < offsetB) {
			return -1;
		}
		if(offsetA > offsetB) {
			return 1;
		}
		return 0;
	}
	printDiffLines(pos,toName) {
		let content = js_node_buffer__$Buffer_Helper.bytesOfBuffer(js_node_Fs.readFileSync(pos.fileName));
		let lineStart = pos.start;
		let lineEnd = pos.end;
		while(lineStart > 0) {
			let char = content.b[lineStart];
			if(char == 10 || char == 13) {
				++lineStart;
				break;
			}
			--lineStart;
		}
		while(lineEnd < content.length) {
			let char = content.b[lineEnd];
			if(char == 10 || char == 13) {
				break;
			}
			++lineEnd;
		}
		let origLine = content.getString(lineStart,lineEnd - lineStart);
		process.stdout.write(Std.string("--- " + origLine));
		process.stdout.write("\n");
		if(toName != null) {
			let newLine = haxe_io_Bytes.ofString(content.getString(0,pos.start) + toName + content.getString(pos.end,content.length - pos.end)).getString(lineStart,lineEnd + (toName.length - (pos.end - pos.start) - lineStart));
			process.stdout.write(Std.string("+++ " + newLine));
			process.stdout.write("\n");
		}
	}
}
refactor_edits_Changelist.__name__ = "refactor.edits.Changelist";
Object.assign(refactor_edits_Changelist.prototype, {
	__class__: refactor_edits_Changelist
});
var refactor_edits_FileEdit = $hxEnums["refactor.edits.FileEdit"] = { __ename__:true,__constructs__:null
	,Move: ($_=function(newFileName) { return {_hx_index:0,newFileName:newFileName,__enum__:"refactor.edits.FileEdit",toString:$estr}; },$_._hx_name="Move",$_.__params__ = ["newFileName"],$_)
	,ReplaceText: ($_=function(text,pos) { return {_hx_index:1,text:text,pos:pos,__enum__:"refactor.edits.FileEdit",toString:$estr}; },$_._hx_name="ReplaceText",$_.__params__ = ["text","pos"],$_)
	,InsertText: ($_=function(text,pos) { return {_hx_index:2,text:text,pos:pos,__enum__:"refactor.edits.FileEdit",toString:$estr}; },$_._hx_name="InsertText",$_.__params__ = ["text","pos"],$_)
	,RemoveText: ($_=function(pos) { return {_hx_index:3,pos:pos,__enum__:"refactor.edits.FileEdit",toString:$estr}; },$_._hx_name="RemoveText",$_.__params__ = ["pos"],$_)
};
refactor_edits_FileEdit.__constructs__ = [refactor_edits_FileEdit.Move,refactor_edits_FileEdit.ReplaceText,refactor_edits_FileEdit.InsertText,refactor_edits_FileEdit.RemoveText];
class refactor_rename_RenameAnonStructField {
	static refactorAnonStructField(context,file,identifier,fields) {
		let changelist = new refactor_edits_Changelist(context);
		changelist.addChange(identifier.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,identifier.pos),identifier);
		return refactor_rename_RenameAnonStructField.renameFieldsOfType(context,changelist,identifier.defineType,fields,identifier.name).then(function(result) {
			return changelist.execute();
		});
	}
	static refactorStructureField(context,file,identifier,fieldNames) {
		let allUses = context.nameMap.getIdentifiers(identifier.name);
		let _g = 0;
		while(_g < allUses.length) {
			let use = allUses[_g];
			++_g;
			let _g1 = use.type;
			if(_g1._hx_index == 21) {
				let _gfields = _g1.fields;
				let fields = _gfields;
				fields = _gfields.concat(refactor_rename_RenameAnonStructField.findBaseTypes(context,use.defineType));
				if(refactor_rename_RenameAnonStructField.matchesFields(fields,fieldNames)) {
					return refactor_rename_RenameAnonStructField.refactorAnonStructField(context,use.file,use,fields);
				}
			} else {
				continue;
			}
		}
		return Promise.resolve(refactor_RefactorResult.Unsupported(identifier.toString()));
	}
	static renameFieldsOfType(context,changelist,type,fields,fromName) {
		let packName = type.file.getPackage();
		let mainModuleName = type.file.getMainModulName();
		fields = fields.concat(refactor_rename_RenameAnonStructField.findBaseTypes(context,type));
		let allUses = context.nameMap.matchIdentifierPart(fromName,true);
		let promises = [];
		let _g = 0;
		while(_g < allUses.length) {
			let use = allUses[_g];
			++_g;
			let _g1 = use.type;
			switch(_g1._hx_index) {
			case 22:
				if(!refactor_rename_RenameAnonStructField.matchesFields(fields,_g1.fieldNames)) {
					continue;
				}
				break;
			case 29:
				if(_g1.isNew == false) {
					promises.push(refactor_rename_RenameHelper.replaceSingleAccessOrCall(context,changelist,use,fromName,[type]));
					continue;
				} else {
					continue;
				}
				break;
			case 31:
				promises.push(refactor_rename_RenameHelper.replaceSingleAccessOrCall(context,changelist,use,fromName,[type]));
				continue;
			default:
				continue;
			}
			switch(use.file.importsModule(packName,mainModuleName,type.name.name)._hx_index) {
			case 0:
				continue;
			case 4:
				break;
			case 1:case 2:case 3:case 5:
				break;
			}
			changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,use.pos),use);
		}
		promises.push(refactor_rename_RenameAnonStructField.findAllExtending(context,changelist,type,fields,fromName));
		return Promise.all(promises).then(null);
	}
	static findAllExtending(context,changelist,type,fields,fromName) {
		let allUses = context.nameMap.getIdentifiers(type.name.name);
		let promises = [];
		let _g = 0;
		while(_g < allUses.length) {
			let use = allUses[_g];
			++_g;
			if(use.type._hx_index == 20) {
				promises.push(refactor_rename_RenameAnonStructField.renameFieldsOfType(context,changelist,use.defineType,refactor_rename_RenameAnonStructField.getFieldsOfTypedef(use.defineType),fromName));
			}
		}
		return Promise.all(promises).then(null);
	}
	static matchesFields(fields,fieldNames) {
		let allowedFieldNames = [];
		let _g = 0;
		while(_g < fields.length) {
			let field = fields[_g];
			++_g;
			switch(field._hx_index) {
			case 0:
				let _gidentifier = field.identifier;
				allowedFieldNames.push(_gidentifier.name);
				if(!fieldNames.includes(_gidentifier.name)) {
					return false;
				}
				break;
			case 1:
				allowedFieldNames.push(field.identifier.name);
				break;
			}
		}
		let _g1 = 0;
		while(_g1 < fieldNames.length) if(!allowedFieldNames.includes(fieldNames[_g1++])) {
			return false;
		}
		return true;
	}
	static findBaseTypes(context,type) {
		let fieldTypes = [];
		let baseTypes = type.findAllIdentifiers(function(i) {
			if(i.type._hx_index == 20) {
				return true;
			} else {
				return false;
			}
		});
		let _g = 0;
		while(_g < baseTypes.length) {
			let base = refactor_rename_RenameAnonStructField.findBase(context,baseTypes[_g++]);
			if(base == null) {
				continue;
			}
			fieldTypes = fieldTypes.concat(refactor_rename_RenameAnonStructField.getFieldsOfTypedef(base));
		}
		return fieldTypes;
	}
	static getFieldsOfTypedef(type) {
		let allChilds = type.findAllIdentifiers(function(i) {
			return true;
		});
		let _g = 0;
		while(_g < allChilds.length) {
			let _g1 = allChilds[_g++].type;
			if(_g1._hx_index == 21) {
				return _g1.fields;
			}
		}
		return [];
	}
	static findBase(context,baseTypeName) {
		let allUses = context.nameMap.getIdentifiers(baseTypeName.name);
		let _g = 0;
		while(_g < allUses.length) {
			let use = allUses[_g];
			++_g;
			if(use.type._hx_index != 8) {
				continue;
			}
			switch(baseTypeName.file.importsModule(use.file.getPackage(),use.file.getMainModulName(),baseTypeName.name)._hx_index) {
			case 0:
				continue;
			case 4:
				break;
			case 1:case 2:case 3:case 5:
				break;
			}
			return use.defineType;
		}
		return null;
	}
}
refactor_rename_RenameAnonStructField.__name__ = "refactor.rename.RenameAnonStructField";
class refactor_rename_RenameEnumField {
	static refactorEnumField(context,file,identifier) {
		let changelist = new refactor_edits_Changelist(context);
		changelist.addChange(identifier.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,identifier.pos),identifier);
		let packName = file.getPackage();
		let mainModuleName = file.getMainModulName();
		let typeName = identifier.defineType.name.name;
		let fullModuleTypeName = identifier.defineType.getFullModulName();
		let allUses = context.nameMap.getIdentifiers("" + typeName + "." + identifier.name);
		let _g = 0;
		while(_g < allUses.length) {
			let use = allUses[_g];
			++_g;
			let _g1 = use.file.importsModule(packName,mainModuleName,typeName);
			switch(_g1._hx_index) {
			case 0:
				continue;
			case 4:
				if(_g1.alias != typeName) {
					continue;
				}
				break;
			case 1:case 2:case 3:case 5:
				break;
			}
			refactor_rename_RenameHelper.replaceTextWithPrefix(use,typeName,context.what.toName,changelist);
		}
		allUses = context.nameMap.getIdentifiers("" + fullModuleTypeName + "." + identifier.name);
		let _g1 = 0;
		while(_g1 < allUses.length) refactor_rename_RenameHelper.replaceTextWithPrefix(allUses[_g1++],fullModuleTypeName,context.what.toName,changelist);
		allUses = context.nameMap.matchIdentifierPart(identifier.name,true);
		let changes = [];
		let _g2 = 0;
		while(_g2 < allUses.length) {
			let use = allUses[_g2];
			++_g2;
			let _g = use.type;
			switch(_g._hx_index) {
			case 28:
				let _gswitchIdentifier = _g.switchIdentifier;
				changes.push(refactor_rename_RenameHelper.matchesType(context,{ name : _gswitchIdentifier.name, pos : _gswitchIdentifier.pos.start, defineType : _gswitchIdentifier.defineType},refactor_rename_TypeHintType.KnownType(identifier.defineType,[])).then(function(matched) {
					if(matched) {
						refactor_rename_RenameHelper.replaceTextWithPrefix(use,"",context.what.toName,changelist);
					}
				}));
				continue;
			case 29:
				if(_g.isNew == false) {
					if(use.parent.type._hx_index != 29) {
						continue;
					}
					let _g = use.file.importsModule(packName,mainModuleName,typeName);
					switch(_g._hx_index) {
					case 0:
						continue;
					case 4:
						if(_g.alias != typeName) {
							continue;
						}
						break;
					case 1:case 2:case 3:case 5:
						break;
					}
				} else {
					continue;
				}
				break;
			case 31:
				if(use.parent.type._hx_index != 29) {
					continue;
				}
				let _g1 = use.file.importsModule(packName,mainModuleName,typeName);
				switch(_g1._hx_index) {
				case 0:
					continue;
				case 4:
					if(_g1.alias != typeName) {
						continue;
					}
					break;
				case 1:case 2:case 3:case 5:
					break;
				}
				break;
			default:
				continue;
			}
			refactor_rename_RenameHelper.replaceTextWithPrefix(use,"",context.what.toName,changelist);
		}
		return Promise.all(changes).then(function(_) {
			return changelist.execute();
		});
	}
}
refactor_rename_RenameEnumField.__name__ = "refactor.rename.RenameEnumField";
class refactor_rename_RenameField {
	static refactorField(context,file,identifier,isStatic) {
		let changelist = new refactor_edits_Changelist(context);
		let types = refactor_rename_RenameHelper.findDescendantTypes(context,file.getPackage(),identifier.defineType);
		types.push(identifier.defineType);
		let changes = [];
		let _g = 0;
		while(_g < types.length) {
			let type = types[_g];
			++_g;
			refactor_rename_RenameField.replaceInType(changelist,type,"",identifier.name,context.what.toName);
			refactor_rename_RenameField.replaceInTypeWithFieldAccess(changelist,type,"",identifier.name,context.what.toName);
			refactor_rename_RenameField.replaceInType(changelist,type,"super.",identifier.name,context.what.toName);
			refactor_rename_RenameField.replaceInType(changelist,type,"this.",identifier.name,context.what.toName);
			refactor_rename_RenameField.replaceInTypeWithFieldAccess(changelist,type,"this.",identifier.name,context.what.toName);
			if(identifier.type._hx_index == 23) {
				refactor_rename_RenameField.replaceInType(changelist,type,"set_",identifier.name,context.what.toName);
				refactor_rename_RenameField.replaceInType(changelist,type,"get_",identifier.name,context.what.toName);
			}
			if(isStatic) {
				refactor_rename_RenameField.replaceStaticUse(context,changelist,type,identifier.name);
				let _g = identifier.type;
				if(_g._hx_index == 18) {
					if(_g.isStatic == true) {
						changes.push(refactor_rename_RenameHelper.replaceStaticExtension(context,changelist,identifier));
					}
				}
			}
		}
		changes.push(refactor_rename_RenameField.replaceAccessOrCalls(context,changelist,identifier,types));
		return Promise.all(changes).then(function(_) {
			return changelist.execute();
		});
	}
	static replaceAccessOrCalls(context,changelist,identifier,types) {
		let allUses = context.nameMap.matchIdentifierPart(identifier.name,true);
		let changes = [];
		let _g = 0;
		while(_g < allUses.length) changes.push(refactor_rename_RenameHelper.replaceSingleAccessOrCall(context,changelist,allUses[_g++],identifier.name,types));
		return Promise.all(changes).then(null);
	}
	static replaceInType(changelist,type,prefix,from,to) {
		let allUses = type.getIdentifiers(prefix + from);
		let innerScopeStart = 0;
		let innerScopeEnd = -1;
		let _g = 0;
		while(_g < allUses.length) {
			let use = allUses[_g];
			++_g;
			if(innerScopeStart < use.pos.start && use.pos.start < innerScopeEnd) {
				continue;
			}
			let _g1 = use.type;
			switch(_g1._hx_index) {
			case 22:
				continue;
			case 33:
				innerScopeStart = _g1.scopeStart;
				innerScopeEnd = _g1.scopeEnd;
				continue;
			default:
			}
			refactor_rename_RenameHelper.replaceTextWithPrefix(use,prefix,to,changelist);
		}
	}
	static replaceInTypeWithFieldAccess(changelist,type,prefix,from,to) {
		let allUses = type.getIdentifiers(prefix + from);
		let allAccess = type.getStartsWith("" + prefix + from + ".");
		let shadowed = false;
		let _g = 0;
		while(_g < allAccess.length) {
			let access = allAccess[_g];
			++_g;
			let _g1 = 0;
			_hx_loop2: while(_g1 < allUses.length) {
				let use = allUses[_g1];
				++_g1;
				if(use.pos.start > access.pos.start) {
					break;
				}
				let _g = use.type;
				switch(_g._hx_index) {
				case 22:
					break;
				case 33:
					if(_g.scopeEnd > access.pos.start) {
						shadowed = true;
						break _hx_loop2;
					}
					break;
				default:
				}
			}
			if(shadowed) {
				continue;
			}
			changelist.addChange(access.pos.fileName,refactor_edits_FileEdit.ReplaceText(to,{ fileName : access.pos.fileName, start : access.pos.start + prefix.length, end : access.pos.start + prefix.length + from.length}),access);
		}
	}
	static replaceStaticUse(context,changelist,type,fromName) {
		let packName = type.file.getPackage();
		let allUses = context.nameMap.getIdentifiers("" + type.name.name + "." + fromName);
		let _g = 0;
		while(_g < allUses.length) {
			let use = allUses[_g];
			++_g;
			switch(use.file.importsModule(packName,type.file.getMainModulName(),type.name.name)._hx_index) {
			case 0:
				continue;
			case 4:
				continue;
			case 1:case 2:case 3:case 5:
				break;
			}
			refactor_rename_RenameHelper.replaceTextWithPrefix(use,"" + type.name.name + ".",context.what.toName,changelist);
		}
		let fullModuleName = type.getFullModulName();
		let allUses1 = context.nameMap.getIdentifiers("" + fullModuleName + "." + fromName);
		let _g1 = 0;
		while(_g1 < allUses1.length) refactor_rename_RenameHelper.replaceTextWithPrefix(allUses1[_g1++],"" + fullModuleName + ".",context.what.toName,changelist);
	}
}
refactor_rename_RenameField.__name__ = "refactor.rename.RenameField";
class refactor_rename_RenameHelper {
	static replaceTextWithPrefix(use,prefix,to,changelist) {
		if(prefix.length <= 0) {
			changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(to,use.pos),use);
		} else {
			changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(to,{ fileName : use.pos.fileName, start : use.pos.start + prefix.length, end : use.pos.end}),use);
		}
	}
	static findDescendantTypes(context,packName,baseType) {
		let types = [];
		let pushType = function(newType) {
			let _g = 0;
			while(_g < types.length) {
				let type = types[_g];
				++_g;
				if(type.file.name == newType.file.name && type.name.name == newType.name.name) {
					return;
				}
			}
			types.push(newType);
		};
		let searchImplementingTypes = function(types,search) {
			let _g = 0;
			while(_g < types.length) {
				let _g1 = 0;
				let _g2 = types[_g++].getIdentifiers(search);
				while(_g1 < _g2.length) {
					let use = _g2[_g1];
					++_g1;
					switch(use.type._hx_index) {
					case 11:case 12:
						pushType(use.defineType);
						break;
					case 13:
						pushType(use.defineType);
						break;
					default:
					}
				}
			}
		};
		let allUses = context.nameMap.getIdentifiers("" + packName + "." + baseType.name.name);
		let _g = 0;
		while(_g < allUses.length) {
			let use = allUses[_g];
			++_g;
			switch(use.type._hx_index) {
			case 1:
				let search;
				let _g1 = use.file.importsModule(baseType.file.getPackage(),baseType.file.getMainModulName(),baseType.name.name);
				switch(_g1._hx_index) {
				case 0:
					continue;
				case 4:
					search = _g1.alias;
					break;
				case 1:case 2:case 3:case 5:
					search = baseType.name.name;
					break;
				}
				searchImplementingTypes(use.file.typeList,search);
				break;
			case 11:case 12:
				pushType(use.defineType);
				break;
			case 13:
				pushType(use.defineType);
				break;
			default:
			}
		}
		allUses = context.nameMap.getIdentifiers(baseType.name.name);
		let _g1 = 0;
		while(_g1 < allUses.length) {
			let use = allUses[_g1];
			++_g1;
			switch(use.type._hx_index) {
			case 11:case 12:
				pushType(use.defineType);
				break;
			case 13:
				pushType(use.defineType);
				break;
			default:
			}
		}
		let _g2 = 0;
		while(_g2 < types.length) {
			let type = types[_g2];
			++_g2;
			let _g = 0;
			let _g1 = refactor_rename_RenameHelper.findDescendantTypes(context,type.file.getPackage(),type);
			while(_g < _g1.length) pushType(_g1[_g++]);
		}
		return types;
	}
	static matchesType(context,searchTypeOf,searchType) {
		return refactor_rename_RenameHelper.findTypeOfIdentifier(context,searchTypeOf).then(function(identifierType) {
			if(identifierType == null) {
				return false;
			}
			if(identifierType == null) {
				let context1 = context;
				let tmp = "types do not match for static extension " + searchTypeOf.name + ":" + refactor_PrintHelper.printTypeHint(identifierType) + " != " + refactor_PrintHelper.printTypeHint(searchType);
				context1.verboseLog(tmp,{ fileName : "refactor/rename/RenameHelper.hx", lineNumber : 121, className : "refactor.rename.RenameHelper", methodName : "matchesType"});
				return false;
			} else {
				switch(identifierType._hx_index) {
				case 0:
					let _gtypeParams = identifierType.typeParams;
					if(searchType._hx_index == 0) {
						let _gtype = searchType.type;
						let _gtypeParams1 = searchType.typeParams;
						if(identifierType.type.getFullModulName() != _gtype.getFullModulName()) {
							return false;
						}
						if(_gtypeParams.length != _gtypeParams1.length) {
							return false;
						}
						let _g = 0;
						let _g1 = _gtypeParams.length;
						while(_g < _g1) {
							let index = _g++;
							if(_gtypeParams[index].name != _gtypeParams1[index].name) {
								return false;
							}
						}
						return true;
					} else {
						let context1 = context;
						let tmp = "types do not match for static extension " + searchTypeOf.name + ":" + refactor_PrintHelper.printTypeHint(identifierType) + " != " + refactor_PrintHelper.printTypeHint(searchType);
						context1.verboseLog(tmp,{ fileName : "refactor/rename/RenameHelper.hx", lineNumber : 121, className : "refactor.rename.RenameHelper", methodName : "matchesType"});
						return false;
					}
					break;
				case 1:
					let _gtypeParams1 = identifierType.typeParams;
					if(searchType._hx_index == 1) {
						let _gtypeParams = searchType.typeParams;
						if(identifierType.name != searchType.name) {
							return false;
						}
						if(_gtypeParams1.length != _gtypeParams.length) {
							return false;
						}
						let _g = 0;
						let _g1 = _gtypeParams1.length;
						while(_g < _g1) {
							let index = _g++;
							if(_gtypeParams1[index].name != _gtypeParams[index].name) {
								return false;
							}
						}
						return true;
					} else {
						let context1 = context;
						let tmp = "types do not match for static extension " + searchTypeOf.name + ":" + refactor_PrintHelper.printTypeHint(identifierType) + " != " + refactor_PrintHelper.printTypeHint(searchType);
						context1.verboseLog(tmp,{ fileName : "refactor/rename/RenameHelper.hx", lineNumber : 121, className : "refactor.rename.RenameHelper", methodName : "matchesType"});
						return false;
					}
					break;
				}
			}
		});
	}
	static findTypeWithTyper(context,fileName,pos) {
		if(context.typer == null) {
			return Promise.reject("no typer");
		}
		return context.typer.resolveType(fileName,pos);
	}
	static findTypeOfIdentifier(context,searchTypeOf) {
		let parts = searchTypeOf.name.split(".");
		let part = parts.shift();
		return refactor_rename_RenameHelper.findFieldOrScopedLocal(context,searchTypeOf.defineType,part,searchTypeOf.pos).then(function(type) {
			let index = 0;
			let findFieldForPart = null;
			findFieldForPart = function(partType) {
				if(index >= parts.length) {
					return Promise.resolve(partType);
				}
				index += 1;
				let part = parts[index - 1];
				if(partType == null) {
					context.verboseLog("unable to determine type of \"" + part + "\" in " + searchTypeOf.defineType.file.name + "@" + searchTypeOf.pos,{ fileName : "refactor/rename/RenameHelper.hx", lineNumber : 147, className : "refactor.rename.RenameHelper", methodName : "findTypeOfIdentifier"});
					return Promise.reject("unable to determine type of \"" + part + "\" in " + searchTypeOf.defineType.file.name + "@" + searchTypeOf.pos);
				} else {
					switch(partType._hx_index) {
					case 0:
						return refactor_rename_RenameHelper.findField(context,partType.type,part).then(findFieldForPart);
					case 1:
						return Promise.reject("unable to determine type of \"" + part + "\" in " + searchTypeOf.defineType.name.name + "@" + searchTypeOf.pos);
					}
				}
			};
			return findFieldForPart(type);
		});
	}
	static findFieldOrScopedLocal(context,containerType,name,pos) {
		return refactor_rename_RenameHelper.findTypeWithTyper(context,containerType.file.name,pos).catch(function(msg) {
			let allUses = containerType.getIdentifiers(name);
			let candidate = null;
			let fieldCandidate = null;
			let _g = 0;
			while(_g < allUses.length) {
				let use = allUses[_g];
				++_g;
				let _g1 = use.type;
				switch(_g1._hx_index) {
				case 16:
					fieldCandidate = use;
					break;
				case 17:
					fieldCandidate = use;
					break;
				case 18:
					fieldCandidate = use;
					break;
				case 21:
					fieldCandidate = use;
					break;
				case 27:
					return Promise.resolve(refactor_rename_TypeHintType.KnownType(use.defineType,[]));
				case 28:
					let _gswitchIdentifier = _g1.switchIdentifier;
					if(use.pos.start == pos) {
						return refactor_rename_RenameHelper.findFieldOrScopedLocal(context,containerType,_gswitchIdentifier.name,_gswitchIdentifier.pos.start);
					}
					break;
				case 33:
					if(pos >= _g1.scopeStart && pos <= _g1.scopeEnd) {
						candidate = use;
					}
					if(pos == use.pos.start) {
						candidate = use;
					}
					break;
				default:
				}
			}
			if(candidate == null) {
				candidate = fieldCandidate;
			}
			if(candidate == null) {
				return Promise.resolve(null);
			}
			let typeHint = candidate.getTypeHint();
			let _g1 = candidate.type;
			if(_g1._hx_index == 33) {
				let _gscopeType = _g1.scopeType;
				switch(_gscopeType._hx_index) {
				case 0:
					if(typeHint != null) {
						return refactor_rename_RenameHelper.typeFromTypeHint(context,typeHint);
					}
					let index = _gscopeType.params.indexOf(candidate);
					let _g = candidate.parent.type;
					if(_g._hx_index == 28) {
						let _gswitchIdentifier = _g.switchIdentifier;
						return refactor_rename_RenameHelper.findFieldOrScopedLocal(context,containerType,_gswitchIdentifier.name,_gswitchIdentifier.pos.start).then(function(enumType) {
							if(enumType == null) {
								return Promise.resolve(null);
							} else {
								switch(enumType._hx_index) {
								case 0:
									let _gtype = enumType.type;
									if(_gtype.name.type._hx_index == 6) {
										let enumFields = _gtype.findAllIdentifiers(function(i) {
											return i.name == candidate.parent.name;
										});
										while(0 < enumFields.length) {
											let _g = enumFields[0].type;
											if(_g._hx_index == 27) {
												let _gparams = _g.params;
												if(_gparams.length <= index) {
													return Promise.resolve(null);
												}
												typeHint = _gparams[index].getTypeHint();
												if(typeHint == null) {
													return Promise.resolve(null);
												}
												return refactor_rename_RenameHelper.typeFromTypeHint(context,typeHint);
											} else {
												return Promise.reject("not an enum field");
											}
										}
									}
									break;
								case 1:
									return Promise.resolve(null);
								}
							}
							return Promise.resolve(enumType);
						});
					}
					break;
				case 3:
					let _gloopIdentifiers = _gscopeType.loopIdentifiers;
					let index1 = _gloopIdentifiers.indexOf(candidate);
					let changes = [];
					let _g2 = 0;
					while(_g2 < _gloopIdentifiers.length) {
						let child = _gloopIdentifiers[_g2];
						++_g2;
						let _g = child.type;
						if(_g._hx_index == 33) {
							if(_g.scopeType._hx_index == 3) {
								continue;
							} else {
								changes.push(refactor_rename_RenameHelper.findTypeOfIdentifier(context,{ name : child.name, pos : child.pos.start, defineType : containerType}).then(function(data) {
									if(data != null) {
										switch(data._hx_index) {
										case 0:
											let _gtypeParams = data.typeParams;
											if(_gtypeParams.length <= index1) {
												return Promise.reject("not enough type parameters");
											}
											return refactor_rename_RenameHelper.typeFromTypeHint(context,_gtypeParams[index1]);
										case 1:
											let _gtypeParams1 = data.typeParams;
											if(_gtypeParams1.length <= index1) {
												return Promise.reject("not enough type parameters");
											}
											return refactor_rename_RenameHelper.typeFromTypeHint(context,_gtypeParams1[index1]);
										}
									}
									return Promise.reject("not found");
								}));
							}
						} else {
							changes.push(refactor_rename_RenameHelper.findTypeOfIdentifier(context,{ name : child.name, pos : child.pos.start, defineType : containerType}).then(function(data) {
								if(data != null) {
									switch(data._hx_index) {
									case 0:
										let _gtypeParams = data.typeParams;
										if(_gtypeParams.length <= index1) {
											return Promise.reject("not enough type parameters");
										}
										return refactor_rename_RenameHelper.typeFromTypeHint(context,_gtypeParams[index1]);
									case 1:
										let _gtypeParams1 = data.typeParams;
										if(_gtypeParams1.length <= index1) {
											return Promise.reject("not enough type parameters");
										}
										return refactor_rename_RenameHelper.typeFromTypeHint(context,_gtypeParams1[index1]);
									}
								}
								return Promise.reject("not found");
							}));
						}
					}
					let winner = Promise.race(changes);
					return winner.catch(function(data) {
						if(typeHint != null) {
							return refactor_rename_RenameHelper.typeFromTypeHint(context,typeHint);
						}
						return Promise.reject("type not found");
					});
				default:
				}
			}
			if(typeHint != null) {
				return refactor_rename_RenameHelper.typeFromTypeHint(context,typeHint);
			}
			return Promise.resolve(null);
		});
	}
	static findField(context,containerType,name) {
		while(true) {
			let allUses = containerType.getIdentifiers(name);
			let candidate = null;
			let _g = 0;
			_hx_loop2: while(_g < allUses.length) {
				let use = allUses[_g];
				++_g;
				switch(use.type._hx_index) {
				case 16:
					candidate = use;
					break _hx_loop2;
				case 17:
					candidate = use;
					break _hx_loop2;
				case 18:
					candidate = use;
					break _hx_loop2;
				case 21:
					candidate = use;
					break _hx_loop2;
				case 27:
					candidate = use;
					break _hx_loop2;
				default:
				}
			}
			if(candidate == null || candidate.uses == null) {
				switch(containerType.name.type._hx_index) {
				case 5:
					let baseType = refactor_rename_RenameHelper.findBaseClass(context.typeList,containerType);
					if(baseType == null) {
						return Promise.resolve(null);
					}
					containerType = baseType;
					continue;
				case 8:
					break;
				default:
				}
				return Promise.resolve(null);
			}
			let _g1 = 0;
			let _g2 = candidate.uses;
			while(_g1 < _g2.length) {
				let use = _g2[_g1];
				++_g1;
				if(use.type._hx_index == 26) {
					return refactor_rename_RenameHelper.typeFromTypeHint(context,use);
				}
			}
			return Promise.resolve(null);
		}
	}
	static findBaseClass(typeList,type) {
		let baseClasses = type.findAllIdentifiers(function(i) {
			if(i.type._hx_index == 11) {
				return true;
			} else {
				return false;
			}
		});
		let _g = 0;
		while(_g < baseClasses.length) {
			let candidateTypes = typeList.findTypeName(baseClasses[_g++].name);
			let _g1 = 0;
			while(_g1 < candidateTypes.length) {
				let candidate = candidateTypes[_g1];
				++_g1;
				switch(type.file.importsModule(candidate.file.getPackage(),candidate.file.getMainModulName(),candidate.name.name)._hx_index) {
				case 0:
					break;
				case 4:
					break;
				case 1:case 2:case 3:case 5:
					return candidate;
				}
			}
		}
		return null;
	}
	static typeFromTypeHint(context,hint) {
		while(true) {
			if(hint.name == "Null") {
				if(hint.uses == null || hint.uses.length <= 0) {
					return Promise.reject();
				}
				hint = hint.uses[0];
				continue;
			}
			let parts = hint.name.split(".");
			let typeName = parts.pop();
			let typeParams = [];
			if(hint.uses != null) {
				let _g = 0;
				let _g1 = hint.uses;
				while(_g < _g1.length) {
					let use = _g1[_g];
					++_g;
					if(use.type._hx_index == 19) {
						typeParams.push(use);
					}
				}
			}
			let allTypes = context.typeList.findTypeName(typeName);
			if(parts.length > 0) {
				let _g = 0;
				while(_g < allTypes.length) {
					let type = allTypes[_g];
					++_g;
					if(type.getFullModulName() == hint.name) {
						return Promise.resolve(refactor_rename_TypeHintType.KnownType(type,typeParams));
					}
				}
				return Promise.resolve(refactor_rename_TypeHintType.UnknownType(hint.name,typeParams));
			}
			let _g = 0;
			while(_g < allTypes.length) {
				let type = allTypes[_g];
				++_g;
				switch(hint.file.importsModule(type.file.getPackage(),type.file.getMainModulName(),type.name.name)._hx_index) {
				case 0:
					break;
				case 4:
					break;
				case 1:case 2:case 3:case 5:
					return Promise.resolve(refactor_rename_TypeHintType.KnownType(type,typeParams));
				}
			}
			return Promise.resolve(refactor_rename_TypeHintType.UnknownType(hint.name,typeParams));
		}
	}
	static replaceStaticExtension(context,changelist,identifier) {
		let allUses = context.nameMap.matchIdentifierPart(identifier.name,true);
		if(identifier.uses == null) {
			return Promise.resolve(null);
		}
		let firstParam = null;
		let _g = 0;
		let _g1 = identifier.uses;
		while(_g < _g1.length) {
			let use = _g1[_g];
			++_g;
			let _g2 = use.type;
			if(_g2._hx_index == 33) {
				if(_g2.scopeType._hx_index == 0) {
					firstParam = use;
					break;
				}
			}
		}
		if(firstParam == null) {
			return Promise.resolve(null);
		}
		let changes = [];
		let _g2 = 0;
		let _g3 = firstParam.uses;
		while(_g2 < _g3.length) {
			let use = _g3[_g2];
			++_g2;
			if(use.type._hx_index == 26) {
				changes.push(refactor_rename_RenameHelper.typeFromTypeHint(context,use).then(function(firstParamType) {
					if(firstParamType == null) {
						context.verboseLog("could not find type of first parameter for static extension",{ fileName : "refactor/rename/RenameHelper.hx", lineNumber : 397, className : "refactor.rename.RenameHelper", methodName : "replaceStaticExtension"});
						return Promise.resolve(null);
					}
					let innerChanges = [];
					let _g = 0;
					while(_g < allUses.length) {
						let use = allUses[_g];
						++_g;
						let object = "";
						if(use.name == identifier.name) {
							if(use.parent != null) {
								if(firstParamType != null) {
									switch(firstParamType._hx_index) {
									case 0:
										if(use.parent.name == firstParamType.type.name.name) {
											changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,use.pos),use);
											continue;
										}
										break;
									case 1:
										if(use.parent.name == firstParamType.name) {
											changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,use.pos),use);
											continue;
										}
										break;
									}
								}
							}
							object = use.name;
						} else {
							object = HxOverrides.substr(use.name,0,use.name.length - identifier.name.length - 1);
						}
						innerChanges.push(refactor_rename_RenameHelper.matchesType(context,{ name : object, pos : use.pos.start, defineType : use.defineType},firstParamType).then(function(matches) {
							if(matches) {
								refactor_rename_RenameHelper.replaceTextWithPrefix(use,"" + object + ".",context.what.toName,changelist);
							}
						}));
					}
					return Promise.all(innerChanges).then(null);
				}));
			}
		}
		return Promise.all(changes).then(null);
	}
	static replaceSingleAccessOrCall(context,changelist,use,fromName,types) {
		let name = use.name;
		let index = name.lastIndexOf("." + fromName);
		if(index < 0) {
			let _g = use.type;
			if(_g._hx_index == 30) {
				return refactor_rename_RenameHelper.replaceArrayAccess(context,changelist,use,fromName,types,_g.posClosing);
			}
			return Promise.resolve(null);
		}
		name = HxOverrides.substr(name,0,index);
		return refactor_rename_RenameHelper.findTypeOfIdentifier(context,{ name : name, pos : use.pos.start, defineType : use.defineType}).then(function(typeHint) {
			if(typeHint != null) {
				switch(typeHint._hx_index) {
				case 0:
					let _gtype = typeHint.type;
					let _g = 0;
					while(_g < types.length) {
						if(types[_g++] != _gtype) {
							continue;
						}
						let pos = { fileName : use.pos.fileName, start : use.pos.start + name.length + 1, end : use.pos.end};
						pos.end = pos.start + fromName.length;
						changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,pos),use);
					}
					break;
				case 1:
					break;
				}
			}
		});
	}
	static replaceArrayAccess(context,changelist,use,fromName,types,posClosing) {
		return refactor_rename_RenameHelper.findTypeOfIdentifier(context,{ name : use.name, pos : posClosing, defineType : use.defineType}).then(function(typeHint) {
			if(typeHint != null) {
				switch(typeHint._hx_index) {
				case 0:
					let _gtype = typeHint.type;
					let _g = 0;
					while(_g < types.length) {
						if(types[_g++] != _gtype) {
							continue;
						}
						let pos = { fileName : use.pos.fileName, start : use.pos.start, end : use.pos.end};
						pos.end = pos.start + fromName.length;
						changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,pos),use);
					}
					break;
				case 1:
					break;
				}
			}
		});
	}
}
refactor_rename_RenameHelper.__name__ = "refactor.rename.RenameHelper";
var refactor_rename_TypeHintType = $hxEnums["refactor.rename.TypeHintType"] = { __ename__:true,__constructs__:null
	,KnownType: ($_=function(type,typeParams) { return {_hx_index:0,type:type,typeParams:typeParams,__enum__:"refactor.rename.TypeHintType",toString:$estr}; },$_._hx_name="KnownType",$_.__params__ = ["type","typeParams"],$_)
	,UnknownType: ($_=function(name,typeParams) { return {_hx_index:1,name:name,typeParams:typeParams,__enum__:"refactor.rename.TypeHintType",toString:$estr}; },$_._hx_name="UnknownType",$_.__params__ = ["name","typeParams"],$_)
};
refactor_rename_TypeHintType.__constructs__ = [refactor_rename_TypeHintType.KnownType,refactor_rename_TypeHintType.UnknownType];
class refactor_rename_RenameImportAlias {
	static refactorImportAlias(context,file,identifier) {
		let allUses = context.nameMap.getIdentifiers(identifier.name);
		let isImportHx = file.getMainModulName() == "import";
		let changelist = new refactor_edits_Changelist(context);
		let _g = 0;
		while(_g < allUses.length) {
			let use = allUses[_g];
			++_g;
			if(use.file.name == file.name) {
				changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,use.pos),use);
				continue;
			}
			if(isImportHx) {
				if(use.file.importHxFile.name == file.name) {
					changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,use.pos),use);
				}
			}
		}
		return Promise.resolve(changelist.execute());
	}
}
refactor_rename_RenameImportAlias.__name__ = "refactor.rename.RenameImportAlias";
class refactor_rename_RenameModuleLevelStatic {
	static refactorModuleLevelStatic(context,file,identifier) {
		let changelist = new refactor_edits_Changelist(context);
		let packageName = file.getPackage();
		let mainModulName = file.getMainModulName();
		let filesWithStaticImport = [];
		refactor_rename_RenameModuleLevelStatic.refactorIdentifier(context,changelist,"" + mainModulName + "." + identifier.name,"" + mainModulName + "." + context.what.toName,filesWithStaticImport);
		if(packageName.length > 0) {
			refactor_rename_RenameModuleLevelStatic.refactorIdentifier(context,changelist,"" + packageName + "." + mainModulName + "." + identifier.name,"" + packageName + "." + mainModulName + "." + context.what.toName,filesWithStaticImport);
		}
		let allUses = context.nameMap.getIdentifiers(identifier.name);
		let _g = 0;
		while(_g < allUses.length) {
			let use = allUses[_g];
			++_g;
			if(use.pos.fileName != file.name && !filesWithStaticImport.includes(use.pos.fileName)) {
				continue;
			}
			changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,use.pos),use);
		}
		allUses = context.nameMap.getIdentifiers("" + packageName + "." + mainModulName);
		let _g1 = 0;
		while(_g1 < allUses.length) {
			let use = allUses[_g1];
			++_g1;
			if(use.type._hx_index == 1) {
				let uses = use.file.findAllIdentifiers(function(i) {
					return i.name == identifier.name;
				});
				let _g = 0;
				while(_g < uses.length) {
					let u = uses[_g];
					++_g;
					let _g1 = u.type;
					switch(_g1._hx_index) {
					case 29:
						if(_g1.isNew == false) {
							changelist.addChange(u.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,u.pos),u);
						}
						break;
					case 31:
						changelist.addChange(u.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,u.pos),u);
						break;
					case 33:
						break;
					default:
					}
				}
			}
		}
		return refactor_rename_RenameHelper.replaceStaticExtension(context,changelist,identifier).then(function(_) {
			return changelist.execute();
		});
	}
	static refactorIdentifier(context,changelist,searchName,replaceName,filesWithStaticImport) {
		let allUses = context.nameMap.getIdentifiers(searchName);
		let _g = 0;
		while(_g < allUses.length) {
			let use = allUses[_g];
			++_g;
			if(use.type._hx_index == 1) {
				filesWithStaticImport.push(use.pos.fileName);
			}
			changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(replaceName,use.pos),use);
		}
		let searchNameDot = "" + searchName + ".";
		let replaceNameDot = "" + replaceName + ".";
		allUses = context.nameMap.getStartsWith(searchNameDot);
		let _g1 = 0;
		while(_g1 < allUses.length) {
			let use = allUses[_g1];
			++_g1;
			changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(replaceNameDot,{ fileName : use.pos.fileName, start : use.pos.start, end : use.pos.start + searchNameDot.length}),use);
		}
	}
}
refactor_rename_RenameModuleLevelStatic.__name__ = "refactor.rename.RenameModuleLevelStatic";
class refactor_rename_RenamePackage {
	static refactorPackageName(context,file,identifier) {
		let changelist = new refactor_edits_Changelist(context);
		let mainTypeName = file.getMainModulName();
		let packageNamePrefix = "";
		let packageName = file.getPackage();
		if(packageName.length > 0) {
			packageNamePrefix = file.packageIdentifier.name + ".";
			changelist.addChange(file.name,refactor_edits_FileEdit.ReplaceText(context.what.toName,file.packageIdentifier.pos),identifier);
		} else {
			changelist.addChange(file.name,refactor_edits_FileEdit.InsertText("package " + context.what.toName + ";\n",{ fileName : file.name, start : 0, end : 0}),identifier);
		}
		let newMainModulName = context.what.toName + "." + mainTypeName;
		let allUses = context.nameMap.getIdentifiers(packageNamePrefix + mainTypeName);
		let _g = 0;
		while(_g < allUses.length) {
			let use = allUses[_g];
			++_g;
			changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(newMainModulName,use.pos),use);
		}
		let _g1 = 0;
		let _g2 = file.typeList;
		while(_g1 < _g2.length) {
			let type = _g2[_g1];
			++_g1;
			if(mainTypeName == type.name.name) {
				continue;
			}
			let typeName = type.name.name;
			let fullModulName = packageNamePrefix + typeName;
			let newFullModulName = context.what.toName + "." + typeName;
			allUses = context.nameMap.getIdentifiers(fullModulName);
			let _g = 0;
			while(_g < allUses.length) {
				let use = allUses[_g];
				++_g;
				changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(newFullModulName,use.pos),use);
			}
			fullModulName = packageNamePrefix + mainTypeName + "." + typeName;
			newFullModulName = context.what.toName + "." + mainTypeName + "." + typeName;
			allUses = context.nameMap.getIdentifiers(fullModulName);
			let _g3 = 0;
			while(_g3 < allUses.length) {
				let use = allUses[_g3];
				++_g3;
				changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(newFullModulName,use.pos),use);
			}
		}
		let uniqueFiles = [];
		allUses = context.nameMap.getIdentifiers(mainTypeName);
		let _g3 = 0;
		while(_g3 < allUses.length) {
			let use = allUses[_g3];
			++_g3;
			if(use.file.name == file.name) {
				continue;
			}
			if(use.file.getPackage() != packageName) {
				continue;
			}
			if(uniqueFiles.includes(use.pos.fileName)) {
				continue;
			}
			switch(use.file.importsModule(packageName,mainTypeName,mainTypeName)._hx_index) {
			case 0:
				break;
			case 3:
				break;
			case 4:
				break;
			case 1:case 2:case 5:
				changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.InsertText("import " + newMainModulName + ";\n",{ fileName : use.pos.fileName, start : use.file.importInsertPos, end : use.file.importInsertPos}),use);
				uniqueFiles.push(use.pos.fileName);
				break;
			}
		}
		refactor_rename_RenamePackage.moveFileToPackage(context,file,changelist,packageName);
		return Promise.resolve(changelist.execute());
	}
	static moveFileToPackage(context,file,changelist,packageName) {
		let path = new haxe_io_Path(file.name);
		let mainTypeName = file.getMainModulName();
		let dotPath = StringTools.replace(StringTools.replace(path.dir,"/","."),"\\",".");
		let pathParts = context.what.toName.split(".");
		pathParts.unshift(haxe_io_Path.removeTrailingSlashes(haxe_io_Path.join(HxOverrides.substr(dotPath,0,dotPath.indexOf(packageName)).split("."))));
		pathParts.push("" + mainTypeName + ".hx");
		changelist.addChange(file.name,refactor_edits_FileEdit.Move(haxe_io_Path.join(pathParts)),null);
	}
}
refactor_rename_RenamePackage.__name__ = "refactor.rename.RenamePackage";
class refactor_rename_RenameScopedLocal {
	static refactorScopedLocal(context,file,identifier,scopeStart,scopeEnd) {
		let changelist = new refactor_edits_Changelist(context);
		let identifierDot = identifier.name + ".";
		let toNameDot = context.what.toName + ".";
		changelist.addChange(identifier.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,identifier.pos),identifier);
		let allUses = identifier.defineType.findAllIdentifiers(function(ident) {
			if(ident.pos.start < scopeStart) {
				return false;
			}
			if(ident.pos.start > scopeEnd) {
				return false;
			}
			if(ident.name == identifier.name) {
				return true;
			}
			if(ident.name.startsWith(identifierDot)) {
				return true;
			}
			return false;
		});
		let allShadows = identifier.defineType.findAllIdentifiers(function(ident) {
			if(ident.pos.start < scopeStart) {
				return false;
			}
			if(ident.pos.start > scopeEnd) {
				return false;
			}
			if(ident.name == context.what.toName) {
				return true;
			}
			if(ident.name.startsWith(toNameDot)) {
				return true;
			}
			return false;
		});
		let _g = 0;
		while(_g < allShadows.length) {
			let use = allShadows[_g];
			++_g;
			switch(use.type._hx_index) {
			case 29:
				changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.InsertText("this.",{ fileName : use.pos.fileName, start : use.pos.start, end : use.pos.start}),use);
				break;
			case 31:
				changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.InsertText("this.",{ fileName : use.pos.fileName, start : use.pos.start, end : use.pos.start}),use);
				break;
			case 33:
				return Promise.reject("local var \"" + context.what.toName + "\" exists");
			default:
			}
		}
		let skipForIterator = false;
		let innerScopeStart = 0;
		let innerScopeEnd = -1;
		let _g1 = 0;
		while(_g1 < allUses.length) {
			let use = allUses[_g1];
			++_g1;
			if(innerScopeStart < use.pos.start && use.pos.start < innerScopeEnd) {
				continue;
			}
			let _g = use.type;
			switch(_g._hx_index) {
			case 22:
				continue;
			case 32:
				if(skipForIterator) {
					skipForIterator = false;
					continue;
				}
				break;
			case 33:
				let _gscopeStart = _g.scopeStart;
				if(use.pos.start == identifier.pos.start) {
					scopeStart = _gscopeStart;
					skipForIterator = true;
				} else {
					innerScopeStart = _gscopeStart;
					innerScopeEnd = _g.scopeEnd;
					continue;
				}
				break;
			default:
				if(use.pos.start < scopeStart) {
					continue;
				}
			}
			if(use.name == identifier.name) {
				changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,use.pos),use);
			} else {
				changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,{ fileName : use.pos.fileName, start : use.pos.start, end : use.pos.start + identifier.pos.end - identifier.pos.start}),use);
			}
		}
		return Promise.resolve(changelist.execute());
	}
}
refactor_rename_RenameScopedLocal.__name__ = "refactor.rename.RenameScopedLocal";
class refactor_rename_RenameTypeName {
	static refactorTypeName(context,file,identifier) {
		let changelist = new refactor_edits_Changelist(context);
		let packName = file.getPackage();
		let mainModuleName = file.getMainModulName();
		let path = new haxe_io_Path(file.name);
		if(mainModuleName == identifier.name) {
			let newFileName = haxe_io_Path.join([path.dir,context.what.toName]) + "." + path.ext;
			changelist.addChange(file.name,refactor_edits_FileEdit.Move(newFileName),null);
		}
		changelist.addChange(identifier.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,identifier.pos),identifier);
		let allUses;
		if(file.packageIdentifier != null) {
			let fullName = identifier.defineType.getFullModulName();
			let parts = fullName.split(".");
			parts.pop();
			let prefix = parts.join(".") + ".";
			allUses = context.nameMap.getIdentifiers(fullName);
			if(allUses != null) {
				let _g = 0;
				while(_g < allUses.length) refactor_rename_RenameHelper.replaceTextWithPrefix(allUses[_g++],prefix,context.what.toName,changelist);
			}
		}
		allUses = context.nameMap.matchIdentifierPart(identifier.name,true);
		let changes = [];
		let _g = 0;
		while(_g < allUses.length) {
			let use = allUses[_g];
			++_g;
			if(use.defineType == null) {
				continue;
			}
			let _g1 = use.file.importsModule(packName,mainModuleName,identifier.name);
			switch(_g1._hx_index) {
			case 0:
				continue;
			case 4:
				if(_g1.alias != identifier.name) {
					continue;
				}
				break;
			case 1:case 2:case 3:case 5:
				break;
			}
			changes.push(refactor_rename_RenameHelper.findTypeOfIdentifier(context,{ name : use.name, pos : use.pos.start, defineType : use.defineType}).then(function(typeHint) {
				if(typeHint != null) {
					switch(typeHint._hx_index) {
					case 0:
						if(typeHint.type != identifier.defineType) {
							return;
						}
						break;
					case 1:
						return;
					}
				}
				if(use.name == identifier.name) {
					changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,use.pos),use);
					return;
				}
				if(use.name.startsWith("" + identifier.name + ".")) {
					changelist.addChange(use.pos.fileName,refactor_edits_FileEdit.ReplaceText(context.what.toName,{ fileName : use.pos.fileName, start : use.pos.start, end : use.pos.start + identifier.name.length}),use);
				}
			}));
		}
		return Promise.all(changes).then(function(_) {
			return Promise.resolve(changelist.execute());
		});
	}
}
refactor_rename_RenameTypeName.__name__ = "refactor.rename.RenameTypeName";
class safety_SafetyException extends haxe_Exception {
	constructor(message,previous,native) {
		super(message,previous,native);
		this.__skipStack++;
	}
}
safety_SafetyException.__name__ = "safety.SafetyException";
safety_SafetyException.__super__ = haxe_Exception;
Object.assign(safety_SafetyException.prototype, {
	__class__: safety_SafetyException
});
class safety_NullPointerException extends safety_SafetyException {
	constructor(message,previous,native) {
		super(message,previous,native);
		this.__skipStack++;
	}
}
safety_NullPointerException.__name__ = "safety.NullPointerException";
safety_NullPointerException.__super__ = safety_SafetyException;
Object.assign(safety_NullPointerException.prototype, {
	__class__: safety_NullPointerException
});
class sys_FileSystem {
	static exists(path) {
		try {
			js_node_Fs.accessSync(path);
			return true;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			return false;
		}
	}
	static isDirectory(path) {
		try {
			return js_node_Fs.statSync(path).isDirectory();
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			return false;
		}
	}
	static createDirectory(path) {
		try {
			js_node_Fs.mkdirSync(path);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(_g1.code == "ENOENT") {
				sys_FileSystem.createDirectory(js_node_Path.dirname(path));
				js_node_Fs.mkdirSync(path);
			} else {
				let stat;
				try {
					stat = js_node_Fs.statSync(path);
				} catch( _g ) {
					throw _g1;
				}
				if(!stat.isDirectory()) {
					throw _g1;
				}
			}
		}
	}
}
sys_FileSystem.__name__ = "sys.FileSystem";
class sys_io_File {
	static copy(srcPath,dstPath) {
		let src = js_node_Fs.openSync(srcPath,"r");
		let stat = js_node_Fs.fstatSync(src);
		let dst = js_node_Fs.openSync(dstPath,"w",stat.mode);
		let bytesRead;
		let pos = 0;
		while(true) {
			bytesRead = js_node_Fs.readSync(src,sys_io_File.copyBuf,0,65536,pos);
			if(!(bytesRead > 0)) {
				break;
			}
			js_node_Fs.writeSync(dst,sys_io_File.copyBuf,0,bytesRead);
			pos += bytesRead;
		}
		js_node_Fs.closeSync(src);
		js_node_Fs.closeSync(dst);
	}
}
sys_io_File.__name__ = "sys.io.File";
class sys_io_FileOutput extends haxe_io_Output {
	constructor(fd) {
		super();
		this.fd = fd;
		this.pos = 0;
	}
	writeByte(b) {
		let buf = js_node_buffer_Buffer.alloc(1);
		buf[0] = b;
		js_node_Fs.writeSync(this.fd,buf,0,1,this.pos);
		this.pos++;
	}
	writeBytes(s,pos,len) {
		let data = s.b;
		let buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		let wrote = js_node_Fs.writeSync(this.fd,buf,pos,len,this.pos);
		this.pos += wrote;
		return wrote;
	}
	close() {
		js_node_Fs.closeSync(this.fd);
	}
}
sys_io_FileOutput.__name__ = "sys.io.FileOutput";
sys_io_FileOutput.__super__ = haxe_io_Output;
Object.assign(sys_io_FileOutput.prototype, {
	__class__: sys_io_FileOutput
});
class tokentree_ToTokenTreeDef {
	static _new(tok) {
		return tok;
	}
	static toTokenTreeDef(this1) {
		return this1;
	}
	static fromTokenDef(tok) {
		let tmp;
		switch(tok._hx_index) {
		case 0:
			tmp = tokentree_TokenTreeDef.Eof;
			break;
		case 1:
			let _gc = tok.c;
			switch(_gc._hx_index) {
			case 0:
				tmp = tokentree_TokenTreeDef.Const(haxeparser_Constant.CInt(_gc.v,_gc.s));
				break;
			case 1:
				tmp = tokentree_TokenTreeDef.Const(haxeparser_Constant.CFloat(_gc.f,_gc.s));
				break;
			case 2:
				tmp = tokentree_TokenTreeDef.Const(haxeparser_Constant.CString(_gc.s,_gc.kind));
				break;
			case 3:
				tmp = tokentree_TokenTreeDef.Const(haxeparser_Constant.CIdent(_gc.s));
				break;
			case 4:
				tmp = tokentree_TokenTreeDef.Const(haxeparser_Constant.CRegexp(_gc.r,_gc.opt));
				break;
			case 5:
				tmp = tokentree_TokenTreeDef.Const(haxeparser_Constant.CMarkup(_gc.s));
				break;
			}
			break;
		case 2:
			tmp = tokentree_TokenTreeDef.Kwd(tok.k);
			break;
		case 3:
			tmp = tokentree_TokenTreeDef.Comment(tok.s);
			break;
		case 4:
			tmp = tokentree_TokenTreeDef.CommentLine(tok.s);
			break;
		case 5:
			tmp = tokentree_TokenTreeDef.Binop(tok.op);
			break;
		case 6:
			tmp = tokentree_TokenTreeDef.Unop(tok.op);
			break;
		case 7:
			tmp = tokentree_TokenTreeDef.Semicolon;
			break;
		case 8:
			tmp = tokentree_TokenTreeDef.Comma;
			break;
		case 9:
			tmp = tokentree_TokenTreeDef.BrOpen;
			break;
		case 10:
			tmp = tokentree_TokenTreeDef.BrClose;
			break;
		case 11:
			tmp = tokentree_TokenTreeDef.BkOpen;
			break;
		case 12:
			tmp = tokentree_TokenTreeDef.BkClose;
			break;
		case 13:
			tmp = tokentree_TokenTreeDef.POpen;
			break;
		case 14:
			tmp = tokentree_TokenTreeDef.PClose;
			break;
		case 15:
			tmp = tokentree_TokenTreeDef.Dot;
			break;
		case 16:
			tmp = tokentree_TokenTreeDef.DblDot;
			break;
		case 17:
			tmp = tokentree_TokenTreeDef.QuestionDot;
			break;
		case 18:
			tmp = tokentree_TokenTreeDef.Arrow;
			break;
		case 19:
			tmp = tokentree_TokenTreeDef.IntInterval(tok.s);
			break;
		case 20:
			tmp = tokentree_TokenTreeDef.Sharp(tok.s);
			break;
		case 21:
			tmp = tokentree_TokenTreeDef.Question;
			break;
		case 22:
			tmp = tokentree_TokenTreeDef.At;
			break;
		case 23:
			tmp = tokentree_TokenTreeDef.Dollar(tok.s);
			break;
		case 24:
			tmp = tokentree_TokenTreeDef.Spread;
			break;
		}
		return tokentree_ToTokenTreeDef._new(tmp);
	}
}
var tokentree_TokenStreamMode = $hxEnums["tokentree.TokenStreamMode"] = { __ename__:true,__constructs__:null
	,Strict: {_hx_name:"Strict",_hx_index:0,__enum__:"tokentree.TokenStreamMode",toString:$estr}
	,Relaxed: {_hx_name:"Relaxed",_hx_index:1,__enum__:"tokentree.TokenStreamMode",toString:$estr}
};
tokentree_TokenStreamMode.__constructs__ = [tokentree_TokenStreamMode.Strict,tokentree_TokenStreamMode.Relaxed];
class tokentree_TokenStream {
	constructor(tokens,bytes) {
		this.tokens = tokens;
		this.bytes = bytes;
		this.sharpIfStack = [];
		this.tempStore = [];
		this.current = 0;
	}
	hasMore() {
		return this.current < this.tokens.length;
	}
	consumeToken() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.CommentLine("auto insert"));
			}
		}
		let token = this.tokens[this.current];
		this.current++;
		return new tokentree_TokenTree(tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(token.tok)),"",token.pos,this.current - 1);
	}
	consumeConstIdent() {
		let _g = this.token();
		switch(_g._hx_index) {
		case 2:
			if(_g.c._hx_index == 3) {
				return this.consumeToken();
			} else {
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					let s = "bad token " + Std.string(this.token()) + " != Const(CIdent(_))";
					throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
				case 1:
					return this.createDummyToken(tokentree_TokenTreeDef.Const(haxeparser_Constant.CIdent("autoInsert")));
				}
			}
			break;
		case 4:
			return this.consumeToken();
		default:
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				let s1 = "bad token " + Std.string(this.token()) + " != Const(CIdent(_))";
				throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s1);
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.Const(haxeparser_Constant.CIdent("autoInsert")));
			}
		}
	}
	consumeConst() {
		if(this.token()._hx_index == 2) {
			return this.consumeToken();
		} else {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				let s = "bad token " + Std.string(this.token()) + " != Const(_)";
				throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.Const(haxeparser_Constant.CString("autoInsert")));
			}
		}
	}
	consumeTokenDef(tokenDef) {
		if(this.matches(tokenDef)) {
			return this.consumeToken();
		}
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			let s = "bad token " + Std.string(this.token()) + " != " + Std.string(tokenDef);
			throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
		case 1:
			return this.createDummyToken(tokenDef);
		}
	}
	consumeToTempStore() {
		this.tempStore.push(this.consumeToken());
	}
	addToTempStore(token) {
		this.tempStore.push(token);
	}
	applyTempStore(parent) {
		while(this.tempStore.length > 0) parent.addChild(this.tempStore.shift());
	}
	hasTempStore() {
		return this.tempStore.length > 0;
	}
	getTempStore() {
		return this.tempStore;
	}
	clearTempStore() {
		this.tempStore = [];
	}
	formatCurrentPos() {
		let pos = this.tokens[this.current].pos;
		return new hxparse_Position(pos.file,pos.min,pos.max).format(this.bytes);
	}
	matches(tokenDef) {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		return Type.enumEq(tokenDef,tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(this.tokens[this.current].tok)));
	}
	isSharp() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		if(this.tokens[this.current].tok._hx_index == 20) {
			return true;
		} else {
			return false;
		}
	}
	isTypedParam() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		let index = this.current + 1;
		let token = this.tokens[this.current];
		let _g = token.tok;
		if(_g._hx_index == 5) {
			if(_g.op._hx_index != 9) {
				return false;
			}
		} else {
			return false;
		}
		let depth = 1;
		let brDepth = 0;
		let bkDepth = 0;
		let pDepth = 0;
		while(true) {
			token = this.tokens[index++];
			let _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				break;
			case 5:
				switch(_g.op._hx_index) {
				case 7:
					if(pDepth > 0 || bkDepth > 0 || brDepth > 0) {
						continue;
					}
					--depth;
					if(depth <= 0) {
						return true;
					}
					break;
				case 9:
					if(pDepth > 0 || bkDepth > 0 || brDepth > 0) {
						continue;
					}
					++depth;
					break;
				default:
					return false;
				}
				break;
			case 9:
				++brDepth;
				break;
			case 10:
				if(brDepth <= 0) {
					return false;
				}
				--brDepth;
				break;
			case 11:
				++bkDepth;
				break;
			case 12:
				if(bkDepth <= 0) {
					return false;
				}
				--bkDepth;
				break;
			case 13:
				++pDepth;
				break;
			case 14:
				if(pDepth <= 0) {
					return false;
				}
				--pDepth;
				break;
			case 8:case 15:case 16:case 18:
				break;
			case 23:
				break;
			default:
				return false;
			}
			if(index >= this.tokens.length) {
				return false;
			}
		}
	}
	token() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return tokentree_TokenTreeDef.CommentLine("auto insert");
			}
		}
		return tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(this.tokens[this.current].tok));
	}
	tokenForMatch() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return tokentree_TokenTreeDef.Root;
		}
		return tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(this.tokens[this.current].tok));
	}
	peekNonCommentToken() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return tokentree_TokenTreeDef.Const(haxeparser_Constant.CString("auto insert"));
			}
		}
		let index = this.current;
		while(index < this.tokens.length) {
			let token = this.tokens[index++];
			if(haxeparser_Token == null) {
				continue;
			}
			switch(token.tok._hx_index) {
			case 3:
				break;
			case 4:
				break;
			default:
				return tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(token.tok));
			}
		}
		return tokentree_TokenTreeDef.Root;
	}
	getTokenPos() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return null;
		}
		return this.tokens[this.current].pos;
	}
	getStreamIndex() {
		return this.current;
	}
	rewindTo(pos) {
		this.current = pos;
	}
	consumeOpGt() {
		let tok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		let _g = this.token();
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 4:
				let assignTok = this.consumeToken();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGte),tok.space + assignTok.space,{ file : tok.pos.file, min : tok.pos.min, max : assignTok.pos.max},tok.index);
			case 7:
				return this.consumeOpShr(tok);
			default:
				return tok;
			}
		} else {
			return tok;
		}
	}
	consumeOpShr(parent) {
		let tok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		let _g = this.token();
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 4:
				let assignTok = this.consumeToken();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShr)),assignTok.space,{ file : parent.pos.file, min : parent.pos.min, max : assignTok.pos.max},parent.index);
			case 7:
				let innerGt = this.consumeToken();
				let _g1 = this.token();
				if(_g1._hx_index == 6) {
					if(_g1.op._hx_index == 4) {
						let assignTok = this.consumeToken();
						return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpUShr)),assignTok.space,{ file : parent.pos.file, min : parent.pos.min, max : assignTok.pos.max},parent.index);
					}
				}
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpUShr),innerGt.space,{ file : parent.pos.file, min : parent.pos.min, max : innerGt.pos.max},parent.index);
			default:
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShr),tok.space,{ file : parent.pos.file, min : parent.pos.min, max : tok.pos.max},parent.index);
			}
		} else {
			return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShr),tok.space,{ file : parent.pos.file, min : parent.pos.min, max : tok.pos.max},parent.index);
		}
	}
	consumeOpSub(parent) {
		let tok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpSub));
		let _g = this.token();
		if(_g._hx_index == 2) {
			switch(_g.c._hx_index) {
			case 0:
				break;
			case 1:
				break;
			default:
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
		} else {
			return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
		}
		let previous = this.current - 2;
		if(previous < 0) {
			throw haxe_Exception.thrown("no more tokens");
		}
		let _g1 = this.tokens[previous].tok;
		switch(_g1._hx_index) {
		case 2:
			switch(_g1.k._hx_index) {
			case 3:case 4:case 5:case 6:case 7:case 10:case 15:case 30:
				break;
			default:
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
			break;
		case 5:
			break;
		case 6:
			break;
		case 7:case 8:case 9:case 11:case 13:case 16:case 21:
			break;
		case 14:
			if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
			let _g2 = parent.tok;
			if(_g2._hx_index == 1) {
				switch(_g2.k._hx_index) {
				case 3:case 4:case 5:case 6:case 7:case 21:
					break;
				default:
					return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
				}
			} else {
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
			break;
		case 19:
			break;
		default:
			return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
		}
		let _g3 = this.token();
		if(_g3._hx_index == 2) {
			let _gc = _g3.c;
			switch(_gc._hx_index) {
			case 0:
				let $const = this.consumeConst();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Const(haxeparser_Constant.CInt("-" + _gc.v,_gc.s)),$const.space,{ file : tok.pos.file, min : tok.pos.min, max : $const.pos.max},tok.index);
			case 1:
				let const1 = this.consumeConst();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Const(haxeparser_Constant.CFloat("-" + _gc.f,_gc.s)),const1.space,{ file : tok.pos.file, min : tok.pos.min, max : const1.pos.max},tok.index);
			default:
				throw haxe_Exception.thrown("no more tokens");
			}
		} else {
			throw haxe_Exception.thrown("no more tokens");
		}
	}
	pushSharpIf(token) {
		this.sharpIfStack.push(token);
	}
	popSharpIf() {
		let token = this.sharpIfStack.pop();
		if(token == null) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.CommentLine("dummy token"));
			}
		}
		return token;
	}
	peekSharpIf() {
		if(this.sharpIfStack.length <= 0) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.CommentLine("dummy token"));
			}
		}
		return this.sharpIfStack[this.sharpIfStack.length - 1];
	}
	createDummyToken(tokDef) {
		let pos;
		if(this.tokens.length <= 0) {
			return new tokentree_TokenTree(tokDef,"",{ file : "<unknown>", min : 0, max : 0},-1,true);
		}
		if(this.current < 0 || this.current >= this.tokens.length) {
			let prevPos = this.tokens[this.tokens.length - 1].pos;
			pos = { min : prevPos.max, max : prevPos.max, file : prevPos.file};
		} else {
			let prevPos = this.tokens[this.current].pos;
			pos = { min : prevPos.min, max : prevPos.min, file : prevPos.file};
		}
		return new tokentree_TokenTree(tokDef,"",pos,-1,true);
	}
}
tokentree_TokenStream.__name__ = "tokentree.TokenStream";
Object.assign(tokentree_TokenStream.prototype, {
	__class__: tokentree_TokenStream
});
class tokentree_TokenStreamProgress {
	constructor(stream) {
		this.stream = stream;
		this.pos = -1;
	}
	streamHasChanged() {
		if(this.pos == -1) {
			this.pos = this.stream.getStreamIndex();
			return true;
		}
		let oldPos = this.pos;
		this.pos = this.stream.getStreamIndex();
		return this.pos != oldPos;
	}
}
tokentree_TokenStreamProgress.__name__ = "tokentree.TokenStreamProgress";
Object.assign(tokentree_TokenStreamProgress.prototype, {
	__class__: tokentree_TokenStreamProgress
});
class tokentree_TokenTree {
	constructor(tok,space,pos,index,inserted) {
		if(inserted == null) {
			inserted = false;
		}
		this.tok = tok;
		this.pos = pos;
		this.index = index;
		this.inserted = inserted;
		this.space = space;
		this.tokenTypeCache = { };
	}
	matches(tokenDef) {
		return Type.enumEq(tokenDef,this.tok);
	}
	isComment() {
		switch(this.tok._hx_index) {
		case 7:
			return true;
		case 8:
			return true;
		default:
			return false;
		}
	}
	isCIdent() {
		let _g = this.tok;
		if(_g._hx_index == 2) {
			if(_g.c._hx_index == 3) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	isCIdentOrCString() {
		let _g = this.tok;
		if(_g._hx_index == 2) {
			switch(_g.c._hx_index) {
			case 2:
				return true;
			case 3:
				return true;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	addChild(child) {
		if(child == null) {
			return;
		}
		if(this.children == null) {
			this.children = [];
		}
		if(this.children.length > 0) {
			child.previousSibling = this.children[this.children.length - 1];
			this.children[this.children.length - 1].nextSibling = child;
		}
		this.children.push(child);
		child.parent = this;
	}
	hasChildren() {
		if(this.children == null) {
			return false;
		}
		return this.children.length > 0;
	}
	getFirstChild() {
		if(!this.hasChildren()) {
			return null;
		}
		return this.children[0];
	}
	getLastChild() {
		if(!this.hasChildren()) {
			return null;
		}
		return this.children[this.children.length - 1];
	}
	getPos() {
		if(this.children == null || this.children.length <= 0) {
			return this.pos;
		}
		let fullPos = { file : this.pos.file, min : this.pos.min, max : this.pos.max};
		let childPos;
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			childPos = _g1[_g++].getPos();
			if(childPos.min < fullPos.min) {
				fullPos.min = childPos.min;
			}
			if(childPos.max > fullPos.max) {
				fullPos.max = childPos.max;
			}
		}
		return fullPos;
	}
	filter(searchFor,mode,maxLevel) {
		if(maxLevel == null) {
			maxLevel = 9999;
		}
		return this.filterCallback(function(token,depth) {
			if(depth > maxLevel) {
				return tokentree_FilterResult.SkipSubtree;
			}
			if(token.matchesAny(searchFor)) {
				if(mode == tokentree_TokenFilterMode.All) {
					return tokentree_FilterResult.FoundGoDeeper;
				}
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
	}
	filterCallback(callback) {
		let results = [];
		this.internalFilterCallback(callback,results,0);
		return results;
	}
	internalFilterCallback(callback,results,depth) {
		if(depth == null) {
			depth = 0;
		}
		if(this.tok._hx_index != 0) {
			switch(callback(this,depth)._hx_index) {
			case 0:
				results.push(this);
				return;
			case 1:
				results.push(this);
				break;
			case 2:
				return;
			case 3:
				break;
			}
		}
		if(this.children == null) {
			return;
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			if(child.tok._hx_index == 3) {
				child.internalFilterCallback(callback,results,depth);
			} else {
				child.internalFilterCallback(callback,results,depth + 1);
			}
		}
	}
	matchesAny(searchFor) {
		if(searchFor == null || this.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		let _g = 0;
		while(_g < searchFor.length) if(Type.enumEq(this.tok,searchFor[_g++])) {
			return true;
		}
		return false;
	}
	toString() {
		return tokentree_TokenTreeDefPrinter.toString(this.tok);
	}
}
tokentree_TokenTree.__name__ = "tokentree.TokenTree";
Object.assign(tokentree_TokenTree.prototype, {
	__class__: tokentree_TokenTree
});
var tokentree_TokenFilterMode = $hxEnums["tokentree.TokenFilterMode"] = { __ename__:true,__constructs__:null
	,All: {_hx_name:"All",_hx_index:0,__enum__:"tokentree.TokenFilterMode",toString:$estr}
	,First: {_hx_name:"First",_hx_index:1,__enum__:"tokentree.TokenFilterMode",toString:$estr}
};
tokentree_TokenFilterMode.__constructs__ = [tokentree_TokenFilterMode.All,tokentree_TokenFilterMode.First];
var tokentree_FilterResult = $hxEnums["tokentree.FilterResult"] = { __ename__:true,__constructs__:null
	,FoundSkipSubtree: {_hx_name:"FoundSkipSubtree",_hx_index:0,__enum__:"tokentree.FilterResult",toString:$estr}
	,FoundGoDeeper: {_hx_name:"FoundGoDeeper",_hx_index:1,__enum__:"tokentree.FilterResult",toString:$estr}
	,SkipSubtree: {_hx_name:"SkipSubtree",_hx_index:2,__enum__:"tokentree.FilterResult",toString:$estr}
	,GoDeeper: {_hx_name:"GoDeeper",_hx_index:3,__enum__:"tokentree.FilterResult",toString:$estr}
};
tokentree_FilterResult.__constructs__ = [tokentree_FilterResult.FoundSkipSubtree,tokentree_FilterResult.FoundGoDeeper,tokentree_FilterResult.SkipSubtree,tokentree_FilterResult.GoDeeper];
class tokentree_TokenTreeAccessHelper {
	static parent(this1) {
		if(this1 != null) {
			return this1.parent;
		} else {
			return null;
		}
	}
	static findParent(this1,predicate) {
		let parent = tokentree_TokenTreeAccessHelper.parent(this1);
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			if(predicate(parent)) {
				return parent;
			}
			parent = tokentree_TokenTreeAccessHelper.parent(parent);
		}
		return null;
	}
	static previousSibling(this1) {
		if(this1 != null) {
			return this1.previousSibling;
		} else {
			return null;
		}
	}
	static firstChild(this1) {
		if(this1 != null) {
			return this1.getFirstChild();
		} else {
			return null;
		}
	}
	static lastChild(this1) {
		if(this1 != null) {
			return this1.getLastChild();
		} else {
			return null;
		}
	}
	static firstOf(this1,token) {
		if(this1 == null || this1.children == null) {
			return null;
		}
		let _g = 0;
		let _g1 = this1.children;
		while(_g < _g1.length) {
			let tok = _g1[_g];
			++_g;
			if(Type.enumEq(tok.tok,token)) {
				return tok;
			}
		}
		return null;
	}
	static lastOf(this1,token) {
		if(this1 == null || this1.children == null) {
			return null;
		}
		let found = null;
		let _g = 0;
		let _g1 = this1.children;
		while(_g < _g1.length) {
			let tok = _g1[_g];
			++_g;
			if(Type.enumEq(tok.tok,token)) {
				found = tok;
			}
		}
		return found;
	}
	static child(this1,index) {
		if(this1 != null && this1.children != null) {
			return this1.children[index];
		} else {
			return null;
		}
	}
	static matches(this1,tok) {
		if(this1 != null && Type.enumEq(this1.tok,tok)) {
			return this1;
		} else {
			return null;
		}
	}
	static isCIdent(this1) {
		if(this1 != null && this1.isCIdent()) {
			return this1;
		} else {
			return null;
		}
	}
}
class tokentree_TokenTreeBuilder {
	static buildTokenTree(tokens,bytes,entryPoint) {
		if(entryPoint == null) {
			entryPoint = tokentree_TokenTreeEntryPoint.TypeLevel;
		}
		return tokentree_TokenTreeBuilder.buildTokenTreeFromStream(new tokentree_TokenStream(tokens,bytes),entryPoint);
	}
	static buildTokenTreeFromStream(stream,entryPoint) {
		let root = stream.createDummyToken(tokentree_TokenTreeDef.Root);
		switch(entryPoint._hx_index) {
		case 0:
			tokentree_walk_WalkFile.walkFile(stream,root);
			break;
		case 1:
			tokentree_walk_WalkClass.walkClassBody(stream,root);
			break;
		case 2:
			tokentree_walk_WalkStatement.walkStatement(stream,root);
			break;
		case 3:
			tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,root);
			break;
		}
		if(stream.hasMore()) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stream.token()));
			case 1:
				let progress = new tokentree_TokenStreamProgress(stream);
				while(progress.streamHasChanged()) tokentree_walk_WalkStatement.walkStatement(stream,root);
				if(stream.hasMore()) {
					throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stream.token()));
				}
				break;
			}
		}
		let tempStore = stream.getTempStore();
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			if(tempStore.length != 0) {
				throw haxe_Exception.thrown("invalid token tree structure - tokens in temp store:" + tempStore.join(", "));
			}
			break;
		case 1:
			let _g = 0;
			while(_g < tempStore.length) root.addChild(tempStore[_g++]);
			break;
		}
		return root;
	}
}
tokentree_TokenTreeBuilder.__name__ = "tokentree.TokenTreeBuilder";
var tokentree_TokenTreeEntryPoint = $hxEnums["tokentree.TokenTreeEntryPoint"] = { __ename__:true,__constructs__:null
	,TypeLevel: {_hx_name:"TypeLevel",_hx_index:0,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,FieldLevel: {_hx_name:"FieldLevel",_hx_index:1,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,ExpressionLevel: {_hx_name:"ExpressionLevel",_hx_index:2,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,TypeHintLevel: {_hx_name:"TypeHintLevel",_hx_index:3,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
};
tokentree_TokenTreeEntryPoint.__constructs__ = [tokentree_TokenTreeEntryPoint.TypeLevel,tokentree_TokenTreeEntryPoint.FieldLevel,tokentree_TokenTreeEntryPoint.ExpressionLevel,tokentree_TokenTreeEntryPoint.TypeHintLevel];
var tokentree_TokenTreeDef = $hxEnums["tokentree.TokenTreeDef"] = { __ename__:true,__constructs__:null
	,Root: {_hx_name:"Root",_hx_index:0,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Kwd: ($_=function(k) { return {_hx_index:1,k:k,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="Kwd",$_.__params__ = ["k"],$_)
	,Const: ($_=function(c) { return {_hx_index:2,c:c,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="Const",$_.__params__ = ["c"],$_)
	,Sharp: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="Sharp",$_.__params__ = ["s"],$_)
	,Dollar: ($_=function(s) { return {_hx_index:4,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="Dollar",$_.__params__ = ["s"],$_)
	,Unop: ($_=function(op) { return {_hx_index:5,op:op,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="Unop",$_.__params__ = ["op"],$_)
	,Binop: ($_=function(op) { return {_hx_index:6,op:op,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="Binop",$_.__params__ = ["op"],$_)
	,Comment: ($_=function(s) { return {_hx_index:7,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="Comment",$_.__params__ = ["s"],$_)
	,CommentLine: ($_=function(s) { return {_hx_index:8,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="CommentLine",$_.__params__ = ["s"],$_)
	,IntInterval: ($_=function(s) { return {_hx_index:9,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_._hx_name="IntInterval",$_.__params__ = ["s"],$_)
	,Semicolon: {_hx_name:"Semicolon",_hx_index:10,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Dot: {_hx_name:"Dot",_hx_index:11,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,DblDot: {_hx_name:"DblDot",_hx_index:12,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,QuestionDot: {_hx_name:"QuestionDot",_hx_index:13,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Arrow: {_hx_name:"Arrow",_hx_index:14,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Comma: {_hx_name:"Comma",_hx_index:15,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BkOpen: {_hx_name:"BkOpen",_hx_index:16,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BkClose: {_hx_name:"BkClose",_hx_index:17,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BrOpen: {_hx_name:"BrOpen",_hx_index:18,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BrClose: {_hx_name:"BrClose",_hx_index:19,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,POpen: {_hx_name:"POpen",_hx_index:20,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,PClose: {_hx_name:"PClose",_hx_index:21,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Question: {_hx_name:"Question",_hx_index:22,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,At: {_hx_name:"At",_hx_index:23,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Eof: {_hx_name:"Eof",_hx_index:24,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Spread: {_hx_name:"Spread",_hx_index:25,__enum__:"tokentree.TokenTreeDef",toString:$estr}
};
tokentree_TokenTreeDef.__constructs__ = [tokentree_TokenTreeDef.Root,tokentree_TokenTreeDef.Kwd,tokentree_TokenTreeDef.Const,tokentree_TokenTreeDef.Sharp,tokentree_TokenTreeDef.Dollar,tokentree_TokenTreeDef.Unop,tokentree_TokenTreeDef.Binop,tokentree_TokenTreeDef.Comment,tokentree_TokenTreeDef.CommentLine,tokentree_TokenTreeDef.IntInterval,tokentree_TokenTreeDef.Semicolon,tokentree_TokenTreeDef.Dot,tokentree_TokenTreeDef.DblDot,tokentree_TokenTreeDef.QuestionDot,tokentree_TokenTreeDef.Arrow,tokentree_TokenTreeDef.Comma,tokentree_TokenTreeDef.BkOpen,tokentree_TokenTreeDef.BkClose,tokentree_TokenTreeDef.BrOpen,tokentree_TokenTreeDef.BrClose,tokentree_TokenTreeDef.POpen,tokentree_TokenTreeDef.PClose,tokentree_TokenTreeDef.Question,tokentree_TokenTreeDef.At,tokentree_TokenTreeDef.Eof,tokentree_TokenTreeDef.Spread];
class tokentree_TokenTreeDefPrinter {
	static toString(def) {
		switch(def._hx_index) {
		case 0:
			return "<root>";
		case 1:
			let _gk = def.k;
			return HxOverrides.substr($hxEnums[_gk.__enum__].__constructs__[_gk._hx_index]._hx_name,3,null).toLowerCase();
		case 2:
			let _gc = def.c;
			switch(_gc._hx_index) {
			case 0:
				let _gv = _gc.v;
				let _gs = _gc.s;
				if(_gs == null) {
					return _gv;
				} else {
					return "" + _gv + _gs;
				}
				break;
			case 1:
				let _gf = _gc.f;
				let _gs1 = _gc.s;
				if(_gs1 == null) {
					return _gf;
				} else {
					return "" + _gf + _gs1;
				}
				break;
			case 2:
				return "\"" + _gc.s + "\"";
			case 3:
				return _gc.s;
			case 4:
				return "~/" + _gc.r + "/" + _gc.opt;
			case 5:
				return "" + _gc.s;
			}
			break;
		case 3:
			return "#" + def.s;
		case 4:
			return "$" + def.s;
		case 5:
			return new haxe_macro_Printer("").printUnop(def.op);
		case 6:
			return new haxe_macro_Printer("").printBinop(def.op);
		case 7:
			return "/*" + def.s + "*/";
		case 8:
			return "//" + def.s;
		case 9:
			return "" + def.s + "...";
		case 10:
			return ";";
		case 11:
			return ".";
		case 12:
			return ":";
		case 13:
			return "?.";
		case 14:
			return "->";
		case 15:
			return ",";
		case 16:
			return "[";
		case 17:
			return "]";
		case 18:
			return "{";
		case 19:
			return "}";
		case 20:
			return "(";
		case 21:
			return ")";
		case 22:
			return "?";
		case 23:
			return "@";
		case 24:
			return "<eof>";
		case 25:
			return "...";
		}
	}
}
tokentree_TokenTreeDefPrinter.__name__ = "tokentree.TokenTreeDefPrinter";
class tokentree_utils_FieldUtils {
	static getFieldType(field,defaultVisibility) {
		if(field == null) {
			return tokentree_utils_TokenFieldType.Unknown;
		}
		let _g = field.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 0:
				return tokentree_utils_FieldUtils.getFunctionFieldType(field,defaultVisibility);
			case 2:case 42:
				return tokentree_utils_FieldUtils.getVarFieldType(field,defaultVisibility);
			default:
			}
		}
		return tokentree_utils_TokenFieldType.Unknown;
	}
	static getFunctionFieldType(field,defaultVisibility) {
		let access = tokentree_TokenTreeAccessHelper.firstChild(field);
		if(access == null) {
			return tokentree_utils_TokenFieldType.Unknown;
		}
		let name = tokentree_utils_TokenTreeCheckUtils.getName(tokentree_utils_TokenTreeCheckUtils.getNameToken(field));
		let visibility = defaultVisibility;
		let isStatic = false;
		let isInline = false;
		let isOverride = false;
		let isFinal = false;
		let isExtern = false;
		if(access.children != null) {
			let _g = 0;
			let _g1 = access.children;
			_hx_loop1: while(_g < _g1.length) {
				let _g2 = _g1[_g++].tok;
				switch(_g2._hx_index) {
				case 1:
					switch(_g2.k._hx_index) {
					case 17:
						isStatic = true;
						break;
					case 18:
						visibility = tokentree_utils_TokenFieldVisibility.Public;
						break;
					case 19:
						visibility = tokentree_utils_TokenFieldVisibility.Private;
						break;
					case 25:
						isExtern = true;
						break;
					case 31:
						isOverride = true;
						break;
					case 35:
						isInline = true;
						break;
					case 42:
						isFinal = true;
						break;
					default:
					}
					break;
				case 18:case 20:
					break _hx_loop1;
				default:
				}
			}
		}
		return tokentree_utils_TokenFieldType.Function(name,visibility,isStatic,isInline,isOverride,isFinal,isExtern);
	}
	static getVarFieldType(field,defaultVisibility) {
		let access = tokentree_TokenTreeAccessHelper.firstChild(field);
		if(access == null) {
			return tokentree_utils_TokenFieldType.Unknown;
		}
		let name = tokentree_utils_TokenTreeCheckUtils.getName(tokentree_utils_TokenTreeCheckUtils.getNameToken(field));
		let visibility = defaultVisibility;
		let isStatic = false;
		let isInline = false;
		let _g = field.tok;
		let isFinal = _g._hx_index == 1 && _g.k._hx_index == 42;
		let isExtern = false;
		if(access.children != null) {
			let _g = 0;
			let _g1 = access.children;
			while(_g < _g1.length) {
				let _g2 = _g1[_g++].tok;
				if(_g2._hx_index == 1) {
					switch(_g2.k._hx_index) {
					case 17:
						isStatic = true;
						break;
					case 18:
						visibility = tokentree_utils_TokenFieldVisibility.Public;
						break;
					case 19:
						visibility = tokentree_utils_TokenFieldVisibility.Private;
						break;
					case 25:
						isExtern = true;
						break;
					case 35:
						isInline = true;
						break;
					default:
					}
				}
			}
		}
		access = tokentree_TokenTreeAccessHelper.firstOf(access,tokentree_TokenTreeDef.POpen);
		if(isFinal || access == null) {
			return tokentree_utils_TokenFieldType.Var(name,visibility,isStatic,isInline,isFinal,isExtern);
		}
		return tokentree_utils_TokenFieldType.Prop(name,visibility,isStatic,tokentree_utils_FieldUtils.makePropertyAccess(tokentree_TokenTreeAccessHelper.firstChild(access)),tokentree_utils_FieldUtils.makePropertyAccess(tokentree_TokenTreeAccessHelper.child(access,1)));
	}
	static makePropertyAccess(accessToken) {
		if(accessToken == null) {
			return tokentree_utils_TokenPropertyAccess.Default;
		}
		let _g = accessToken.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 16:
				return tokentree_utils_TokenPropertyAccess.Default;
			case 33:
				return tokentree_utils_TokenPropertyAccess.DynamicAccess;
			case 37:
				return tokentree_utils_TokenPropertyAccess.NullAccess;
			default:
				return tokentree_utils_TokenPropertyAccess.Default;
			}
			break;
		case 2:
			let _gc = _g.c;
			if(_gc._hx_index == 3) {
				switch(_gc.s) {
				case "get":
					return tokentree_utils_TokenPropertyAccess.Get;
				case "never":
					return tokentree_utils_TokenPropertyAccess.Never;
				case "set":
					return tokentree_utils_TokenPropertyAccess.Set;
				default:
					return tokentree_utils_TokenPropertyAccess.Default;
				}
			} else {
				return tokentree_utils_TokenPropertyAccess.Default;
			}
			break;
		default:
			return tokentree_utils_TokenPropertyAccess.Default;
		}
	}
	static isOperatorFunction(functionToken) {
		return Lambda.exists(tokentree_utils_TokenTreeCheckUtils.getMetadata(functionToken),function(meta) {
			let _g = meta.tok;
			if(_g._hx_index == 2) {
				let _gc = _g.c;
				if(_gc._hx_index == 3) {
					switch(_gc.s) {
					case "arrayAccess":
						return true;
					case "op":
						return true;
					case "resolve":
						return true;
					default:
						return false;
					}
				} else {
					return false;
				}
			} else {
				return false;
			}
		});
	}
}
tokentree_utils_FieldUtils.__name__ = "tokentree.utils.FieldUtils";
var tokentree_utils_TokenFieldType = $hxEnums["tokentree.utils.TokenFieldType"] = { __ename__:true,__constructs__:null
	,Function: ($_=function(name,visibility,isStatic,isInline,isOverride,isFinal,isExtern) { return {_hx_index:0,name:name,visibility:visibility,isStatic:isStatic,isInline:isInline,isOverride:isOverride,isFinal:isFinal,isExtern:isExtern,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}; },$_._hx_name="Function",$_.__params__ = ["name","visibility","isStatic","isInline","isOverride","isFinal","isExtern"],$_)
	,Var: ($_=function(name,visibility,isStatic,isInline,isFinal,isExtern) { return {_hx_index:1,name:name,visibility:visibility,isStatic:isStatic,isInline:isInline,isFinal:isFinal,isExtern:isExtern,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}; },$_._hx_name="Var",$_.__params__ = ["name","visibility","isStatic","isInline","isFinal","isExtern"],$_)
	,Prop: ($_=function(name,visibility,isStatic,getter,setter) { return {_hx_index:2,name:name,visibility:visibility,isStatic:isStatic,getter:getter,setter:setter,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}; },$_._hx_name="Prop",$_.__params__ = ["name","visibility","isStatic","getter","setter"],$_)
	,Unknown: {_hx_name:"Unknown",_hx_index:3,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}
};
tokentree_utils_TokenFieldType.__constructs__ = [tokentree_utils_TokenFieldType.Function,tokentree_utils_TokenFieldType.Var,tokentree_utils_TokenFieldType.Prop,tokentree_utils_TokenFieldType.Unknown];
var tokentree_utils_TokenFieldVisibility = $hxEnums["tokentree.utils.TokenFieldVisibility"] = { __ename__:true,__constructs__:null
	,Public: {_hx_name:"Public",_hx_index:0,__enum__:"tokentree.utils.TokenFieldVisibility",toString:$estr}
	,Private: {_hx_name:"Private",_hx_index:1,__enum__:"tokentree.utils.TokenFieldVisibility",toString:$estr}
};
tokentree_utils_TokenFieldVisibility.__constructs__ = [tokentree_utils_TokenFieldVisibility.Public,tokentree_utils_TokenFieldVisibility.Private];
var tokentree_utils_TokenPropertyAccess = $hxEnums["tokentree.utils.TokenPropertyAccess"] = { __ename__:true,__constructs__:null
	,Default: {_hx_name:"Default",_hx_index:0,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,NullAccess: {_hx_name:"NullAccess",_hx_index:1,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,Get: {_hx_name:"Get",_hx_index:2,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,Set: {_hx_name:"Set",_hx_index:3,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,DynamicAccess: {_hx_name:"DynamicAccess",_hx_index:4,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,Never: {_hx_name:"Never",_hx_index:5,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
};
tokentree_utils_TokenPropertyAccess.__constructs__ = [tokentree_utils_TokenPropertyAccess.Default,tokentree_utils_TokenPropertyAccess.NullAccess,tokentree_utils_TokenPropertyAccess.Get,tokentree_utils_TokenPropertyAccess.Set,tokentree_utils_TokenPropertyAccess.DynamicAccess,tokentree_utils_TokenPropertyAccess.Never];
class tokentree_utils_TokenTreeCheckUtils {
	static isImport(token) {
		let parent = token;
		while(parent != null) {
			if(parent.tok == tokentree_TokenTreeDef.Root) {
				return false;
			}
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 13:
					return true;
				case 25:
					break;
				case 27:
					break;
				case 36:
					return true;
				case 41:
					break;
				default:
					return false;
				}
				break;
			case 2:
				if(_g.c._hx_index != 3) {
					return false;
				}
				break;
			case 6:
				if(_g.op._hx_index != 23) {
					return false;
				}
				break;
			case 11:
				break;
			default:
				return false;
			}
			parent = parent.parent;
		}
		return false;
	}
	static isTypeParameter(token) {
		let _g = token.tok;
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 7:
				return tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt)) != null;
			case 9:
				return tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt)) != null;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	static isOpGtTypedefExtension(token) {
		let _g = token.tok;
		if(_g._hx_index == 6) {
			if(_g.op._hx_index == 7) {
				return tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.BrOpen)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign))))),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef)) != null;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	static filterOpSub(token) {
		if(token == null) {
			return false;
		}
		let _g = token.tok;
		if(!(_g._hx_index == 6 && _g.op._hx_index == 3)) {
			return false;
		}
		let prev = token.previousSibling;
		if(token.previousSibling == null) {
			prev = token.parent;
		} else {
			prev = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.previousSibling);
			if(prev == null) {
				return false;
			}
		}
		let _g1 = prev.tok;
		switch(_g1._hx_index) {
		case 1:
			switch(_g1.k._hx_index) {
			case 4:
				return true;
			case 5:
				return true;
			case 6:
				return true;
			case 10:
				return true;
			case 27:
				return true;
			default:
				return false;
			}
			break;
		case 6:
			if(_g1.op._hx_index == 23) {
				return true;
			} else {
				return true;
			}
			break;
		case 12:
			return true;
		case 14:
			return true;
		case 15:
			return true;
		case 16:
			return true;
		case 17:
			return false;
		case 18:
			return true;
		case 19:
			return true;
		case 20:
			return true;
		case 21:
			switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(prev.parent)._hx_index) {
			case 0:
				return true;
			case 1:
				return true;
			case 2:
				return false;
			case 3:
				return true;
			case 4:
				return true;
			case 5:
				return true;
			case 6:
				return true;
			case 7:
				return false;
			case 8:
				return true;
			case 9:
				return false;
			}
			break;
		case 22:
			return true;
		case 25:
			return true;
		default:
			return false;
		}
	}
	static isTernary(token) {
		while(true) {
			if(token == null) {
				return false;
			}
			if(token.tok._hx_index == 12) {
				token = token.parent;
				continue;
			}
			if(token.tok._hx_index != 22) {
				return false;
			}
			if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.DblDot) == null) {
				return false;
			}
			if(token.parent == null) {
				return false;
			}
			let _g = token.parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 2:
					return false;
				case 42:
					return false;
				default:
					return true;
				}
				break;
			case 3:
				return false;
			case 6:
				return true;
			case 15:
				return false;
			case 20:
				let prev = token.previousSibling;
				if(prev == null) {
					return false;
				}
				let lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(prev);
				if(lastToken == null) {
					return false;
				}
				switch(lastToken.tok._hx_index) {
				case 10:
					return false;
				case 15:
					return false;
				default:
					return true;
				}
				break;
			default:
				return true;
			}
		}
	}
	static isTypeEnumAbstract(type) {
		let _g = type.tok;
		if(_g._hx_index == 1) {
			if(_g.k._hx_index == 40) {
				let this1 = tokentree_TokenTreeAccessHelper.firstChild(type);
				if(this1 == null || this1.children == null || this1.children.length <= 0) {
					return false;
				}
				if(tokentree_TokenTreeAccessHelper.firstOf(this1,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdEnum)) != null) {
					return true;
				}
				let _g = 0;
				let _g1 = this1.children;
				while(_g < _g1.length) {
					let child = _g1[_g];
					++_g;
					if(child.tok._hx_index != 23) {
						continue;
					}
					if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(child),tokentree_TokenTreeDef.DblDot)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdEnum)) == null) {
						continue;
					}
					return true;
				}
			}
		}
		return false;
	}
	static isTypeStructure(typedefToken) {
		let afterAssign = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(typedefToken)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign)));
		if(tokentree_TokenTreeAccessHelper.matches(afterAssign,tokentree_TokenTreeDef.BrOpen) == null) {
			return tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.isCIdent(afterAssign),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAnd)) != null;
		} else {
			return true;
		}
	}
	static isTypeEnum(enumToken) {
		let _g = enumToken.tok;
		if(!(_g._hx_index == 1 && _g.k._hx_index == 26)) {
			return false;
		}
		if(tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract(enumToken)) {
			return false;
		}
		if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(enumToken),tokentree_TokenTreeDef.DblDot)),tokentree_TokenTreeDef.At) != null) {
			return false;
		}
		return true;
	}
	static isTypeMacroClass(classToken) {
		let _g = classToken.tok;
		if(_g._hx_index == 1 && _g.k._hx_index == 1) {
			return tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(classToken),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdMacro)) != null;
		} else {
			return false;
		}
	}
	static getName(token) {
		if(token == null) {
			return null;
		}
		let _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 22) {
				return "new";
			} else {
				return null;
			}
			break;
		case 2:
			let _gc = _g.c;
			if(_gc._hx_index == 3) {
				return _gc.s;
			} else {
				return null;
			}
			break;
		default:
			return null;
		}
	}
	static getNameToken(token) {
		if(tokentree_utils_TokenTreeCheckUtils.isNameToken(token)) {
			return token;
		}
		let nameToken = tokentree_TokenTreeAccessHelper.firstChild(token);
		if(tokentree_utils_TokenTreeCheckUtils.isNameToken(nameToken)) {
			return nameToken;
		}
		nameToken = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(nameToken,tokentree_TokenTreeDef.Question));
		if(tokentree_utils_TokenTreeCheckUtils.isNameToken(nameToken)) {
			return nameToken;
		}
		return null;
	}
	static isNameToken(token) {
		if(token == null) {
			return false;
		}
		let _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 22) {
				return true;
			} else {
				return false;
			}
			break;
		case 2:
			if(_g.c._hx_index == 3) {
				return true;
			} else {
				return false;
			}
			break;
		default:
			return false;
		}
	}
	static getMetadata(declToken) {
		let this1 = tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(declToken));
		if(this1 == null || !this1.hasChildren()) {
			return [];
		}
		let _this = this1.children;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(_this[i],tokentree_TokenTreeDef.At)),tokentree_TokenTreeDef.DblDot));
		}
		let _g2 = [];
		let _g3 = 0;
		while(_g3 < result.length) {
			let v = result[_g3];
			++_g3;
			if(v != null) {
				_g2.push(v);
			}
		}
		return _g2;
	}
	static getDocComment(declToken) {
		let access = declToken;
		while(true) {
			access = tokentree_TokenTreeAccessHelper.previousSibling(access);
			if(access == null) {
				return null;
			}
			switch(access.tok._hx_index) {
			case 7:
				return access;
			case 8:
				continue;
			default:
				return null;
			}
		}
	}
	static isModifier(keyword) {
		if(keyword == null) {
			return false;
		}
		let _g = keyword.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 17:
				return true;
			case 18:
				return true;
			case 19:
				return true;
			case 25:
				return true;
			case 31:
				return true;
			case 33:
				return true;
			case 35:
				return true;
			case 41:
				return true;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	static getBrOpenType(token) {
		if(token == null) {
			return tokentree_utils_BrOpenType.Unknown;
		}
		if(token.tokenTypeCache.brOpenType != null) {
			return token.tokenTypeCache.brOpenType;
		}
		let type = tokentree_utils_TokenTreeCheckUtils.determineBrOpenType(token);
		token.tokenTypeCache.brOpenType = type;
		return type;
	}
	static determineBrOpenType(token) {
		if(token == null) {
			return tokentree_utils_BrOpenType.Unknown;
		}
		if(token.parent == null || token.parent.tok == tokentree_TokenTreeDef.Root) {
			return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
		}
		let _g = token.parent.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 10) {
				return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
			}
			break;
		case 2:
			let _gc = _g.c;
			if(_gc._hx_index == 3) {
				switch(_gc.s) {
				case "from":case "to":
					return tokentree_utils_BrOpenType.AnonType;
				default:
					return tokentree_utils_BrOpenType.Block;
				}
			} else {
				return tokentree_utils_BrOpenType.Block;
			}
			break;
		case 4:
			return tokentree_utils_BrOpenType.Block;
		case 6:
			switch(_g.op._hx_index) {
			case 4:
				if(tokentree_utils_TokenTreeCheckUtils.isInsideTypedef(token.parent)) {
					return tokentree_utils_BrOpenType.TypedefDecl;
				}
				return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
			case 9:
				return tokentree_utils_BrOpenType.AnonType;
			default:
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
			break;
		case 12:
			if(tokentree_utils_TokenTreeCheckUtils.isTernary(token.parent)) {
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
			let parent = token.parent.parent;
			let _g1 = parent.tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 15:
					return tokentree_utils_BrOpenType.ObjectDecl;
				case 16:
					return tokentree_utils_BrOpenType.ObjectDecl;
				default:
					return tokentree_utils_BrOpenType.AnonType;
				}
				break;
			case 2:
				switch(_g1.c._hx_index) {
				case 2:
					break;
				case 3:
					break;
				default:
					return tokentree_utils_BrOpenType.AnonType;
				}
				break;
			default:
				return tokentree_utils_BrOpenType.AnonType;
			}
			parent = parent.parent;
			let _g2 = parent.tok;
			switch(_g2._hx_index) {
			case 1:
				switch(_g2.k._hx_index) {
				case 0:
					return tokentree_utils_BrOpenType.AnonType;
				case 2:
					return tokentree_utils_BrOpenType.AnonType;
				case 42:
					return tokentree_utils_BrOpenType.AnonType;
				default:
					return tokentree_utils_BrOpenType.ObjectDecl;
				}
				break;
			case 6:
				if(_g2.op._hx_index == 9) {
					return tokentree_utils_BrOpenType.AnonType;
				} else {
					return tokentree_utils_BrOpenType.ObjectDecl;
				}
				break;
			case 18:
				return tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent);
			case 20:
				return tokentree_utils_BrOpenType.AnonType;
			case 22:
				return tokentree_utils_BrOpenType.AnonType;
			default:
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
			break;
		case 16:
			return tokentree_utils_BrOpenType.ObjectDecl;
		case 20:
			switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(token.parent)._hx_index) {
			case 0:
				return tokentree_utils_BrOpenType.ObjectDecl;
			case 1:
				return tokentree_utils_BrOpenType.AnonType;
			case 2:
				return tokentree_utils_BrOpenType.ObjectDecl;
			case 3:
				return tokentree_utils_BrOpenType.Unknown;
			case 4:
				return tokentree_utils_BrOpenType.Unknown;
			case 5:
				return tokentree_utils_BrOpenType.Unknown;
			case 6:
				return tokentree_utils_BrOpenType.Unknown;
			case 7:
				return tokentree_utils_BrOpenType.Unknown;
			case 8:
				return tokentree_utils_BrOpenType.Unknown;
			case 9:
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
			break;
		case 22:
			if(tokentree_utils_TokenTreeCheckUtils.isTernary(token.parent)) {
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
			break;
		default:
		}
		return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
	}
	static determinBrChildren(token) {
		if(token.children == null || token.children.length <= 0) {
			if(token.parent.tok._hx_index == 1) {
				return tokentree_utils_BrOpenType.Block;
			} else {
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
		}
		if(token.parent != null && token.parent.tok != tokentree_TokenTreeDef.Root) {
			if(token.children.length == 1) {
				if(token.parent.tok._hx_index == 1) {
					return tokentree_utils_BrOpenType.Block;
				} else {
					return tokentree_utils_BrOpenType.ObjectDecl;
				}
			}
			if(token.children.length == 2 && token.getLastChild().tok._hx_index == 10) {
				if(token.parent.tok._hx_index == 1) {
					return tokentree_utils_BrOpenType.Block;
				} else {
					return tokentree_utils_BrOpenType.ObjectDecl;
				}
			}
		}
		if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Arrow) != null) {
			return tokentree_utils_BrOpenType.AnonType;
		}
		if(token.nextSibling != null && token.nextSibling.tok._hx_index == 14) {
			return tokentree_utils_BrOpenType.AnonType;
		}
		let onlyComment = true;
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			let _g2 = child.tok;
			switch(_g2._hx_index) {
			case 2:
				switch(_g2.c._hx_index) {
				case 2:
					if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(child),tokentree_TokenTreeDef.DblDot) == null) {
						return tokentree_utils_BrOpenType.Block;
					}
					onlyComment = false;
					break;
				case 3:
					if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(child),tokentree_TokenTreeDef.DblDot) == null) {
						return tokentree_utils_BrOpenType.Block;
					}
					onlyComment = false;
					break;
				default:
					return tokentree_utils_BrOpenType.Block;
				}
				break;
			case 3:
				break;
			case 7:
				break;
			case 8:
				break;
			case 19:
				if(onlyComment) {
					if(token.parent != null && token.parent.tok != tokentree_TokenTreeDef.Root) {
						if(token.parent.tok._hx_index == 1) {
							return tokentree_utils_BrOpenType.Block;
						} else {
							return tokentree_utils_BrOpenType.ObjectDecl;
						}
					} else {
						return tokentree_utils_BrOpenType.ObjectDecl;
					}
				}
				return tokentree_utils_BrOpenType.ObjectDecl;
			case 23:
				break;
			default:
				return tokentree_utils_BrOpenType.Block;
			}
		}
		return tokentree_utils_BrOpenType.ObjectDecl;
	}
	static getPOpenType(token) {
		while(true) {
			if(token == null) {
				return tokentree_utils_POpenType.Expression;
			}
			switch(token.tok._hx_index) {
			case 20:
				break;
			case 21:
				token = token.parent;
				continue;
			default:
				return tokentree_utils_POpenType.Expression;
			}
			if(token.tokenTypeCache.pOpenType != null) {
				return token.tokenTypeCache.pOpenType;
			}
			let type = tokentree_utils_TokenTreeCheckUtils.determinePOpenType(token);
			token.tokenTypeCache.pOpenType = type;
			return type;
		}
	}
	static determinePOpenType(token) {
		let parent = token.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return tokentree_utils_POpenType.Expression;
		}
		if(tokentree_utils_TokenTreeCheckUtils.hasAtParent(token)) {
			return tokentree_utils_POpenType.At;
		}
		if(token.hasChildren() && tokentree_utils_TokenTreeCheckUtils.checkPOpenForArrowChildren(token)) {
			return tokentree_utils_POpenType.Parameter;
		}
		_hx_loop1: while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 3:
				switch(_g.s) {
				case "elseif":case "if":
					if(parent.getFirstChild() == token) {
						return tokentree_utils_POpenType.SharpCondition;
					}
					parent = parent.parent;
					break;
				default:
					break _hx_loop1;
				}
				break;
			case 6:
				if(_g.op._hx_index == 9) {
					parent = parent.parent;
				} else {
					break _hx_loop1;
				}
				break;
			default:
				break _hx_loop1;
			}
		}
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return tokentree_utils_POpenType.Expression;
		}
		let _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return tokentree_utils_POpenType.Parameter;
			case 3:
				let firstChild = parent.getFirstChild();
				if(firstChild == null) {
					return tokentree_utils_POpenType.IfCondition;
				}
				if(firstChild.index == token.index) {
					return tokentree_utils_POpenType.IfCondition;
				}
				return tokentree_utils_POpenType.Expression;
			case 5:
				return tokentree_utils_POpenType.WhileCondition;
			case 7:
				return tokentree_utils_POpenType.ForLoop;
			case 14:
				return tokentree_utils_POpenType.SwitchCondition;
			case 21:
				return tokentree_utils_POpenType.Catch;
			case 22:
				return tokentree_utils_POpenType.Parameter;
			default:
			}
			break;
		case 2:
			if(_g.c._hx_index == 3) {
				if(parent.parent == null || parent.parent.tok == tokentree_TokenTreeDef.Root) {
					return tokentree_utils_POpenType.Call;
				}
				let _g = parent.parent.tok;
				switch(_g._hx_index) {
				case 1:
					switch(_g.k._hx_index) {
					case 0:
						if(parent.previousSibling == null) {
							let this1 = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.POpen);
							if(this1 == null) {
								return tokentree_utils_POpenType.Parameter;
							}
							if(this1.index == token.index) {
								return tokentree_utils_POpenType.Parameter;
							}
							return tokentree_utils_POpenType.Expression;
						}
						return tokentree_utils_POpenType.Call;
					case 40:
						return tokentree_utils_POpenType.Parameter;
					default:
						return tokentree_utils_POpenType.Call;
					}
					break;
				case 18:
					if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(parent.parent)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdEnum)) != null) {
						return tokentree_utils_POpenType.Parameter;
					}
					return tokentree_utils_POpenType.Call;
				default:
					return tokentree_utils_POpenType.Call;
				}
			}
			break;
		case 20:
			return tokentree_utils_POpenType.Expression;
		default:
		}
		if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Arrow) != null) {
			return tokentree_utils_POpenType.Parameter;
		}
		return tokentree_utils_POpenType.Expression;
	}
	static checkPOpenForArrowChildren(token) {
		let skip = true;
		let _g = 0;
		let _g1 = token.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			if(child.tok._hx_index == 21) {
				skip = false;
			}
			if(skip) {
				continue;
			}
			if(child.tok._hx_index == 14) {
				return true;
			}
		}
		return false;
	}
	static hasAtParent(token) {
		let parent = token.parent;
		while(parent.tok != tokentree_TokenTreeDef.Root) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				break;
			case 2:
				break;
			case 6:
				if(_g.op._hx_index != 23) {
					return false;
				}
				break;
			case 11:
				break;
			case 12:
				break;
			case 23:
				return true;
			default:
				return false;
			}
			parent = parent.parent;
		}
		return false;
	}
	static isInsideTypedef(token) {
		if(token == null) {
			return false;
		}
		let parent = token;
		while(parent.parent != null) {
			let _g = parent.tok;
			if(_g._hx_index == 1 && _g.k._hx_index == 32) {
				return true;
			}
			parent = parent.parent;
		}
		return false;
	}
	static isDeprecated(declToken) {
		return Lambda.exists(tokentree_utils_TokenTreeCheckUtils.getMetadata(declToken),function(meta) {
			let _g = meta.tok;
			if(_g._hx_index == 2) {
				let _gc = _g.c;
				if(_gc._hx_index == 3) {
					if(_gc.s == "deprecated") {
						return true;
					} else {
						return false;
					}
				} else {
					return false;
				}
			} else {
				return false;
			}
		});
	}
	static getArrowType(token) {
		if(token == null) {
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		if(token.tokenTypeCache.arrowType != null) {
			return token.tokenTypeCache.arrowType;
		}
		let type = tokentree_utils_TokenTreeCheckUtils.determineArrowType(token);
		if(type == null) {
			type = tokentree_utils_ArrowType.ArrowFunction;
		}
		token.tokenTypeCache.arrowType = type;
		return type;
	}
	static determineArrowType(token) {
		if(token == null) {
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		let child = token.getFirstChild();
		while(child != null) {
			let _g = child.tok;
			switch(_g._hx_index) {
			case 1:
				if(_g.k._hx_index != 41) {
					return tokentree_utils_ArrowType.ArrowFunction;
				}
				break;
			case 2:
				if(_g.c._hx_index != 3) {
					return tokentree_utils_ArrowType.ArrowFunction;
				}
				break;
			case 6:
				if(_g.op._hx_index == 9) {
					child = child.nextSibling;
					continue;
				} else {
					return tokentree_utils_ArrowType.ArrowFunction;
				}
				break;
			case 7:
				break;
			case 8:
				break;
			case 18:
				if(child.getFirstChild().tok._hx_index == 19) {
					return tokentree_utils_ArrowType.ArrowFunction;
				}
				let brType = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(child);
				if(brType == null) {
					brType = tokentree_utils_BrOpenType.Unknown;
				}
				if(brType != null) {
					switch(brType._hx_index) {
					case 0:
						return tokentree_utils_ArrowType.ArrowFunction;
					case 3:
						break;
					default:
					}
				}
				child = child.nextSibling;
				continue;
			case 20:
				break;
			case 10:case 11:case 14:case 22:
				break;
			default:
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			child = child.getFirstChild();
		}
		let parent = token.parent;
		if(parent == null) {
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		let resultType = tokentree_utils_TokenTreeCheckUtils.checkArrowParent(parent);
		if(resultType != null) {
			return resultType;
		}
		return tokentree_utils_TokenTreeCheckUtils.checkArrowChildren(parent);
	}
	static checkArrowChildren(parent) {
		let child = parent.getFirstChild();
		if(child == null) {
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		let seenArrow = false;
		while(child != null) {
			let _g = child.tok;
			switch(_g._hx_index) {
			case 1:
				return tokentree_utils_ArrowType.ArrowFunction;
			case 2:
				if(_g.c._hx_index != 3) {
					return tokentree_utils_ArrowType.NewFunctionType;
				}
				break;
			case 6:
				if(_g.op._hx_index == 9) {
					child = child.nextSibling;
					continue;
				} else {
					return tokentree_utils_ArrowType.NewFunctionType;
				}
				break;
			case 7:
				break;
			case 8:
				break;
			case 10:case 11:
				break;
			case 12:case 18:
				break;
			case 14:
				seenArrow = true;
				break;
			case 20:
				let result = tokentree_utils_TokenTreeCheckUtils.checkArrowPOpen(child);
				if(result != null) {
					return result;
				}
				child = child.nextSibling;
				continue;
			case 21:
				break;
			case 22:
				break;
			default:
				return tokentree_utils_ArrowType.NewFunctionType;
			}
			child = child.getFirstChild();
		}
		if(seenArrow) {
			return tokentree_utils_ArrowType.OldFunctionType;
		}
		return tokentree_utils_ArrowType.NewFunctionType;
	}
	static checkArrowPOpen(token) {
		if(token.children == null || token.children.length <= 1) {
			return null;
		}
		if(token.parent.isCIdent()) {
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		if(token.filterCallback(function(token,index) {
			if(token.tok._hx_index == 14) {
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		}).length <= 0) {
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		if(token.filterCallback(function(token,index) {
			if(token.tok._hx_index == 12) {
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		}).length > 0) {
			return tokentree_utils_ArrowType.NewFunctionType;
		}
		return tokentree_utils_ArrowType.OldFunctionType;
	}
	static checkArrowParent(parent) {
		if(parent == null) {
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		let _g = parent.tok;
		switch(_g._hx_index) {
		case 2:
			if(_g.c._hx_index == 3) {
				if(parent.parent == null || parent.parent.tok == tokentree_TokenTreeDef.Root) {
					return tokentree_utils_ArrowType.ArrowFunction;
				}
				let _g = parent.parent.tok;
				switch(_g._hx_index) {
				case 6:
					switch(_g.op._hx_index) {
					case 4:
						if(tokentree_utils_TokenTreeCheckUtils.isInsideTypedef(parent.parent)) {
							return tokentree_utils_ArrowType.OldFunctionType;
						}
						return tokentree_utils_ArrowType.ArrowFunction;
					case 22:
						return tokentree_utils_ArrowType.ArrowFunction;
					default:
					}
					break;
				case 12:
					switch(tokentree_utils_TokenTreeCheckUtils.getColonType(parent.parent)._hx_index) {
					case 1:
						return tokentree_utils_ArrowType.OldFunctionType;
					case 2:
						return tokentree_utils_ArrowType.OldFunctionType;
					case 0:case 3:case 4:case 5:case 6:
						return tokentree_utils_ArrowType.ArrowFunction;
					}
					break;
				case 14:
					return tokentree_utils_ArrowType.OldFunctionType;
				case 20:
					let type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(parent.parent);
					if(type == null) {
						type = tokentree_utils_POpenType.Expression;
					}
					switch(type._hx_index) {
					case 1:
						return tokentree_utils_ArrowType.OldFunctionType;
					case 9:
						return tokentree_utils_ArrowType.OldFunctionType;
					default:
						return tokentree_utils_ArrowType.ArrowFunction;
					}
					break;
				default:
				}
			} else {
				return tokentree_utils_ArrowType.OldFunctionType;
			}
			break;
		case 20:
			break;
		default:
			return tokentree_utils_ArrowType.OldFunctionType;
		}
		return null;
	}
	static getColonType(token) {
		if(token == null) {
			return tokentree_utils_ColonType.Unknown;
		}
		if(token.tokenTypeCache.colonType != null) {
			return token.tokenTypeCache.colonType;
		}
		let type = tokentree_utils_TokenTreeCheckUtils.determineColonType(token);
		token.tokenTypeCache.colonType = type;
		return type;
	}
	static determineColonType(token) {
		if(token == null) {
			return tokentree_utils_ColonType.Unknown;
		}
		if(tokentree_utils_TokenTreeCheckUtils.isTernary(token)) {
			return tokentree_utils_ColonType.Ternary;
		}
		let parent = token.parent;
		if(parent == null) {
			return tokentree_utils_ColonType.Unknown;
		}
		if(parent.tok._hx_index == 3) {
			parent = parent.parent;
			if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
				return tokentree_utils_ColonType.Unknown;
			}
		}
		let _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return tokentree_utils_ColonType.TypeHint;
			case 15:case 16:
				return tokentree_utils_ColonType.SwitchCase;
			case 22:
				return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
			case 23:
				return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
			case 41:
				return tokentree_utils_ColonType.TypeHint;
			default:
			}
			break;
		case 2:
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
		case 6:
			if(_g.op._hx_index == 9) {
				return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
			}
			break;
		case 18:
			let this1 = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.BrClose);
			if(this1 == null) {
				return tokentree_utils_ColonType.Unknown;
			}
			if(this1.pos.max <= token.pos.min) {
				return tokentree_utils_ColonType.TypeCheck;
			}
			break;
		case 20:
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(token);
		case 22:
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
		case 23:
			return tokentree_utils_ColonType.At;
		default:
		}
		return tokentree_utils_ColonType.Unknown;
	}
	static findColonParent(token) {
		let parent = token;
		while(parent.tok != tokentree_TokenTreeDef.Root) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 2:case 42:
					return tokentree_utils_ColonType.TypeHint;
				default:
				}
				break;
			case 18:
				switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent)._hx_index) {
				case 0:
					return tokentree_utils_ColonType.Unknown;
				case 1:
					return tokentree_utils_ColonType.TypeHint;
				case 2:
					return tokentree_utils_ColonType.ObjectLiteral;
				case 3:
					return tokentree_utils_ColonType.TypeHint;
				case 4:
					return tokentree_utils_ColonType.Unknown;
				}
				break;
			case 20:
				let this1 = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose);
				if(this1 != null && this1.pos.max <= token.pos.min) {
					return tokentree_utils_ColonType.TypeCheck;
				}
				switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(parent)._hx_index) {
				case 0:
					return tokentree_utils_ColonType.ObjectLiteral;
				case 1:
					return tokentree_utils_ColonType.TypeHint;
				case 2:
					return tokentree_utils_ColonType.Unknown;
				case 3:
					return tokentree_utils_ColonType.TypeCheck;
				case 4:
					return tokentree_utils_ColonType.Unknown;
				case 5:
					return tokentree_utils_ColonType.Unknown;
				case 6:
					return tokentree_utils_ColonType.Unknown;
				case 7:
					return tokentree_utils_ColonType.Unknown;
				case 8:
					return tokentree_utils_ColonType.TypeCheck;
				case 9:
					return tokentree_utils_ColonType.TypeCheck;
				}
				break;
			default:
			}
			parent = parent.parent;
		}
		return tokentree_utils_ColonType.Unknown;
	}
	static getLastToken(token) {
		if(token == null) {
			return null;
		}
		if(token.children == null) {
			return token;
		}
		if(token.children.length <= 0) {
			return token;
		}
		let lastChild = token.getLastChild();
		while(lastChild != null) {
			let newLast = lastChild.getLastChild();
			if(newLast == null) {
				return lastChild;
			}
			lastChild = newLast;
		}
		return null;
	}
	static isMetadata(token) {
		if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		let parent = token.parent;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) switch(parent.tok._hx_index) {
		case 12:
			parent = parent.parent;
			if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
				return false;
			}
			if(parent.tok._hx_index == 23) {
				return true;
			} else {
				return false;
			}
			break;
		case 23:
			return true;
		default:
			parent = parent.parent;
		}
		return false;
	}
}
tokentree_utils_TokenTreeCheckUtils.__name__ = "tokentree.utils.TokenTreeCheckUtils";
var tokentree_utils_BrOpenType = $hxEnums["tokentree.utils.BrOpenType"] = { __ename__:true,__constructs__:null
	,Block: {_hx_name:"Block",_hx_index:0,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,TypedefDecl: {_hx_name:"TypedefDecl",_hx_index:1,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,ObjectDecl: {_hx_name:"ObjectDecl",_hx_index:2,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,AnonType: {_hx_name:"AnonType",_hx_index:3,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,Unknown: {_hx_name:"Unknown",_hx_index:4,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
};
tokentree_utils_BrOpenType.__constructs__ = [tokentree_utils_BrOpenType.Block,tokentree_utils_BrOpenType.TypedefDecl,tokentree_utils_BrOpenType.ObjectDecl,tokentree_utils_BrOpenType.AnonType,tokentree_utils_BrOpenType.Unknown];
var tokentree_utils_POpenType = $hxEnums["tokentree.utils.POpenType"] = { __ename__:true,__constructs__:null
	,At: {_hx_name:"At",_hx_index:0,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Parameter: {_hx_name:"Parameter",_hx_index:1,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Call: {_hx_name:"Call",_hx_index:2,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,SwitchCondition: {_hx_name:"SwitchCondition",_hx_index:3,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,WhileCondition: {_hx_name:"WhileCondition",_hx_index:4,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,IfCondition: {_hx_name:"IfCondition",_hx_index:5,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,SharpCondition: {_hx_name:"SharpCondition",_hx_index:6,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Catch: {_hx_name:"Catch",_hx_index:7,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,ForLoop: {_hx_name:"ForLoop",_hx_index:8,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Expression: {_hx_name:"Expression",_hx_index:9,__enum__:"tokentree.utils.POpenType",toString:$estr}
};
tokentree_utils_POpenType.__constructs__ = [tokentree_utils_POpenType.At,tokentree_utils_POpenType.Parameter,tokentree_utils_POpenType.Call,tokentree_utils_POpenType.SwitchCondition,tokentree_utils_POpenType.WhileCondition,tokentree_utils_POpenType.IfCondition,tokentree_utils_POpenType.SharpCondition,tokentree_utils_POpenType.Catch,tokentree_utils_POpenType.ForLoop,tokentree_utils_POpenType.Expression];
var tokentree_utils_ArrowType = $hxEnums["tokentree.utils.ArrowType"] = { __ename__:true,__constructs__:null
	,ArrowFunction: {_hx_name:"ArrowFunction",_hx_index:0,__enum__:"tokentree.utils.ArrowType",toString:$estr}
	,OldFunctionType: {_hx_name:"OldFunctionType",_hx_index:1,__enum__:"tokentree.utils.ArrowType",toString:$estr}
	,NewFunctionType: {_hx_name:"NewFunctionType",_hx_index:2,__enum__:"tokentree.utils.ArrowType",toString:$estr}
};
tokentree_utils_ArrowType.__constructs__ = [tokentree_utils_ArrowType.ArrowFunction,tokentree_utils_ArrowType.OldFunctionType,tokentree_utils_ArrowType.NewFunctionType];
var tokentree_utils_ColonType = $hxEnums["tokentree.utils.ColonType"] = { __ename__:true,__constructs__:null
	,SwitchCase: {_hx_name:"SwitchCase",_hx_index:0,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,TypeHint: {_hx_name:"TypeHint",_hx_index:1,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,TypeCheck: {_hx_name:"TypeCheck",_hx_index:2,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,Ternary: {_hx_name:"Ternary",_hx_index:3,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,ObjectLiteral: {_hx_name:"ObjectLiteral",_hx_index:4,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,At: {_hx_name:"At",_hx_index:5,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,Unknown: {_hx_name:"Unknown",_hx_index:6,__enum__:"tokentree.utils.ColonType",toString:$estr}
};
tokentree_utils_ColonType.__constructs__ = [tokentree_utils_ColonType.SwitchCase,tokentree_utils_ColonType.TypeHint,tokentree_utils_ColonType.TypeCheck,tokentree_utils_ColonType.Ternary,tokentree_utils_ColonType.ObjectLiteral,tokentree_utils_ColonType.At,tokentree_utils_ColonType.Unknown];
class tokentree_walk_WalkAbstract {
	static walkAbstract(stream,parent) {
		let typeTok = stream.consumeToken();
		let _g = stream.token();
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 1:case 28:
				stream.addToTempStore(typeTok);
				tokentree_walk_WalkType.walkType(stream,parent);
				return;
			default:
			}
		}
		parent.addChild(typeTok);
		let name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
		stream.applyTempStore(name);
		if(stream.tokenForMatch()._hx_index == 20) {
			tokentree_walk_WalkPOpen.walkPOpen(stream,name);
		}
		let typeParent = name;
		let typeChild;
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 2:
				let _gc = _g.c;
				if(_gc._hx_index == 3) {
					switch(_gc.s) {
					case "from":case "to":
						let fromToken = stream.consumeToken();
						name.addChild(fromToken);
						tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,fromToken);
						break;
					default:
						typeChild = stream.consumeToken();
						typeParent.addChild(typeChild);
						typeParent = typeChild;
					}
				} else {
					typeChild = stream.consumeToken();
					typeParent.addChild(typeChild);
					typeParent = typeChild;
				}
				break;
			case 7:
				name.addChild(stream.consumeToken());
				break;
			case 8:
				name.addChild(stream.consumeToken());
				break;
			case 18:
				break _hx_loop1;
			default:
				typeChild = stream.consumeToken();
				typeParent.addChild(typeChild);
				typeParent = typeChild;
			}
		}
		let block = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
		name.addChild(block);
		tokentree_walk_WalkAbstract.walkAbstractBody(stream,block);
		block.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
	}
	static walkAbstractBody(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					tokentree_walk_WalkFunction.walkFunction(stream,parent);
					break;
				case 2:
					tokentree_walk_WalkVar.walkVar(stream,parent);
					break;
				case 42:
					tokentree_walk_WalkFinal.walkFinal(stream,parent);
					break;
				default:
					stream.consumeToTempStore();
				}
				break;
			case 3:
				tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkAbstract.walkAbstractBody);
				break;
			case 7:
				parent.addChild(stream.consumeToken());
				break;
			case 8:
				parent.addChild(stream.consumeToken());
				break;
			case 10:
				parent.addChild(stream.consumeToken());
				break;
			case 19:
				break _hx_loop1;
			case 23:
				stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
				break;
			default:
				stream.consumeToTempStore();
			}
		}
		stream.applyTempStore(parent);
	}
}
tokentree_walk_WalkAbstract.__name__ = "tokentree.walk.WalkAbstract";
class tokentree_walk_WalkArrayAccess {
	static walkArrayAccess(stream,parent) {
		let bkOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.BkOpen);
		parent.addChild(bkOpen);
		stream.applyTempStore(bkOpen);
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					tokentree_walk_WalkFunction.walkFunction(stream,bkOpen);
					break;
				case 5:
					stream.applyTempStore(bkOpen);
					tokentree_walk_WalkWhile.walkWhile(stream,bkOpen);
					break;
				case 7:
					stream.applyTempStore(bkOpen);
					tokentree_walk_WalkFor.walkFor(stream,bkOpen);
					break;
				default:
					stream.applyTempStore(bkOpen);
					tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
				}
				break;
			case 6:
				if(_g.op._hx_index == 22) {
					let child = bkOpen.getLastChild();
					if(child == null) {
						child = bkOpen;
					}
					tokentree_walk_WalkStatement.walkStatement(stream,child);
				} else {
					stream.applyTempStore(bkOpen);
					tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
				}
				break;
			case 15:
				let comma = stream.consumeToken();
				let child = bkOpen.getLastChild();
				if(child == null) {
					child = bkOpen;
				}
				child.addChild(comma);
				break;
			case 16:
				tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,bkOpen);
				break;
			case 17:
				break _hx_loop1;
			case 18:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkBlock.walkBlock(stream,bkOpen);
				break;
			case 20:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkPOpen.walkPOpen(stream,bkOpen);
				break;
			case 23:
				stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
				break;
			default:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
			}
		}
		bkOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BkClose));
		if(stream.hasMore()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 2:
				let _gc = _g.c;
				if(_gc._hx_index == 3) {
					if(_gc.s == "is") {
						tokentree_walk_WalkStatement.walkStatementContinue(stream,bkOpen);
					}
				}
				break;
			case 6:
				tokentree_walk_WalkStatement.walkStatementContinue(stream,bkOpen);
				break;
			case 11:case 16:
				tokentree_walk_WalkStatement.walkStatementContinue(stream,bkOpen);
				break;
			default:
			}
		}
	}
}
tokentree_walk_WalkArrayAccess.__name__ = "tokentree.walk.WalkArrayAccess";
class tokentree_walk_WalkAt {
	static walkAt(stream) {
		let atTok = stream.consumeTokenDef(tokentree_TokenTreeDef.At);
		let parent = atTok;
		if(stream.tokenForMatch()._hx_index == 12) {
			let dblDot = stream.consumeToken();
			atTok.addChild(dblDot);
			parent = dblDot;
		}
		tokentree_walk_WalkAt.walkIdent(stream,parent);
		return atTok;
	}
	static walkIdent(stream,parent) {
		while(true) {
			let ident;
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				ident = stream.consumeToken();
				break;
			case 2:
				if(_g.c._hx_index == 3) {
					ident = stream.consumeConstIdent();
				} else {
					return;
				}
				break;
			case 6:
				if(_g.op._hx_index == 23) {
					ident = stream.consumeToken();
				} else {
					return;
				}
				break;
			default:
				return;
			}
			parent.addChild(ident);
			switch(stream.token()._hx_index) {
			case 11:
				let child = stream.consumeToken();
				ident.addChild(child);
				parent = child;
				continue;
			case 20:
				let pOpenPos = stream.getTokenPos();
				if(ident.pos.max == pOpenPos.min) {
					let tempStore = stream.getTempStore();
					stream.clearTempStore();
					tokentree_walk_WalkPOpen.walkPOpen(stream,ident,false);
					let _g = 0;
					while(_g < tempStore.length) stream.addToTempStore(tempStore[_g++]);
				}
				break;
			default:
			}
			return;
		}
	}
	static walkAts(stream) {
		let progress = new tokentree_TokenStreamProgress(stream);
		while(progress.streamHasChanged()) if(stream.token()._hx_index == 23) {
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
		}
	}
}
tokentree_walk_WalkAt.__name__ = "tokentree.walk.WalkAt";
class tokentree_walk_WalkBinopSub {
	static walkBinopSub(stream,parent) {
		let sub = stream.consumeOpSub(parent);
		parent.addChild(sub);
		if(sub.tok._hx_index == 2) {
			tokentree_walk_WalkStatement.walkStatementContinue(stream,sub);
		} else {
			tokentree_walk_WalkStatement.walkStatement(stream,sub);
		}
	}
}
tokentree_walk_WalkBinopSub.__name__ = "tokentree.walk.WalkBinopSub";
class tokentree_walk_WalkBlock {
	static walkBlock(stream,parent) {
		while(stream.tokenForMatch()._hx_index == 23) stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
		if(stream.tokenForMatch()._hx_index == 18) {
			let openTok = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
			parent.addChild(openTok);
			stream.applyTempStore(openTok);
			tokentree_walk_WalkBlock.walkBlockContinue(stream,openTok);
			stream.applyTempStore(openTok);
		} else {
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
	static walkBlockContinue(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 15:case 16:
					tokentree_walk_WalkSwitch.walkSwitchCases(stream,parent);
					break;
				default:
					tokentree_walk_WalkStatement.walkStatement(stream,parent);
				}
				break;
			case 15:
				let child = stream.consumeToken();
				let lastChild = parent.getLastChild();
				if(lastChild == null) {
					parent.addChild(child);
				} else {
					lastChild.addChild(child);
				}
				break;
			case 19:
				break _hx_loop1;
			case 17:case 21:
				parent.addChild(stream.consumeToken());
				break;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
		}
		tokentree_walk_WalkBlock.walkBlockEnd(stream,parent);
	}
	static walkBlockEnd(stream,parent) {
		parent.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
		if(stream.hasMore()) {
			let _g = stream.token();
			if(_g._hx_index == 6) {
				if(_g.op._hx_index == 7) {
					return;
				}
			}
			tokentree_walk_WalkBlock.walkAfterBlock(stream,parent);
			if(stream.hasMore()) {
				if(stream.token()._hx_index == 10) {
					parent.addChild(stream.consumeToken());
				}
			}
		}
	}
	static walkAfterBlock(stream,parent) {
		if(!stream.hasMore()) {
			return;
		}
		let _g = stream.token();
		switch(_g._hx_index) {
		case 2:
			let _gc = _g.c;
			if(_gc._hx_index == 3) {
				if(_gc.s == "is") {
					tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
				}
			}
			break;
		case 5:
			if(parent.isCIdentOrCString()) {
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			}
			break;
		case 6:
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			break;
		case 7:
			let nextTokDef = stream.peekNonCommentToken();
			if(nextTokDef == null) {
				return;
			}
			if(nextTokDef != null) {
				switch(nextTokDef._hx_index) {
				case 5:
					tokentree_walk_WalkComment.walkComment(stream,parent);
					tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
					break;
				case 6:
					tokentree_walk_WalkComment.walkComment(stream,parent);
					tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
					break;
				case 11:case 12:case 22:
					tokentree_walk_WalkComment.walkComment(stream,parent);
					tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
					break;
				default:
				}
			}
			break;
		case 8:
			let nextTokDef1 = stream.peekNonCommentToken();
			if(nextTokDef1 == null) {
				return;
			}
			if(nextTokDef1 != null) {
				switch(nextTokDef1._hx_index) {
				case 5:
					tokentree_walk_WalkComment.walkComment(stream,parent);
					tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
					break;
				case 6:
					tokentree_walk_WalkComment.walkComment(stream,parent);
					tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
					break;
				case 11:case 12:case 22:
					tokentree_walk_WalkComment.walkComment(stream,parent);
					tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
					break;
				default:
				}
			}
			break;
		case 10:
			return;
		case 11:
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			break;
		case 12:
			tokentree_walk_WalkStatement.walkDblDot(stream,parent);
			break;
		case 14:
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			break;
		case 20:
			if(parent.parent.tok._hx_index == 4) {
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			}
			break;
		case 22:
			tokentree_walk_WalkQuestion.walkQuestion(stream,parent);
			break;
		default:
		}
	}
}
tokentree_walk_WalkBlock.__name__ = "tokentree.walk.WalkBlock";
class tokentree_walk_WalkClass {
	static walkClass(stream,parent) {
		let typeTok = stream.consumeToken();
		parent.addChild(typeTok);
		tokentree_walk_WalkComment.walkComment(stream,parent);
		let name = typeTok;
		let _g = stream.token();
		switch(_g._hx_index) {
		case 2:
			if(_g.c._hx_index == 3) {
				name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
				stream.applyTempStore(name);
			}
			break;
		case 4:
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
			stream.applyTempStore(name);
			break;
		default:
		}
		tokentree_walk_WalkClass.walkClassExtends(stream,name);
		let block = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
		name.addChild(block);
		tokentree_walk_WalkClass.walkClassBody(stream,block);
		block.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
	}
	static walkClassExtends(stream,name) {
		let progress = new tokentree_TokenStreamProgress(stream);
		while(progress.streamHasChanged()) {
			tokentree_walk_WalkExtends.walkExtends(stream,name);
			tokentree_walk_WalkImplements.walkImplements(stream,name);
			if(stream.isSharp()) {
				tokentree_walk_WalkSharp.walkSharp(stream,name,tokentree_walk_WalkClass.walkClassExtends);
			}
			tokentree_walk_WalkComment.walkComment(stream,name);
		}
	}
	static walkClassBody(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(stream.hasMore() && progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					tokentree_walk_WalkFunction.walkFunction(stream,parent);
					break;
				case 2:
					tokentree_walk_WalkVar.walkVar(stream,parent);
					break;
				case 42:
					tokentree_walk_WalkFinal.walkFinal(stream,parent);
					break;
				case 17:case 18:case 19:case 25:case 31:case 33:case 35:case 40:case 41:case 44:
					stream.consumeToTempStore();
					break;
				default:
					switch(tokentree_TokenStream.MODE._hx_index) {
					case 0:
						throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(stream.token())));
					case 1:
						tokentree_walk_WalkStatement.walkStatement(stream,parent);
						break;
					}
				}
				break;
			case 3:
				tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkClass.walkClassBody);
				tokentree_walk_WalkClass.walkClassContinueAfterSharp(stream,parent);
				break;
			case 7:
				if(stream.hasTempStore()) {
					stream.consumeToTempStore();
				} else {
					parent.addChild(stream.consumeToken());
				}
				break;
			case 8:
				if(stream.hasTempStore()) {
					stream.consumeToTempStore();
				} else {
					parent.addChild(stream.consumeToken());
				}
				break;
			case 10:
				parent.addChild(stream.consumeToken());
				break;
			case 19:
				break _hx_loop1;
			case 23:
				stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
				break;
			default:
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(stream.token())));
				case 1:
					tokentree_walk_WalkStatement.walkStatement(stream,parent);
					break;
				}
			}
		}
		let tempStore = stream.getTempStore();
		if(tempStore.length > 0) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(tempStore)));
			case 1:
				stream.applyTempStore(parent);
				break;
			}
		}
	}
	static walkClassContinueAfterSharp(stream,parent) {
		let brOpen = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.lastChild(tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.lastOf(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.lastChild(parent),tokentree_TokenTreeDef.Sharp("if")),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction)))),tokentree_TokenTreeDef.BrOpen);
		if(brOpen == null) {
			return;
		}
		if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.lastChild(brOpen),tokentree_TokenTreeDef.BrClose) != null) {
			return;
		}
		tokentree_walk_WalkBlock.walkBlockContinue(stream,parent);
	}
}
tokentree_walk_WalkClass.__name__ = "tokentree.walk.WalkClass";
class tokentree_walk_WalkComment {
	static walkComment(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		while(stream.hasMore() && progress.streamHasChanged()) switch(stream.token()._hx_index) {
		case 7:
			parent.addChild(stream.consumeToken());
			break;
		case 8:
			parent.addChild(stream.consumeToken());
			break;
		default:
			return;
		}
	}
	static tryWalkComment(stream,parent,expect) {
		let currentPos = stream.getStreamIndex();
		let progress = new tokentree_TokenStreamProgress(stream);
		let comments = [];
		while(stream.hasMore() && progress.streamHasChanged()) switch(stream.token()._hx_index) {
		case 7:
			comments.push(stream.consumeToken());
			break;
		case 8:
			comments.push(stream.consumeToken());
			break;
		default:
			if(stream.matches(expect)) {
				let _g = 0;
				while(_g < comments.length) parent.addChild(comments[_g++]);
				return;
			}
			stream.rewindTo(currentPos);
			return;
		}
	}
}
tokentree_walk_WalkComment.__name__ = "tokentree.walk.WalkComment";
class tokentree_walk_WalkDoWhile {
	static walkDoWhile(stream,parent) {
		let doTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDo));
		parent.addChild(doTok);
		stream.applyTempStore(doTok);
		tokentree_walk_WalkComment.walkComment(stream,doTok);
		tokentree_walk_WalkBlock.walkBlock(stream,doTok);
		let whileTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdWhile));
		doTok.addChild(whileTok);
		tokentree_walk_WalkStatement.walkStatement(stream,whileTok);
		tokentree_walk_WalkComment.walkComment(stream,whileTok);
		if(stream.tokenForMatch()._hx_index == 10) {
			whileTok.addChild(stream.consumeToken());
		}
	}
}
tokentree_walk_WalkDoWhile.__name__ = "tokentree.walk.WalkDoWhile";
class tokentree_walk_WalkEnum {
	static walkEnum(stream,parent) {
		let typeTok = stream.consumeToken();
		let _g = stream.tokenForMatch();
		if(_g._hx_index == 1 && _g.k._hx_index == 40) {
			stream.addToTempStore(typeTok);
			tokentree_walk_WalkAbstract.walkAbstract(stream,parent);
			return;
		}
		parent.addChild(typeTok);
		let name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
		stream.applyTempStore(name);
		tokentree_walk_WalkBlock.walkBlock(stream,name);
	}
}
tokentree_walk_WalkEnum.__name__ = "tokentree.walk.WalkEnum";
class tokentree_walk_WalkExtends {
	static walkExtends(stream,parent) {
		let _g = stream.tokenForMatch();
		if(!(_g._hx_index == 1 && _g.k._hx_index == 11)) {
			return;
		}
		let parentType = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdExtends));
		parent.addChild(parentType);
		tokentree_walk_WalkComment.walkComment(stream,parent);
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parentType);
		tokentree_walk_WalkComment.walkComment(stream,parent);
		tokentree_walk_WalkExtends.walkExtends(stream,parent);
		tokentree_walk_WalkComment.walkComment(stream,parent);
	}
}
tokentree_walk_WalkExtends.__name__ = "tokentree.walk.WalkExtends";
class tokentree_walk_WalkFieldDef {
	static walkFieldDef(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 2:case 42:
					let tok = stream.consumeToken();
					parent.addChild(tok);
					parent = tok;
					break;
				default:
					break _hx_loop1;
				}
				break;
			case 7:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				break;
			case 8:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				break;
			case 23:
				stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
				break;
			default:
				break _hx_loop1;
			}
		}
		let name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
		stream.applyTempStore(name);
		if(stream.tokenForMatch()._hx_index == 12) {
			let dblDot = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
			name.addChild(dblDot);
			tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,dblDot);
		}
		let _g = stream.tokenForMatch();
		if(_g._hx_index == 6 && _g.op._hx_index == 4) {
			tokentree_walk_WalkStatement.walkStatement(stream,name);
		}
		switch(stream.token()._hx_index) {
		case 10:
			name.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Semicolon));
			break;
		case 15:
			name.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Comma));
			break;
		default:
		}
	}
}
tokentree_walk_WalkFieldDef.__name__ = "tokentree.walk.WalkFieldDef";
class tokentree_walk_WalkFile {
	static walkFile(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		while(stream.hasMore() && progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					tokentree_walk_WalkFunction.walkFunction(stream,parent);
					break;
				case 2:
					tokentree_walk_WalkVar.walkVar(stream,parent);
					break;
				case 13:case 34:case 36:
					stream.applyTempStore(parent);
					tokentree_walk_WalkPackageImport.walkPackageImport(stream,parent);
					break;
				case 1:case 26:case 28:case 32:case 40:
					tokentree_walk_WalkType.walkType(stream,parent);
					break;
				case 42:
					tokentree_walk_WalkFinal.walkFinal(stream,parent);
					break;
				case 17:case 18:case 19:case 25:case 33:case 35:case 41:case 44:
					stream.consumeToTempStore();
					break;
				default:
					tokentree_walk_WalkBlock.walkBlock(stream,parent);
				}
				break;
			case 3:
				tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkFile.walkFile);
				if(!stream.hasMore()) {
					return;
				}
				if(stream.token()._hx_index == 18) {
					tokentree_walk_WalkBlock.walkBlock(stream,parent.children[parent.children.length - 1]);
				}
				break;
			case 7:
				if(stream.hasTempStore()) {
					stream.consumeToTempStore();
				} else {
					tokentree_walk_WalkComment.walkComment(stream,parent);
				}
				break;
			case 8:
				if(stream.hasTempStore()) {
					stream.consumeToTempStore();
				} else {
					tokentree_walk_WalkComment.walkComment(stream,parent);
				}
				break;
			case 10:case 15:case 17:case 19:case 21:
				parent.addChild(stream.consumeToken());
				break;
			case 23:
				stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
				break;
			default:
				tokentree_walk_WalkBlock.walkBlock(stream,parent);
			}
		}
		let tempStore = stream.getTempStore();
		let _g = 0;
		while(_g < tempStore.length) {
			let stored = tempStore[_g];
			++_g;
			let _g1 = stored.tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 18:case 19:case 25:
					switch(tokentree_TokenStream.MODE._hx_index) {
					case 0:
						throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stored));
					case 1:
						parent.addChild(stored);
						break;
					}
					break;
				default:
					parent.addChild(stored);
				}
				break;
			case 23:
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stored));
				case 1:
					parent.addChild(stored);
					break;
				}
				break;
			default:
				parent.addChild(stored);
			}
		}
	}
}
tokentree_walk_WalkFile.__name__ = "tokentree.walk.WalkFile";
class tokentree_walk_WalkFinal {
	static walkFinal(stream,parent) {
		let name = null;
		let finalTok = stream.consumeToken();
		stream.addToTempStore(finalTok);
		tokentree_walk_WalkComment.walkComment(stream,parent);
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					return;
				case 17:case 18:case 19:case 25:case 31:case 33:case 35:case 41:
					stream.consumeToTempStore();
					break;
				case 1:case 28:
					return;
				default:
				}
				break;
			case 2:
				if(_g.c._hx_index == 3) {
					break _hx_loop1;
				}
				break;
			case 7:
				stream.consumeToTempStore();
				break;
			case 8:
				stream.consumeToTempStore();
				break;
			default:
			}
		}
		parent.addChild(finalTok);
		let progress1 = new tokentree_TokenStreamProgress(stream);
		while(progress1.streamHasChanged()) {
			tokentree_walk_WalkComment.walkComment(stream,parent);
			if(stream.token()._hx_index == 23) {
				tokentree_walk_WalkAt.walkAts(stream);
			}
			tokentree_walk_WalkComment.walkComment(stream,parent);
			let nameParent = finalTok;
			if(stream.tokenForMatch()._hx_index == 22) {
				nameParent = stream.consumeToken();
				finalTok.addChild(nameParent);
			}
			name = stream.consumeConstIdent();
			nameParent.addChild(name);
			let tempStore = stream.getTempStore();
			let _g = 0;
			while(_g < tempStore.length) {
				let stored = tempStore[_g];
				++_g;
				let _g1 = stored.tok;
				if(_g1._hx_index == 1) {
					if(_g1.k._hx_index != 42) {
						name.addChild(stored);
					}
				} else {
					name.addChild(stored);
				}
			}
			stream.clearTempStore();
			tokentree_walk_WalkComment.walkComment(stream,name);
			if(stream.tokenForMatch()._hx_index == 20) {
				tokentree_walk_WalkPOpen.walkPOpen(stream,name);
			}
			if(stream.tokenForMatch()._hx_index == 12) {
				let dblDot = stream.consumeToken();
				name.addChild(dblDot);
				tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,dblDot);
			}
			let _g1 = stream.tokenForMatch();
			if(_g1._hx_index == 6 && _g1.op._hx_index == 4) {
				tokentree_walk_WalkStatement.walkStatement(stream,name);
			}
			if(stream.tokenForMatch()._hx_index == 15) {
				name.addChild(stream.consumeToken());
				continue;
			}
			break;
		}
		if(stream.tokenForMatch()._hx_index == 10) {
			name.addChild(stream.consumeToken());
		}
	}
}
tokentree_walk_WalkFinal.__name__ = "tokentree.walk.WalkFinal";
class tokentree_walk_WalkFor {
	static walkFor(stream,parent) {
		let forTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFor));
		parent.addChild(forTok);
		stream.applyTempStore(forTok);
		tokentree_walk_WalkComment.walkComment(stream,forTok);
		tokentree_walk_WalkFor.walkForPOpen(stream,forTok);
		tokentree_walk_WalkComment.walkComment(stream,forTok);
		tokentree_walk_WalkBlock.walkBlock(stream,forTok);
	}
	static walkForPOpen(stream,parent) {
		let pOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.POpen);
		parent.addChild(pOpen);
		tokentree_walk_WalkComment.walkComment(stream,pOpen);
		let identifier = null;
		if(stream.token()._hx_index == 4) {
			tokentree_walk_WalkStatement.walkStatement(stream,pOpen);
			identifier = pOpen.getLastChild();
		} else {
			identifier = stream.consumeConstIdent();
			pOpen.addChild(identifier);
		}
		tokentree_walk_WalkComment.walkComment(stream,identifier);
		let _g = stream.tokenForMatch();
		if(_g._hx_index == 6 && _g.op._hx_index == 22) {
			let arrowTok = stream.consumeToken();
			identifier.addChild(arrowTok);
			if(stream.token()._hx_index == 4) {
				tokentree_walk_WalkStatement.walkStatement(stream,arrowTok);
			} else {
				arrowTok.addChild(stream.consumeConstIdent());
			}
		}
		let inTok = null;
		let _g1 = stream.token();
		switch(_g1._hx_index) {
		case 1:
			if(_g1.k._hx_index == 27) {
				inTok = stream.consumeToken();
				identifier.addChild(inTok);
				tokentree_walk_WalkComment.walkComment(stream,inTok);
				tokentree_walk_WalkStatement.walkStatement(stream,inTok);
				tokentree_walk_WalkComment.walkComment(stream,pOpen);
				pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
				tokentree_walk_WalkComment.walkComment(stream,parent);
			}
			break;
		case 6:
			if(_g1.op._hx_index == 23) {
				inTok = stream.consumeToken();
				identifier.addChild(inTok);
				tokentree_walk_WalkComment.walkComment(stream,inTok);
				tokentree_walk_WalkStatement.walkStatement(stream,inTok);
				tokentree_walk_WalkComment.walkComment(stream,pOpen);
				pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
				tokentree_walk_WalkComment.walkComment(stream,parent);
			}
			break;
		case 21:
			pOpen.addChild(stream.consumeToken());
			tokentree_walk_WalkComment.walkComment(stream,parent);
			return;
		default:
		}
	}
}
tokentree_walk_WalkFor.__name__ = "tokentree.walk.WalkFor";
class tokentree_walk_WalkFunction {
	static walkFunction(stream,parent) {
		let funcTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction));
		parent.addChild(funcTok);
		tokentree_walk_WalkComment.walkComment(stream,funcTok);
		let name = funcTok;
		let _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 22) {
				name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
			} else {
				name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
			}
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				tokentree_walk_WalkLtGt.walkLtGt(stream,funcTok);
				name = funcTok.getLastChild();
			} else {
				name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
			}
			break;
		case 20:
			break;
		default:
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
		}
		stream.applyTempStore(name);
		tokentree_walk_WalkComment.walkComment(stream,name);
		tokentree_walk_WalkFunction.walkFunctionParameters(stream,name);
		tokentree_walk_WalkComment.walkComment(stream,name);
		if(stream.token()._hx_index == 3) {
			tokentree_walk_WalkSharp.walkSharp(stream,name,tokentree_walk_WalkStatement.walkStatement);
			switch(stream.token()._hx_index) {
			case 12:case 18:
				break;
			default:
				return;
			}
		}
		if(stream.tokenForMatch()._hx_index == 12) {
			let dblDot = stream.consumeToken();
			name.addChild(dblDot);
			tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dblDot);
		}
		tokentree_walk_WalkBlock.walkBlock(stream,name);
	}
	static walkFunctionParameters(stream,parent) {
		let pOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.POpen);
		parent.addChild(pOpen);
		let progress = new tokentree_TokenStreamProgress(stream);
		while(progress.streamHasChanged()) {
			tokentree_walk_WalkComment.walkComment(stream,pOpen);
			if(stream.tokenForMatch()._hx_index == 21) {
				break;
			}
			tokentree_walk_WalkFieldDef.walkFieldDef(stream,pOpen);
		}
		pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
	}
}
tokentree_walk_WalkFunction.__name__ = "tokentree.walk.WalkFunction";
class tokentree_walk_WalkIf {
	static walkIf(stream,parent) {
		let ifTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdIf));
		parent.addChild(ifTok);
		stream.applyTempStore(ifTok);
		tokentree_walk_WalkStatement.walkStatement(stream,ifTok);
		if(stream.tokenForMatch()._hx_index == 12) {
			return;
		}
		tokentree_walk_WalkBlock.walkBlock(stream,ifTok);
		tokentree_walk_WalkComment.tryWalkComment(stream,ifTok,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
		let _g = stream.tokenForMatch();
		if(_g._hx_index == 1 && _g.k._hx_index == 4) {
			let elseTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
			ifTok.addChild(elseTok);
			tokentree_walk_WalkBlock.walkBlock(stream,elseTok);
		}
	}
}
tokentree_walk_WalkIf.__name__ = "tokentree.walk.WalkIf";
class tokentree_walk_WalkImplements {
	static walkImplements(stream,parent) {
		let _g = stream.tokenForMatch();
		if(!(_g._hx_index == 1 && _g.k._hx_index == 12)) {
			return;
		}
		let interfacePart = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdImplements));
		parent.addChild(interfacePart);
		tokentree_walk_WalkComment.walkComment(stream,parent);
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,interfacePart);
		tokentree_walk_WalkComment.walkComment(stream,parent);
		tokentree_walk_WalkImplements.walkImplements(stream,parent);
		tokentree_walk_WalkComment.walkComment(stream,parent);
	}
}
tokentree_walk_WalkImplements.__name__ = "tokentree.walk.WalkImplements";
class tokentree_walk_WalkInterface {
	static walkInterface(stream,parent) {
		let typeTok = stream.consumeToken();
		parent.addChild(typeTok);
		let name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
		stream.applyTempStore(name);
		tokentree_walk_WalkClass.walkClassExtends(stream,name);
		let block = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
		name.addChild(block);
		tokentree_walk_WalkInterface.walkInterfaceBody(stream,block);
		block.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
	}
	static walkInterfaceBody(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					tokentree_walk_WalkFunction.walkFunction(stream,parent);
					break;
				case 2:
					tokentree_walk_WalkVar.walkVar(stream,parent);
					break;
				case 17:case 18:case 19:case 25:case 31:case 33:case 35:case 41:
					stream.consumeToTempStore();
					break;
				case 42:
					tokentree_walk_WalkFinal.walkFinal(stream,parent);
					break;
				default:
					stream.consumeToTempStore();
				}
				break;
			case 3:
				tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkInterface.walkInterfaceBody);
				break;
			case 7:
				if(stream.hasTempStore()) {
					stream.consumeToTempStore();
				} else {
					parent.addChild(stream.consumeToken());
				}
				break;
			case 8:
				if(stream.hasTempStore()) {
					stream.consumeToTempStore();
				} else {
					parent.addChild(stream.consumeToken());
				}
				break;
			case 10:
				parent.addChild(stream.consumeToken());
				break;
			case 19:
				break _hx_loop1;
			case 23:
				stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
				break;
			default:
				stream.consumeToTempStore();
			}
		}
		stream.applyTempStore(parent);
	}
}
tokentree_walk_WalkInterface.__name__ = "tokentree.walk.WalkInterface";
class tokentree_walk_WalkLtGt {
	static walkLtGt(stream,parent) {
		let ltTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt));
		parent.addChild(ltTok);
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 6:
				switch(_g.op._hx_index) {
				case 4:
					let equals = stream.consumeToken();
					ltTok.getLastChild().addChild(equals);
					tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,equals);
					break;
				case 7:
					break _hx_loop1;
				default:
					tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,ltTok);
				}
				break;
			case 12:
				let dblDot = stream.consumeToken();
				ltTok.addChild(dblDot);
				tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dblDot);
				break;
			case 15:
				ltTok.addChild(stream.consumeToken());
				tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,ltTok);
				break;
			case 20:
				tokentree_walk_WalkPOpen.walkPOpen(stream,ltTok);
				break;
			default:
				tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,ltTok);
			}
		}
		ltTok.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt)));
	}
}
tokentree_walk_WalkLtGt.__name__ = "tokentree.walk.WalkLtGt";
class tokentree_walk_WalkNew {
	static walkNew(stream,parent) {
		let newTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdNew));
		parent.addChild(newTok);
		let name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,newTok);
		let pOpen = null;
		tokentree_walk_WalkComment.walkComment(stream,name);
		switch(stream.token()._hx_index) {
		case 3:
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
			break;
		case 20:
			pOpen = tokentree_walk_WalkPOpen.walkPOpen(stream,name);
			break;
		default:
		}
		tokentree_walk_WalkComment.walkComment(stream,name);
		let _g = stream.token();
		switch(_g._hx_index) {
		case 2:
			let _gc = _g.c;
			if(_gc._hx_index == 3) {
				if(_gc.s == "is") {
					if(pOpen != null) {
						tokentree_walk_WalkStatement.walkStatement(stream,pOpen);
					} else {
						tokentree_walk_WalkStatement.walkStatement(stream,name);
					}
				}
			}
			break;
		case 6:
			if(pOpen != null) {
				tokentree_walk_WalkStatement.walkStatement(stream,pOpen);
			} else {
				tokentree_walk_WalkStatement.walkStatement(stream,name);
			}
			break;
		case 11:case 16:
			if(pOpen != null) {
				tokentree_walk_WalkStatement.walkStatement(stream,pOpen);
			} else {
				tokentree_walk_WalkStatement.walkStatement(stream,name);
			}
			break;
		default:
		}
	}
}
tokentree_walk_WalkNew.__name__ = "tokentree.walk.WalkNew";
class tokentree_walk_WalkPOpen {
	static walkPOpen(stream,parent,walkTrailingComments) {
		if(walkTrailingComments == null) {
			walkTrailingComments = true;
		}
		let pOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.POpen);
		parent.addChild(pOpen);
		tokentree_walk_WalkPOpen.walkPOpenParts(stream,pOpen);
		pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
		if(walkTrailingComments) {
			tokentree_walk_WalkComment.walkComment(stream,parent);
		}
		if(stream.hasMore()) {
			if(stream.token()._hx_index == 14) {
				let arrow = stream.consumeToken();
				pOpen.addChild(arrow);
				tokentree_walk_WalkBlock.walkBlock(stream,arrow);
			}
		}
		return pOpen;
	}
	static walkPOpenParts(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) switch(stream.token()._hx_index) {
		case 3:
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkPOpen.walkPOpenParts);
			break;
		case 15:
			let comma = stream.consumeToken();
			let child = parent.getLastChild();
			if(child == null) {
				child = parent;
			}
			child.addChild(comma);
			break;
		case 16:
			tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
			break;
		case 18:
			tokentree_walk_WalkBlock.walkBlock(stream,parent);
			break;
		case 21:
			break _hx_loop1;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
}
tokentree_walk_WalkPOpen.__name__ = "tokentree.walk.WalkPOpen";
class tokentree_walk_WalkPackageImport {
	static walkPackageImport(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		while(stream.hasMore() && progress.streamHasChanged()) switch(stream.token()._hx_index) {
		case 3:
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkPackageImport.walkPackageImport);
			break;
		case 10:
			parent.addChild(stream.consumeToken());
			return;
		default:
			let newChild = stream.consumeToken();
			parent.addChild(newChild);
			parent = newChild;
		}
	}
}
tokentree_walk_WalkPackageImport.__name__ = "tokentree.walk.WalkPackageImport";
class tokentree_walk_WalkQuestion {
	static walkQuestion(stream,parent) {
		if(!tokentree_walk_WalkQuestion.isTernary(stream,parent)) {
			tokentree_walk_WalkFieldDef.walkFieldDef(stream,parent);
			return;
		}
		let question = stream.consumeTokenDef(tokentree_TokenTreeDef.Question);
		parent.addChild(question);
		tokentree_walk_WalkComment.walkComment(stream,question);
		tokentree_walk_WalkStatement.walkStatement(stream,question);
		tokentree_walk_WalkComment.walkComment(stream,question);
		if(stream.tokenForMatch()._hx_index != 12) {
			return;
		}
		let dblDotTok = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
		question.addChild(dblDotTok);
		tokentree_walk_WalkStatement.walkStatement(stream,dblDotTok);
	}
	static isTernary(stream,parent) {
		let lastChild = parent.getLastChild();
		if(lastChild == null) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 23:
					return true;
				case 37:case 38:case 39:
					return true;
				default:
					return false;
				}
				break;
			case 2:
				return true;
			case 4:
				return true;
			case 21:
				return true;
			default:
				return false;
			}
		}
		let _g = lastChild.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return true;
			case 22:
				return true;
			case 23:case 29:
				return true;
			case 30:
				return true;
			case 37:case 38:case 39:
				return true;
			case 41:
				return lastChild.index + 1 != stream.getStreamIndex();
			default:
				return false;
			}
			break;
		case 2:
			return true;
		case 4:
			return true;
		case 5:
			return true;
		case 6:
			switch(_g.op._hx_index) {
			case 0:case 3:
				return true;
			default:
				return false;
			}
			break;
		case 12:
			return true;
		case 16:
			return true;
		case 18:
			return true;
		case 20:
			return true;
		case 21:
			return true;
		default:
			return false;
		}
	}
}
tokentree_walk_WalkQuestion.__name__ = "tokentree.walk.WalkQuestion";
class tokentree_walk_WalkSharp {
	static walkSharp(stream,parent,walker) {
		let _g = stream.token();
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "else":
				tokentree_walk_WalkSharp.walkSharpElse(stream,parent);
				break;
			case "elseif":
				tokentree_walk_WalkSharp.walkSharpElseIf(stream,parent);
				break;
			case "end":
				tokentree_walk_WalkSharp.walkSharpEnd(stream,parent);
				break;
			case "error":
				let errorToken = stream.consumeToken();
				parent.addChild(errorToken);
				let _g1 = stream.token();
				if(_g1._hx_index == 2) {
					if(_g1.c._hx_index == 2) {
						errorToken.addChild(stream.consumeToken());
					}
				}
				break;
			case "if":
				tokentree_walk_WalkSharp.walkSharpIf(stream,parent,walker);
				break;
			default:
				parent.addChild(stream.consumeToken());
			}
		}
	}
	static walkSharpIf(stream,parent,walker) {
		let ifToken = stream.consumeToken();
		parent.addChild(ifToken);
		tokentree_walk_WalkSharp.walkSharpIfExpr(stream,ifToken);
		stream.pushSharpIf(ifToken);
		let newParent = ifToken;
		let progress = new tokentree_TokenStreamProgress(stream);
		while(progress.streamHasChanged()) try {
			walker(stream,newParent);
			switch(stream.token()._hx_index) {
			case 15:case 19:case 21:
				newParent.addChild(stream.consumeToken());
				break;
			default:
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof tokentree_walk_SharpElseException)) {
				newParent = _g1.token;
			} else if(((_g1) instanceof tokentree_walk_SharpEndException)) {
				stream.popSharpIf();
				return;
			} else {
				throw _g;
			}
		}
	}
	static walkSharpElse(stream,parent) {
		let sharpIfParent = stream.peekSharpIf();
		let ifToken = stream.consumeToken();
		sharpIfParent.addChild(ifToken);
		stream.applyTempStore(sharpIfParent);
		throw haxe_Exception.thrown(new tokentree_walk_SharpElseException(ifToken));
	}
	static walkSharpElseIf(stream,parent) {
		let sharpIfParent = stream.peekSharpIf();
		let ifToken = stream.consumeToken();
		sharpIfParent.addChild(ifToken);
		stream.applyTempStore(sharpIfParent);
		tokentree_walk_WalkSharp.walkSharpIfExpr(stream,ifToken);
		throw haxe_Exception.thrown(new tokentree_walk_SharpElseException(ifToken));
	}
	static walkSharpEnd(stream,parent) {
		let sharpIfParent = stream.peekSharpIf();
		let endToken = stream.consumeToken();
		stream.applyTempStore(sharpIfParent);
		sharpIfParent.addChild(endToken);
		throw haxe_Exception.thrown(new tokentree_walk_SharpEndException());
	}
	static walkSharpIfExpr(stream,parent) {
		let childToken;
		let progress = new tokentree_TokenStreamProgress(stream);
		while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				childToken = stream.consumeToken();
				parent.addChild(childToken);
				if(!stream.hasMore()) {
					return;
				}
				if(stream.token()._hx_index != 11) {
					return;
				}
				let pos = stream.getTokenPos();
				if(pos == null) {
					return;
				}
				if(pos.min == childToken.pos.max + 1) {
					continue;
				}
				let dot = stream.consumeToken();
				childToken.addChild(dot);
				tokentree_walk_WalkSharp.walkSharpIfExpr(stream,dot);
				return;
			case 2:
				if(_g.c._hx_index == 3) {
					childToken = stream.consumeToken();
					parent.addChild(childToken);
					if(!stream.hasMore()) {
						return;
					}
					if(stream.token()._hx_index != 11) {
						return;
					}
					let pos = stream.getTokenPos();
					if(pos == null) {
						return;
					}
					if(pos.min == childToken.pos.max + 1) {
						continue;
					}
					let dot = stream.consumeToken();
					childToken.addChild(dot);
					tokentree_walk_WalkSharp.walkSharpIfExpr(stream,dot);
					return;
				} else {
					return;
				}
				break;
			case 5:
				if(_g.op._hx_index == 2) {
					childToken = stream.consumeToken();
					parent.addChild(childToken);
					tokentree_walk_WalkSharp.walkSharpIfExpr(stream,childToken);
					return;
				} else {
					return;
				}
				break;
			case 20:
				tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
				return;
			default:
				return;
			}
		}
	}
}
tokentree_walk_WalkSharp.__name__ = "tokentree.walk.WalkSharp";
class tokentree_walk_SharpElseException {
	constructor(token) {
		this.token = token;
	}
}
tokentree_walk_SharpElseException.__name__ = "tokentree.walk.SharpElseException";
Object.assign(tokentree_walk_SharpElseException.prototype, {
	__class__: tokentree_walk_SharpElseException
});
class tokentree_walk_SharpEndException {
	constructor() {
	}
}
tokentree_walk_SharpEndException.__name__ = "tokentree.walk.SharpEndException";
Object.assign(tokentree_walk_SharpEndException.prototype, {
	__class__: tokentree_walk_SharpEndException
});
class tokentree_walk_WalkStatement {
	static walkStatement(stream,parent) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		if(stream.tokenForMatch()._hx_index == 10) {
			let semicolon = stream.consumeToken();
			let lastChild;
			let _g = parent.tok;
			if(_g._hx_index == 6) {
				switch(_g.op._hx_index) {
				case 0:case 3:case 14:case 15:
					lastChild = parent.parent.getLastChild();
					break;
				default:
					lastChild = parent.getLastChild();
				}
			} else {
				lastChild = parent.getLastChild();
			}
			if(lastChild == null) {
				lastChild = parent;
			}
			switch(lastChild.tok._hx_index) {
			case 17:case 19:case 21:
				lastChild = parent;
				break;
			default:
			}
			lastChild.addChild(semicolon);
		}
	}
	static walkStatementWithoutSemicolon(stream,parent) {
		while(true) {
			tokentree_walk_WalkComment.walkComment(stream,parent);
			let wantMore = true;
			tokentree_walk_WalkAt.walkAts(stream);
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				if(tokentree_walk_WalkStatement.walkKeyword(stream,parent)) {
					wantMore = true;
				} else {
					return;
				}
				break;
			case 2:
				let _gc = _g.c;
				if(_gc._hx_index == 3) {
					switch(_gc.s) {
					case "final":
						if(tokentree_walk_WalkStatement.walkKeyword(stream,parent)) {
							wantMore = true;
						} else {
							return;
						}
						break;
					case "is":
						wantMore = true;
						break;
					default:
						wantMore = false;
					}
				} else {
					wantMore = false;
				}
				break;
			case 3:
				tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
				tokentree_walk_WalkStatement.walkStatementContinueAfterSharp(stream,parent);
				return;
			case 4:
				tokentree_walk_WalkStatement.walkDollarStatement(stream,parent);
				return;
			case 5:
				if(parent.isCIdentOrCString()) {
					let newChild = stream.consumeToken();
					parent.addChild(newChild);
					if(!stream.hasMore()) {
						return;
					}
					let _g = stream.token();
					switch(_g._hx_index) {
					case 2:
						let _gc = _g.c;
						if(_gc._hx_index == 3) {
							if(_gc.s == "is") {
								tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
							}
						}
						break;
					case 6:
						tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
						break;
					case 11:
						tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
						break;
					default:
					}
					return;
				}
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 3:
					tokentree_walk_WalkBinopSub.walkBinopSub(stream,parent);
					return;
				case 7:
					let gtTok = stream.consumeOpGt();
					parent.addChild(gtTok);
					parent = gtTok;
					continue;
				case 9:
					if(stream.isTypedParam()) {
						tokentree_walk_WalkLtGt.walkLtGt(stream,parent);
						if(stream.tokenForMatch()._hx_index == 14) {
							tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
						}
						if(stream.tokenForMatch()._hx_index == 20) {
							tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
						}
						return;
					}
					wantMore = true;
					break;
				case 12:
					if(parent.parent != null && parent.parent.tok != tokentree_TokenTreeDef.Root) {
						let _g = parent.parent.tok;
						if(_g._hx_index == 1) {
							if(_g.k._hx_index == 15) {
								parent.addChild(stream.consumeToken());
								parent = parent.parent;
								continue;
							}
						}
					}
					wantMore = true;
					break;
				default:
					wantMore = true;
				}
				break;
			case 9:
				wantMore = true;
				break;
			case 10:
				return;
			case 12:
				let _g1 = parent.tok;
				switch(_g1._hx_index) {
				case 1:
					if(_g1.k._hx_index == 41) {
						tokentree_walk_WalkStatement.walkDblDot(stream,parent);
						return;
					}
					break;
				case 11:
					return;
				default:
				}
				if(parent.tok._hx_index == 11) {
					return;
				}
				if(tokentree_walk_WalkQuestion.isTernary(stream,parent)) {
					tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
					return;
				}
				wantMore = true;
				break;
			case 11:case 13:
				wantMore = true;
				break;
			case 14:
				wantMore = true;
				break;
			case 15:
				return;
			case 16:
				tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				return;
			case 17:case 19:case 21:
				return;
			case 18:
				tokentree_walk_WalkBlock.walkBlock(stream,parent);
				return;
			case 20:
				tokentree_walk_WalkStatement.walkPOpen(stream,parent);
				return;
			case 22:
				tokentree_walk_WalkQuestion.walkQuestion(stream,parent);
				return;
			case 25:
				wantMore = true;
				break;
			default:
				wantMore = false;
			}
			let newChild = stream.consumeToken();
			parent.addChild(newChild);
			stream.applyTempStore(newChild);
			tokentree_walk_WalkStatement.walkTrailingComment(stream,newChild);
			if(wantMore) {
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
			}
			tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild);
			tokentree_walk_WalkStatement.walkTrailingComment(stream,newChild);
			return;
		}
	}
	static walkTrailingComment(stream,parent) {
		if(!stream.hasMore()) {
			return;
		}
		if(stream.token()._hx_index == 8) {
			let currentPos = stream.getStreamIndex();
			let commentTok = stream.consumeToken();
			let _g = stream.tokenForMatch();
			if(!(_g._hx_index == 1 && _g.k._hx_index == 4)) {
				stream.rewindTo(currentPos);
				return;
			}
			parent.addChild(commentTok);
		}
	}
	static walkStatementContinue(stream,parent) {
		while(true) {
			if(!stream.hasMore()) {
				return;
			}
			let _g = stream.token();
			switch(_g._hx_index) {
			case 2:
				let _gc = _g.c;
				if(_gc._hx_index == 3) {
					if(_gc.s == "is") {
						tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
					}
				}
				break;
			case 5:
				if(parent.isCIdentOrCString()) {
					tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
				}
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 0:case 3:
					tokentree_walk_WalkStatement.walkOpAdd(stream,parent);
					break;
				case 7:
					let ltParent = parent;
					_hx_loop2: while(true) {
						let _g = ltParent.tok;
						switch(_g._hx_index) {
						case 0:
							break _hx_loop2;
						case 2:
							ltParent = ltParent.parent;
							break;
						case 4:
							ltParent = ltParent.parent;
							break;
						case 6:
							switch(_g.op._hx_index) {
							case 7:
								ltParent = ltParent.parent;
								break;
							case 9:
								return;
							default:
								break _hx_loop2;
							}
							break;
						case 11:case 12:case 14:case 15:case 16:case 18:case 20:
							ltParent = ltParent.parent;
							break;
						default:
							break _hx_loop2;
						}
					}
					tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
					break;
				case 14:case 15:
					tokentree_walk_WalkStatement.walkOpBool(stream,parent);
					break;
				default:
					tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
				}
				break;
			case 7:
				let nextTokDef = stream.peekNonCommentToken();
				if(nextTokDef == null) {
					return;
				}
				if(nextTokDef != null) {
					switch(nextTokDef._hx_index) {
					case 5:
						tokentree_walk_WalkComment.walkComment(stream,parent);
						continue;
					case 6:
						tokentree_walk_WalkComment.walkComment(stream,parent);
						continue;
					case 11:case 12:case 22:
						tokentree_walk_WalkComment.walkComment(stream,parent);
						continue;
					default:
					}
				}
				break;
			case 8:
				let nextTokDef1 = stream.peekNonCommentToken();
				if(nextTokDef1 == null) {
					return;
				}
				if(nextTokDef1 != null) {
					switch(nextTokDef1._hx_index) {
					case 5:
						tokentree_walk_WalkComment.walkComment(stream,parent);
						continue;
					case 6:
						tokentree_walk_WalkComment.walkComment(stream,parent);
						continue;
					case 11:case 12:case 22:
						tokentree_walk_WalkComment.walkComment(stream,parent);
						continue;
					default:
					}
				}
				break;
			case 10:
				return;
			case 12:
				tokentree_walk_WalkStatement.walkDblDot(stream,parent);
				break;
			case 11:case 13:
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
				break;
			case 14:
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
				break;
			case 16:
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
				break;
			case 20:
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
				break;
			case 22:
				tokentree_walk_WalkQuestion.walkQuestion(stream,parent);
				break;
			case 25:
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
				break;
			default:
			}
			return;
		}
	}
	static walkKeyword(stream,parent) {
		let _g = stream.token();
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 1:
				tokentree_walk_WalkClass.walkClass(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			case 3:
				tokentree_walk_WalkIf.walkIf(stream,parent);
				break;
			case 5:
				let tmp;
				if(parent.tok._hx_index != 18) {
					let _g = parent.parent.tok;
					tmp = _g._hx_index == 1 && _g.k._hx_index == 6;
				} else {
					tmp = false;
				}
				if(tmp) {
					return false;
				}
				tokentree_walk_WalkWhile.walkWhile(stream,parent);
				break;
			case 6:
				tokentree_walk_WalkDoWhile.walkDoWhile(stream,parent);
				break;
			case 7:
				tokentree_walk_WalkFor.walkFor(stream,parent);
				break;
			case 10:case 41:
				return true;
			case 14:
				tokentree_walk_WalkSwitch.walkSwitch(stream,parent);
				break;
			case 15:
				return false;
			case 16:
				if(parent.tok._hx_index == 18) {
					return false;
				}
				return true;
			case 17:case 18:case 19:
				stream.addToTempStore(stream.consumeToken());
				return false;
			case 20:
				tokentree_walk_WalkTry.walkTry(stream,parent);
				break;
			case 22:
				if(parent.tok._hx_index == 11) {
					let newChild = stream.consumeToken();
					parent.addChild(newChild);
					tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild);
				} else {
					tokentree_walk_WalkNew.walkNew(stream,parent);
				}
				break;
			case 23:
				let newChild = stream.consumeToken();
				parent.addChild(newChild);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild);
				return false;
			case 30:
				let newChild1 = stream.consumeToken();
				parent.addChild(newChild1);
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild1);
				return false;
			case 35:
				return tokentree_walk_WalkStatement.walkInline(stream,parent);
			case 37:case 38:case 39:
				let newChild2 = stream.consumeToken();
				parent.addChild(newChild2);
				let _g1 = stream.token();
				switch(_g1._hx_index) {
				case 6:
					switch(_g1.op._hx_index) {
					case 14:case 15:
						tokentree_walk_WalkStatement.walkOpBool(stream,newChild2);
						break;
					default:
						tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild2);
					}
					break;
				case 22:
					tokentree_walk_WalkQuestion.walkQuestion(stream,newChild2);
					break;
				default:
				}
				return false;
			case 42:
				tokentree_walk_WalkFinal.walkFinal(stream,parent);
				break;
			default:
				return true;
			}
		} else {
			return true;
		}
		return false;
	}
	static walkInline(stream,parent) {
		stream.addToTempStore(stream.consumeToken());
		let _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				return false;
			case 22:
				return true;
			default:
				return false;
			}
			break;
		case 2:
			return true;
		default:
			return false;
		}
	}
	static walkDblDot(stream,parent) {
		if(tokentree_walk_WalkStatement.findQuestionParent(stream,parent) != null) {
			return;
		}
		let dblDotTok = stream.consumeToken();
		parent.addChild(dblDotTok);
		if(parent.isCIdentOrCString() && parent.parent.tok._hx_index == 18) {
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,dblDotTok);
			return;
		}
		let _g = stream.tokenForMatch();
		if(_g._hx_index == 1 && _g.k._hx_index == 22) {
			tokentree_walk_WalkNew.walkNew(stream,dblDotTok);
			return;
		}
		if(!tokentree_walk_WalkStatement.walkKeyword(stream,dblDotTok)) {
			return;
		}
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dblDotTok);
		let _g1 = stream.tokenForMatch();
		if(_g1._hx_index == 6 && _g1.op._hx_index == 4) {
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		}
		if(stream.tokenForMatch()._hx_index == 14) {
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		}
	}
	static walkPOpen(stream,parent) {
		let pOpen = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
		if(parent.tok == tokentree_TokenTreeDef.Root) {
			return;
		}
		if(parent.isCIdent()) {
			tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
		} else {
			let _g = parent.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 3:case 5:case 7:case 14:
					let _g1 = stream.token();
					switch(_g1._hx_index) {
					case 6:
						if(_g1.op._hx_index == 3) {
							return;
						}
						break;
					case 11:
						break;
					default:
						return;
					}
					break;
				default:
				}
			}
			tokentree_walk_WalkStatement.walkStatementContinue(stream,pOpen);
		}
	}
	static findQuestionParent(stream,token) {
		let parent = token;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 10:
					return parent;
				case 15:
					return parent;
				case 16:
					return parent;
				case 41:
					if(parent.index + 1 == stream.getStreamIndex()) {
						return null;
					}
					parent = tokentree_walk_WalkStatement.findQuestionParent(stream,parent.parent);
					if(parent == null) {
						return null;
					}
					let _g1 = parent.tok;
					switch(_g1._hx_index) {
					case 1:
						switch(_g1.k._hx_index) {
						case 15:case 16:
							return parent;
						default:
							return null;
						}
						break;
					case 22:
						return parent;
					default:
						return null;
					}
					break;
				default:
				}
				break;
			case 6:
				return parent;
			case 12:
				switch(tokentree_utils_TokenTreeCheckUtils.determineColonType(parent)._hx_index) {
				case 0:case 5:
					return null;
				case 1:case 2:case 3:case 4:case 6:
					break;
				}
				break;
			case 15:
				return null;
			case 18:
				if(tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.BrClose) == null) {
					return null;
				}
				break;
			case 20:
				if(tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose) == null) {
					return null;
				}
				break;
			case 22:
				if(tokentree_walk_WalkQuestion.isTernary(stream,parent)) {
					return parent;
				}
				return null;
			default:
			}
			parent = parent.parent;
		}
		return null;
	}
	static walkStatementContinueAfterSharp(stream,parent) {
		let _g = stream.token();
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 15:case 16:
				let lastChild = parent.getLastChild();
				if(lastChild == null) {
					lastChild = parent;
				}
				tokentree_walk_WalkSwitch.walkSwitchCases(stream,lastChild);
				break;
			default:
			}
		}
	}
	static walkOpBool(stream,token) {
		let parent = token.parent;
		_hx_loop1: while(parent.tok != tokentree_TokenTreeDef.Root) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					break _hx_loop1;
				case 14:case 15:case 16:
					break _hx_loop1;
				case 3:case 5:case 10:case 24:case 29:
					break _hx_loop1;
				default:
					token = parent;
					parent = parent.parent;
				}
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 4:
					break _hx_loop1;
				case 14:case 15:
					token = parent.parent;
					break _hx_loop1;
				case 20:
					break _hx_loop1;
				default:
					token = parent;
					parent = parent.parent;
				}
				break;
			case 12:
				token = parent;
				break _hx_loop1;
			case 20:
				if(token.tok._hx_index == 20) {
					token = parent;
				}
				break _hx_loop1;
			case 14:case 22:
				break _hx_loop1;
			default:
				token = parent;
				parent = parent.parent;
			}
		}
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,token);
	}
	static walkOpAdd(stream,token) {
		let parent = token.parent;
		_hx_loop1: while(parent.tok != tokentree_TokenTreeDef.Root) {
			let _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					break _hx_loop1;
				case 3:case 5:case 10:case 24:case 29:
					break _hx_loop1;
				default:
					token = parent;
					parent = parent.parent;
				}
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 1:case 2:
					token = parent;
					parent = parent.parent;
					break;
				case 0:case 3:
					token = parent.parent;
					break _hx_loop1;
				case 4:
					break _hx_loop1;
				case 20:
					break _hx_loop1;
				default:
					break _hx_loop1;
				}
				break;
			case 9:
				break _hx_loop1;
			case 12:
				break _hx_loop1;
			case 16:case 18:
				break _hx_loop1;
			case 20:
				if(tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose) == null) {
					token = parent;
					break _hx_loop1;
				}
				token = parent;
				parent = parent.parent;
				break;
			case 14:case 22:
				break _hx_loop1;
			default:
				token = parent;
				parent = parent.parent;
			}
		}
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,token);
	}
	static walkDollarStatement(stream,parent) {
		let dollarTok = stream.consumeToken();
		parent.addChild(dollarTok);
		let _g = stream.token();
		switch(_g._hx_index) {
		case 2:
			let _gc = _g.c;
			if(_gc._hx_index == 3) {
				if(_gc.s == "is") {
					tokentree_walk_WalkBlock.walkBlock(stream,dollarTok);
				}
			}
			break;
		case 6:
			tokentree_walk_WalkBlock.walkBlock(stream,dollarTok);
			break;
		case 11:case 16:case 18:case 20:
			tokentree_walk_WalkBlock.walkBlock(stream,dollarTok);
			break;
		default:
		}
	}
}
tokentree_walk_WalkStatement.__name__ = "tokentree.walk.WalkStatement";
class tokentree_walk_WalkSwitch {
	static walkSwitch(stream,parent) {
		let switchTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdSwitch));
		parent.addChild(switchTok);
		stream.applyTempStore(switchTok);
		tokentree_walk_WalkComment.walkComment(stream,switchTok);
		tokentree_walk_WalkStatement.walkStatement(stream,switchTok);
		tokentree_walk_WalkComment.walkComment(stream,switchTok);
		if(stream.token()._hx_index == 3) {
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
		}
		if(stream.tokenForMatch()._hx_index == 18) {
			let brOpen = stream.consumeToken();
			switchTok.addChild(brOpen);
			tokentree_walk_WalkSwitch.walkSwitchCases(stream,brOpen);
			brOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
		}
	}
	static walkSwitchCases(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 15:case 16:
					tokentree_walk_WalkSwitch.walkCase(stream,parent);
					break;
				default:
					tokentree_walk_WalkStatement.walkStatement(stream,parent);
				}
				break;
			case 3:
				tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
				break;
			case 7:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				break;
			case 8:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				break;
			case 19:
				break _hx_loop1;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
		}
	}
	static walkCase(stream,parent) {
		tokentree_walk_WalkComment.walkComment(stream,parent);
		let caseTok = stream.consumeToken();
		parent.addChild(caseTok);
		tokentree_walk_WalkSwitch.walkCaseExpr(stream,caseTok);
		let dblDot = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
		caseTok.addChild(dblDot);
		let progress = new tokentree_TokenStreamProgress(stream);
		while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 15:case 16:
					return;
				default:
					tokentree_walk_WalkStatement.walkStatement(stream,dblDot);
				}
				break;
			case 3:
				tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
				tokentree_walk_WalkSwitch.relocateSharpTree(parent,dblDot);
				break;
			case 7:
				let _g1 = stream.peekNonCommentToken();
				if(_g1 != null) {
					if(_g1._hx_index == 1) {
						switch(_g1.k._hx_index) {
						case 15:case 16:
							return;
						default:
						}
					}
				}
				tokentree_walk_WalkComment.walkComment(stream,dblDot);
				break;
			case 8:
				let _g2 = stream.peekNonCommentToken();
				if(_g2 != null) {
					if(_g2._hx_index == 1) {
						switch(_g2.k._hx_index) {
						case 15:case 16:
							return;
						default:
						}
					}
				}
				tokentree_walk_WalkComment.walkComment(stream,dblDot);
				break;
			case 18:
				tokentree_walk_WalkBlock.walkBlock(stream,dblDot);
				break;
			case 19:
				return;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,dblDot);
			}
		}
	}
	static relocateSharpTree(parent,dblDot) {
		let sharp = parent.getLastChild();
		if(sharp.children.length < 2) {
			return;
		}
		let _g = sharp.children[1].tok;
		if(_g._hx_index == 1 && _g.k._hx_index == 15) {
			return;
		}
		parent.children.pop();
		dblDot.addChild(sharp);
	}
	static walkCaseExpr(stream,parent) {
		let progress = new tokentree_TokenStreamProgress(stream);
		while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				if(_g.k._hx_index == 2) {
					let varTok = stream.consumeToken();
					parent.addChild(varTok);
					tokentree_walk_WalkStatement.walkStatement(stream,varTok);
				} else {
					tokentree_walk_WalkStatement.walkStatement(stream,parent);
				}
				break;
			case 10:case 12:case 17:case 19:case 21:
				return;
			case 15:
				let comma = stream.consumeToken();
				let child = parent.getLastChild();
				if(child == null) {
					child = parent;
				}
				child.addChild(comma);
				break;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
		}
	}
}
tokentree_walk_WalkSwitch.__name__ = "tokentree.walk.WalkSwitch";
class tokentree_walk_WalkTry {
	static walkTry(stream,parent) {
		let tryTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTry));
		parent.addChild(tryTok);
		stream.applyTempStore(tryTok);
		tokentree_walk_WalkBlock.walkBlock(stream,tryTok);
		let currentPos = stream.getStreamIndex();
		let progress = new tokentree_TokenStreamProgress(stream);
		let comments = [];
		while(stream.hasMore() && progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				if(_g.k._hx_index == 21) {
					let _g = 0;
					while(_g < comments.length) tryTok.addChild(comments[_g++]);
					comments = [];
					tokentree_walk_WalkTry.walkCatch(stream,tryTok);
					currentPos = stream.getStreamIndex();
				} else {
					stream.rewindTo(currentPos);
					return;
				}
				break;
			case 7:
				comments.push(stream.consumeToken());
				break;
			case 8:
				comments.push(stream.consumeToken());
				break;
			default:
				stream.rewindTo(currentPos);
				return;
			}
		}
	}
	static walkCatch(stream,parent) {
		let catchTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdCatch));
		parent.addChild(catchTok);
		tokentree_walk_WalkPOpen.walkPOpen(stream,catchTok);
		tokentree_walk_WalkComment.walkComment(stream,catchTok);
		tokentree_walk_WalkBlock.walkBlock(stream,catchTok);
	}
}
tokentree_walk_WalkTry.__name__ = "tokentree.walk.WalkTry";
class tokentree_walk_WalkType {
	static walkType(stream,parent) {
		let _g = stream.token();
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 1:
				tokentree_walk_WalkClass.walkClass(stream,parent);
				break;
			case 26:
				tokentree_walk_WalkEnum.walkEnum(stream,parent);
				break;
			case 28:
				tokentree_walk_WalkInterface.walkInterface(stream,parent);
				break;
			case 32:
				tokentree_walk_WalkTypedef.walkTypedef(stream,parent);
				break;
			case 40:
				tokentree_walk_WalkAbstract.walkAbstract(stream,parent);
				break;
			default:
			}
		}
	}
}
tokentree_walk_WalkType.__name__ = "tokentree.walk.WalkType";
class tokentree_walk_WalkTypeNameDef {
	static walkTypeNameDef(stream,parent) {
		tokentree_walk_WalkComment.walkComment(stream,parent);
		tokentree_walk_WalkAt.walkAts(stream);
		if(stream.tokenForMatch()._hx_index == 22) {
			let questTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Question);
			parent.addChild(questTok);
			parent = questTok;
			tokentree_walk_WalkComment.walkComment(stream,questTok);
		}
		let name;
		let bAdd = true;
		let _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 22:case 25:case 41:
				name = stream.consumeToken();
				break;
			default:
				name = stream.consumeToken();
			}
			break;
		case 2:
			name = stream.consumeConst();
			break;
		case 3:
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
			if(!stream.hasMore()) {
				return parent.getFirstChild();
			}
			if(stream.token()._hx_index == 2) {
				name = stream.consumeConst();
			} else {
				return parent.getFirstChild();
			}
			break;
		case 4:
			name = stream.consumeToken();
			break;
		case 16:
			tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
			return parent.getFirstChild();
		case 18:
			tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,parent);
			return parent.getFirstChild();
		case 20:
			name = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
			if(stream.tokenForMatch()._hx_index == 22) {
				tokentree_walk_WalkQuestion.walkQuestion(stream,name);
			}
			bAdd = false;
			break;
		default:
			name = stream.consumeToken();
		}
		stream.applyTempStore(name);
		if(bAdd) {
			parent.addChild(name);
		}
		tokentree_walk_WalkTypeNameDef.walkTypeNameDefContinue(stream,name);
		return name;
	}
	static walkTypeNameDefContinue(stream,parent) {
		tokentree_walk_WalkTypeNameDef.walkTypeNameDefComment(stream,parent);
		if(stream.tokenForMatch()._hx_index == 11) {
			let dot = stream.consumeToken();
			parent.addChild(dot);
			tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dot);
			return;
		}
		let _g = stream.tokenForMatch();
		if(_g._hx_index == 6 && _g.op._hx_index == 9) {
			tokentree_walk_WalkLtGt.walkLtGt(stream,parent);
		}
		if(stream.tokenForMatch()._hx_index == 14) {
			let arrow = stream.consumeToken();
			parent.addChild(arrow);
			tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,arrow);
			return;
		}
		if(stream.tokenForMatch()._hx_index == 16) {
			tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
		}
		tokentree_walk_WalkTypeNameDef.walkTypeNameDefComment(stream,parent);
	}
	static walkTypeNameDefComment(stream,parent) {
		let currentPos = stream.getStreamIndex();
		let progress = new tokentree_TokenStreamProgress(stream);
		let comments = [];
		while(stream.hasMore() && progress.streamHasChanged()) switch(stream.token()._hx_index) {
		case 6:
			let _g = 0;
			while(_g < comments.length) parent.addChild(comments[_g++]);
			return;
		case 7:
			comments.push(stream.consumeToken());
			break;
		case 8:
			comments.push(stream.consumeToken());
			break;
		case 10:case 11:case 12:case 15:case 16:case 18:case 20:
			let _g1 = 0;
			while(_g1 < comments.length) parent.addChild(comments[_g1++]);
			return;
		default:
			stream.rewindTo(currentPos);
			return;
		}
	}
}
tokentree_walk_WalkTypeNameDef.__name__ = "tokentree.walk.WalkTypeNameDef";
class tokentree_walk_WalkTypedef {
	static walkTypedef(stream,parent) {
		let typeTok = stream.consumeToken();
		parent.addChild(typeTok);
		let name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
		stream.applyTempStore(name);
		let _g = stream.tokenForMatch();
		if(_g._hx_index == 6 && _g.op._hx_index == 4) {
			let assign = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign));
			name.addChild(assign);
			name = assign;
		}
		tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,name);
	}
}
tokentree_walk_WalkTypedef.__name__ = "tokentree.walk.WalkTypedef";
class tokentree_walk_WalkTypedefBody {
	static walkTypedefBody(stream,parent) {
		if(stream.tokenForMatch()._hx_index == 18) {
			let openTok = stream.consumeToken();
			parent.addChild(openTok);
			tokentree_walk_WalkTypedefBody.walkTypedefCurlyBody(stream,openTok);
			openTok.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
		} else {
			tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,parent);
		}
		let _g = stream.tokenForMatch();
		if(_g._hx_index == 6 && _g.op._hx_index == 11) {
			let and = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAnd));
			parent.getLastChild().addChild(and);
			tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,parent);
		}
		if(stream.tokenForMatch()._hx_index == 14) {
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
	static walkTypedefCurlyBody(stream,openTok) {
		let progress = new tokentree_TokenStreamProgress(stream);
		_hx_loop1: while(progress.streamHasChanged()) {
			let _g = stream.token();
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					tokentree_walk_WalkFunction.walkFunction(stream,openTok);
					break;
				case 2:
					tokentree_walk_WalkVar.walkVar(stream,openTok);
					break;
				case 17:case 18:case 19:case 25:case 31:case 33:case 35:case 41:
					stream.consumeToTempStore();
					break;
				case 42:
					tokentree_walk_WalkFinal.walkFinal(stream,openTok);
					break;
				default:
					tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
				}
				break;
			case 3:
				tokentree_walk_WalkSharp.walkSharp(stream,openTok,tokentree_walk_WalkTypedefBody.walkTypedefCurlyBody);
				break;
			case 6:
				if(_g.op._hx_index == 7) {
					tokentree_walk_WalkTypedefBody.walkStructureExtension(stream,openTok);
				} else {
					tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
				}
				break;
			case 7:
				if(stream.hasTempStore()) {
					stream.consumeToTempStore();
				} else {
					tokentree_walk_WalkComment.walkComment(stream,openTok);
				}
				break;
			case 8:
				if(stream.hasTempStore()) {
					stream.consumeToTempStore();
				} else {
					tokentree_walk_WalkComment.walkComment(stream,openTok);
				}
				break;
			case 19:
				break _hx_loop1;
			case 23:
				stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
				break;
			default:
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
			}
		}
		let tempStore = stream.getTempStore();
		if(tempStore.length > 0) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(tempStore)));
			case 1:
				stream.applyTempStore(openTok);
				break;
			}
		}
	}
	static walkTypedefAlias(stream,parent) {
		let newParent;
		if(stream.tokenForMatch()._hx_index == 20) {
			newParent = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
		} else {
			newParent = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
		}
		if(stream.tokenForMatch()._hx_index == 14) {
			let arrowTok = stream.consumeToken();
			newParent.addChild(arrowTok);
			tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,arrowTok);
		}
		if(stream.tokenForMatch()._hx_index == 10) {
			newParent.addChild(stream.consumeToken());
		}
	}
	static walkStructureExtension(stream,parent) {
		let gt = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		parent.addChild(gt);
		let name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
		gt.addChild(name);
		if(stream.tokenForMatch()._hx_index == 15) {
			name.addChild(stream.consumeToken());
		}
	}
}
tokentree_walk_WalkTypedefBody.__name__ = "tokentree.walk.WalkTypedefBody";
class tokentree_walk_WalkVar {
	static walkVar(stream,parent) {
		let name = null;
		let varTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdVar));
		parent.addChild(varTok);
		tokentree_walk_WalkComment.walkComment(stream,parent);
		let progress = new tokentree_TokenStreamProgress(stream);
		while(progress.streamHasChanged()) {
			let _g = stream.tokenForMatch();
			if(_g._hx_index == 1 && _g.k._hx_index == 2) {
				return;
			}
			tokentree_walk_WalkComment.walkComment(stream,parent);
			if(stream.token()._hx_index == 23) {
				tokentree_walk_WalkAt.walkAts(stream);
			}
			tokentree_walk_WalkComment.walkComment(stream,parent);
			let nameParent = varTok;
			if(stream.tokenForMatch()._hx_index == 22) {
				nameParent = stream.consumeToken();
				varTok.addChild(nameParent);
			}
			name = stream.consumeConstIdent();
			nameParent.addChild(name);
			stream.applyTempStore(name);
			tokentree_walk_WalkComment.walkComment(stream,name);
			if(stream.tokenForMatch()._hx_index == 20) {
				tokentree_walk_WalkPOpen.walkPOpen(stream,name);
			}
			if(stream.tokenForMatch()._hx_index == 12) {
				let dblDot = stream.consumeToken();
				name.addChild(dblDot);
				tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,dblDot);
			}
			let _g1 = stream.tokenForMatch();
			if(_g1._hx_index == 6 && _g1.op._hx_index == 4) {
				tokentree_walk_WalkStatement.walkStatement(stream,name);
			}
			if(stream.tokenForMatch()._hx_index == 15) {
				name.addChild(stream.consumeToken());
				continue;
			}
			break;
		}
		if(stream.tokenForMatch()._hx_index == 10) {
			name.addChild(stream.consumeToken());
		}
	}
}
tokentree_walk_WalkVar.__name__ = "tokentree.walk.WalkVar";
class tokentree_walk_WalkWhile {
	static walkWhile(stream,parent) {
		let whileTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdWhile));
		parent.addChild(whileTok);
		stream.applyTempStore(whileTok);
		tokentree_walk_WalkComment.walkComment(stream,whileTok);
		tokentree_walk_WalkStatement.walkStatement(stream,whileTok);
		tokentree_walk_WalkComment.walkComment(stream,whileTok);
		tokentree_walk_WalkBlock.walkBlock(stream,whileTok);
	}
}
tokentree_walk_WalkWhile.__name__ = "tokentree.walk.WalkWhile";
function $iterator(o) { if( o instanceof Array ) return function() { return new haxe_iterators_ArrayIterator(o); }; return typeof(o.iterator) == 'function' ? $bind(o,o.iterator) : o.iterator; }
function $keyValueIterator(o) { if( o instanceof Array ) return function() { return HxOverrides.keyValueIter(o); }; return typeof(o.keyValueIterator) == 'function' ? $bind(o,o.keyValueIterator) : o.keyValueIterator; }
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
{
	Object.defineProperty(String.prototype,"__class__",{ value : String, enumerable : false, writable : true});
	String.__name__ = "String";
	Array.__name__ = "Array";
	Date.prototype.__class__ = Date;
	Date.__name__ = "Date";
	var Int = { };
	var Dynamic = { };
	var Float = Number;
	var Bool = Boolean;
	var Class = { };
	var Enum = { };
}
js_Boot.__toStr = ({ }).toString;
DateTools.DAY_SHORT_NAMES = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
DateTools.DAY_NAMES = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
DateTools.MONTH_SHORT_NAMES = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
DateTools.MONTH_NAMES = ["January","February","March","April","May","June","July","August","September","October","November","December"];
Xml.Element = 0;
Xml.PCData = 1;
Xml.CData = 2;
Xml.Comment = 3;
Xml.DocType = 4;
Xml.ProcessingInstruction = 5;
Xml.Document = 6;
formatter_FormatStats.totalLinesOrig = 0;
formatter_FormatStats.totalLinesFormatted = 0;
haxe_xml_Parser.escapes = (function($this) {
	var $r;
	let h = new haxe_ds_StringMap();
	h.h["lt"] = "<";
	h.h["gt"] = ">";
	h.h["amp"] = "&";
	h.h["quot"] = "\"";
	h.h["apos"] = "'";
	$r = h;
	return $r;
}(this));
haxeLanguageServer_Configuration.DefaultInitOptions = { displayServerConfig : { path : "haxe", env : { }, 'arguments' : [], print : { completion : false, reusing : false}, useSocket : true}, displayArguments : [], haxelibConfig : { executable : "haxelib"}, sendMethodResults : false, experimentalClientCapabilities : { supportedCommands : []}};
haxeLanguageServer_Configuration.DefaultUserSettings = { enableCodeLens : false, enableDiagnostics : true, enableServerView : false, enableSignatureHelpDocumentation : true, diagnosticsPathFilter : "${workspaceRoot}", displayPort : null, buildCompletionCache : true, enableCompletionCacheWarning : true, populateCacheFromDisplay : true, useLegacyCompletion : false, codeGeneration : { functions : { anonymous : { argumentTypeHints : false, returnTypeHint : "never", useArrowSyntax : true, placeOpenBraceOnNewLine : false, explicitPublic : false, explicitPrivate : false, explicitNull : false}, field : { argumentTypeHints : true, returnTypeHint : "non-void", useArrowSyntax : false, placeOpenBraceOnNewLine : false, explicitPublic : false, explicitPrivate : false, explicitNull : false}}, imports : { style : "type", enableAutoImports : true}, switch_ : { parentheses : false}}, exclude : ["zpp_nape"], postfixCompletion : { level : "full"}, importsSortOrder : "all-alphabetical", maxCompletionItems : 1000, renameSourceFolders : ["src","source","Source","test","tests"], inlayHints : { variableTypes : true, parameterNames : true, parameterTypes : false, functionReturnTypes : true, conditionals : false}, serverRecording : { enabled : false, path : ".haxelsp/recording/", exclude : [], excludeUntracked : false, watch : []}};
haxeLanguageServer_Context.haxeSelector = [{ language : "haxe", scheme : "file"},{ language : "haxe", scheme : "untitled"}];
haxeLanguageServer_Context.hxmlSelector = [{ language : "hxml", scheme : "file"},{ language : "hxml", scheme : "untitled"}];
var haxeLanguageServer_extensions_DocumentUriExtensions_driveLetterPathRe = new EReg("^/[a-zA-Z]:","");
var haxeLanguageServer_extensions_DocumentUriExtensions_uriRe = new EReg("^(([^:/?#]+?):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?","");
var haxeLanguageServer_extensions_FsPathExtensions_upperCaseDriveRe = new EReg("^(/)?([A-Z]:)","");
haxeLanguageServer_features_haxe_RenameFeature.HINT_SETTINGS = " - check `haxe.renameSourceFolders` setting (see https://github.com/vshaxe/vshaxe/wiki/Rename-Symbol)";
haxeLanguageServer_features_haxe_codeAction_OrganizeImportsFeature.stdLibPackages = ["cpp","cs","eval","flash","haxe","hl","java","js","lua","neko","php","python","sys","Any","Array","ArrayAccess","Bool","Class","Date","DateTools","Dynamic","EReg","Enum","EnumValue","Float","Int","IntIterator","Iterable","Iterator","KeyValueIterable","KeyValueIterator","Lambda","List","Map","Math","Null","Reflect","Single","Std","String","StringBuf","StringTools","Sys","SysError","Type","UInt","UnicodeString","ValueType","Void","Xml","XmlType"];
haxeLanguageServer_features_haxe_completion_CompletionFeature.autoTriggerOnSpacePattern = new EReg("(\\b(import|using|extends|implements|from|to|case|new|cast|override)|(->)) $","");
haxeLanguageServer_features_haxe_completion_CompletionFeature.dollarPattern = new EReg("(\\$+)$","");
haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.reCaseOrDefault = new EReg("\\b(case|default)\\b[^:]*:$","");
haxeLanguageServer_features_haxe_completion_CompletionFeatureLegacy.reFieldPart = new EReg("(\\.|@(:?))(\\w*)$","");
haxeLanguageServer_features_haxe_foldingRange_FoldingRangeResolver.regionStartPattern = new EReg("^\\s*[#{]?\\s*region\\b","");
haxeLanguageServer_features_haxe_foldingRange_FoldingRangeResolver.regionEndPattern = new EReg("^\\s*[#}]?\\s*end ?region\\b","");
var haxeLanguageServer_features_hxml_data_Shared_DceEnumValues = [{ name : "full", description : "Apply dead code elimination to all code."},{ name : "std", description : "Only apply dead code elimination to the standard library."},{ name : "no", description : "Disable dead code elimination."}];
var haxeLanguageServer_features_hxml_data_Defines_DefineVersions = (function($this) {
	var $r;
	let v4_0_0_rc3 = { major : 4, minor : 0, patch : 0, pre : "rc.3", build : null};
	let v4_0_0_rc4 = { major : 4, minor : 0, patch : 0, pre : "rc.4", build : null};
	let v4_1_0 = { major : 4, minor : 1, patch : 0, pre : null, build : null};
	let v4_2_0 = { major : 4, minor : 2, patch : 0, pre : null, build : null};
	let _g = new haxe_ds_StringMap();
	_g.h["CsVer"] = { since : v4_0_0_rc3};
	_g.h["NetcoreVer"] = { since : v4_0_0_rc3};
	_g.h["DumpPath"] = { since : v4_0_0_rc4};
	_g.h["KeepInlinePositions"] = { since : v4_0_0_rc4};
	_g.h["StdEncodingUtf8"] = { since : v4_1_0};
	_g.h["NoTre"] = { since : v4_1_0};
	_g.h["JarLegacyLoader"] = { since : v4_2_0};
	_g.h["NoCOpt"] = { until : v4_1_0};
	_g.h["OldConstructorInline"] = { until : v4_1_0};
	_g.h["JvmCompressionLevel"] = { since : v4_2_0};
	_g.h["JvmDynamicLevel"] = { since : v4_2_0};
	$r = _g;
	return $r;
}(this));
var haxeLanguageServer_features_hxml_data_Defines_DefineEnums = (function($this) {
	var $r;
	let _g = new haxe_ds_StringMap();
	_g.h["Dce"] = haxeLanguageServer_features_hxml_data_Shared_DceEnumValues;
	_g.h["Dump"] = [{ name : "pretty"},{ name : "record"},{ name : "position"},{ name : "legacy"}];
	_g.h["HlVer"] = [{ name : "1.10.0"},{ name : "1.11.0"},{ name : "1.12.0"}];
	_g.h["JavaVer"] = [{ name : "7"},{ name : "6"},{ name : "5"}];
	_g.h["JsEs"] = [{ name : "6"},{ name : "5"},{ name : "3"}];
	_g.h["LuaVer"] = [{ name : "5.2"},{ name : "5.1"}];
	_g.h["NetTarget"] = [{ name : "net"},{ name : "netcore", description : ".NET core"},{ name : "xbox"},{ name : "micro", description : "Micro Framework"},{ name : "compact", description : "Compact Framework"}];
	{
		let value = haxeLanguageServer_features_hxml_data_Defines_integers(1,9);
		_g.h["SwfCompressLevel"] = value;
	}
	{
		let value1 = haxeLanguageServer_features_hxml_data_Defines_integers(0,9);
		_g.h["JvmCompressionLevel"] = value1;
	}
	_g.h["JvmDynamicLevel"] = [{ name : "1", description : "field read/write optimization (default)"},{ name : "0", description : "none"},{ name : "2", description : "compile-time method closures"}];
	$r = _g;
	return $r;
}(this));
var haxeLanguageServer_features_hxml_data_Defines_RemovedDefines = [{ "name" : "NoCOpt", "define" : "no_copt", "doc" : "Disable completion optimization (for debug purposes)."},{ "name" : "OldConstructorInline", "define" : "old-constructor-inline", "doc" : "Use old constructor inlining logic (from Haxe 3.4.2) instead of the reworked version."}];
var haxeLanguageServer_features_hxml_data_Defines_Defines = [{ "name" : "AbsolutePath", "define" : "absolute_path", "doc" : "Print absolute file path in trace output."},{ "name" : "AdvancedTelemetry", "define" : "advanced-telemetry", "doc" : "Allow the SWF to be measured with Monocle tool.", "platforms" : ["flash"]},{ "name" : "AnalyzerOptimize", "define" : "analyzer_optimize", "doc" : "Perform advanced optimizations."},{ "name" : "AnnotateSource", "define" : "annotate_source", "doc" : "Add additional comments to generated source code.", "platforms" : ["cpp"]},{ "name" : "CheckXmlProxy", "define" : "check_xml_proxy", "doc" : "Check the used fields of the XML proxy."},{ "name" : "CoreApi", "define" : "core_api", "doc" : "Defined in the core API context."},{ "name" : "CoreApiSerialize", "define" : "core_api_serialize", "doc" : "Mark some generated core API classes with the `Serializable` attribute on C#.", "platforms" : ["cs"]},{ "name" : "Cppia", "define" : "cppia", "doc" : "Generate cpp instruction assembly."},{ "name" : "CsVer", "define" : "cs_ver", "doc" : "The C# version to target.", "platforms" : ["cs"], "params" : ["version"]},{ "name" : "NoCppiaAst", "define" : "nocppiaast", "doc" : "Use legacy cppia generation."},{ "name" : "Dce", "define" : "dce", "doc" : "Set the dead code elimination mode. (default: std)", "params" : ["mode: std | full | no"], "links" : ["https://haxe.org/manual/cr-dce.html"]},{ "name" : "DceDebug", "define" : "dce_debug", "doc" : "Show DCE log.", "links" : ["https://haxe.org/manual/cr-dce.html"]},{ "name" : "Debug", "define" : "debug", "doc" : "Activated when compiling with -debug."},{ "name" : "DisableUnicodeStrings", "define" : "disable_unicode_strings", "doc" : "Disable Unicode support in `String` type.", "platforms" : ["cpp"]},{ "name" : "Display", "define" : "display", "doc" : "Activated during completion.", "links" : ["https://haxe.org/manual/cr-completion.html"]},{ "name" : "DisplayStdin", "define" : "display_stdin", "doc" : "Read the contents of a file specified in `--display` from standard input."},{ "name" : "DllExport", "define" : "dll_export", "doc" : "GenCPP experimental linking.", "platforms" : ["cpp"]},{ "name" : "DllImport", "define" : "dll_import", "doc" : "Handle Haxe-generated .NET DLL imports.", "platforms" : ["cs"]},{ "name" : "DocGen", "define" : "doc_gen", "doc" : "Do not perform any removal/change in order to correctly generate documentation."},{ "name" : "Dump", "define" : "dump", "doc" : "Dump typed AST in dump subdirectory using specified mode or non-prettified default.", "params" : ["mode: pretty | record | position | legacy"]},{ "name" : "DumpPath", "define" : "dump_path", "doc" : "Path to generate dumps to (default: \"dump\").", "params" : ["path"]},{ "name" : "DumpDependencies", "define" : "dump_dependencies", "doc" : "Dump the classes dependencies in a dump subdirectory."},{ "name" : "DumpIgnoreVarIds", "define" : "dump_ignore_var_ids", "doc" : "Remove variable IDs from non-pretty dumps (helps with diff)."},{ "name" : "DynamicInterfaceClosures", "define" : "dynamic_interface_closures", "doc" : "Use slow path for interface closures to save space.", "platforms" : ["cpp"]},{ "name" : "EraseGenerics", "define" : "erase_generics", "doc" : "Erase generic classes on C#.", "platforms" : ["cs"]},{ "name" : "EvalCallStackDepth", "define" : "eval_call_stack_depth", "doc" : "Set maximum call stack depth for eval. (default: 1000)", "platforms" : ["eval"], "params" : ["depth"]},{ "name" : "EvalDebugger", "define" : "eval_debugger", "doc" : "Support debugger in macro/interp mode. Allows `host:port` value to open a socket. Implies eval_stack.", "platforms" : ["eval"]},{ "name" : "EvalStack", "define" : "eval_stack", "doc" : "Record stack information in macro/interp mode.", "platforms" : ["eval"]},{ "name" : "EvalTimes", "define" : "eval_times", "doc" : "Record per-method execution times in macro/interp mode. Implies eval_stack.", "platforms" : ["eval"]},{ "name" : "FilterTimes", "define" : "filter_times", "doc" : "Record per-filter execution times upon --times."},{ "name" : "FastCast", "define" : "fast_cast", "doc" : "Enables an experimental casts cleanup on C# and Java.", "platforms" : ["cs","java"]},{ "name" : "Fdb", "define" : "fdb", "doc" : "Enable full flash debug infos for FDB interactive debugging.", "platforms" : ["flash"]},{ "name" : "FileExtension", "define" : "file_extension", "doc" : "Output filename extension for cpp source code.", "platforms" : ["cpp"]},{ "name" : "FlashStrict", "define" : "flash_strict", "doc" : "More strict typing for flash target.", "platforms" : ["flash"]},{ "name" : "FlashUseStage", "define" : "flash_use_stage", "doc" : "Keep the SWF library initial stage.", "platforms" : ["flash"]},{ "devcomment" : "force_lib_check is only here as a debug facility - compiler checking allows errors to be found more easily", "name" : "ForceLibCheck", "define" : "force_lib_check", "doc" : "Force the compiler to check `--net-lib` and `-java-lib` added classes (internal).", "platforms" : ["cs","java"]},{ "name" : "ForceNativeProperty", "define" : "force_native_property", "doc" : "Tag all properties with `:nativeProperty` metadata for 3.1 compatibility.", "platforms" : ["cpp"]},{ "name" : "GencommonDebug", "define" : "gencommon_debug", "doc" : "GenCommon internal.", "platforms" : ["cs","java"]},{ "name" : "Haxe3Compat", "define" : "haxe3compat", "doc" : "Gives warnings about transition from Haxe 3.x to Haxe 4.0."},{ "name" : "HaxeBoot", "define" : "haxe_boot", "doc" : "Give the name 'haxe' to the flash boot class instead of a generated name.", "platforms" : ["flash"]},{ "name" : "HaxeVer", "define" : "haxe_ver", "doc" : "The current Haxe version value as decimal number. E.g. 3.407 for 3.4.7.", "reserved" : true},{ "name" : "Haxe", "define" : "haxe", "doc" : "The current Haxe version value in SemVer format.", "reserved" : true},{ "name" : "HlVer", "define" : "hl_ver", "doc" : "The HashLink version to target. (default: 1.10.0)", "platforms" : ["hl"], "params" : ["version"]},{ "name" : "HxcppApiLevel", "define" : "hxcpp_api_level", "doc" : "Provided to allow compatibility between hxcpp versions.", "platforms" : ["cpp"], "reserved" : true},{ "name" : "HxcppGcGenerational", "define" : "HXCPP_GC_GENERATIONAL", "doc" : "Experimental Garbage Collector.", "platforms" : ["cpp"]},{ "name" : "HxcppDebugger", "define" : "HXCPP_DEBUGGER", "doc" : "Include additional information for hxcpp_debugger.", "platforms" : ["cpp"]},{ "name" : "HxcppSmartStings", "define" : "hxcpp_smart_strings", "doc" : "Use wide strings in hxcpp. (Turned on by default unless `-D disable_unicode_strings` is specified.)", "platforms" : ["cpp"]},{ "name" : "IncludePrefix", "define" : "include_prefix", "doc" : "Prepend path to generated include files.", "platforms" : ["cpp"]},{ "name" : "Interp", "define" : "interp", "doc" : "The code is compiled to be run with `--interp`."},{ "name" : "JarLegacyLoader", "define" : "jar-legacy-loader", "doc" : "Use the legacy loader to load .jar files on the JVM target.", "platforms" : ["java"]},{ "name" : "JavaVer", "define" : "java_ver", "doc" : "Sets the Java version to be targeted.", "platforms" : ["java"], "params" : ["version: 5-7"]},{ "name" : "JsClassic", "define" : "js_classic", "doc" : "Don't use a function wrapper and strict mode in JS output.", "platforms" : ["js"]},{ "name" : "JsEs", "define" : "js_es", "doc" : "Generate JS compliant with given ES standard version. (default: 5)", "platforms" : ["js"], "params" : ["version: 3 | 5 | 6"], "links" : ["https://haxe.org/manual/target-javascript-es6.html"]},{ "name" : "JsEnumsAsArrays", "define" : "js_enums_as_arrays", "doc" : "Generate enum representation as array instead of as object.", "platforms" : ["js"]},{ "name" : "JsUnflatten", "define" : "js_unflatten", "doc" : "Generate nested objects for packages and types.", "platforms" : ["js"]},{ "name" : "JsSourceMap", "define" : "js_source_map", "doc" : "Generate JavaScript source map even in non-debug mode. Deprecated in favor of `-D source_map`.", "platforms" : ["js"]},{ "name" : "SourceMap", "define" : "source_map", "doc" : "Generate source map for compiled files.", "platforms" : ["php","js"]},{ "name" : "Jvm", "define" : "jvm", "doc" : "Generate jvm directly.", "platforms" : ["java"]},{ "name" : "JvmCompressionLevel", "define" : "jvm.compression-level", "doc" : "Set the compression level of the generated file between 0 (no compression) and 9 (highest compression). Default: 6", "platforms" : ["java"]},{ "name" : "JvmDynamicLevel", "define" : "jvm.dynamic-level", "doc" : "Controls the amount of dynamic support code being generated. 0 = none, 1 = field read/write optimization (default), 2 = compile-time method closures", "platforms" : ["java"]},{ "name" : "KeepOldOutput", "define" : "keep_old_output", "doc" : "Keep old source files in the output directory.", "platforms" : ["cs","java"]},{ "name" : "LoopUnrollMaxCost", "define" : "loop_unroll_max_cost", "doc" : "Maximum cost (number of expressions * iterations) before loop unrolling is canceled. (default: 250)", "params" : ["cost"]},{ "name" : "LuaJit", "define" : "lua_jit", "doc" : "Enable the jit compiler for lua (version 5.2 only).", "platforms" : ["lua"]},{ "name" : "LuaVanilla", "define" : "lua_vanilla", "doc" : "Generate code lacking compiled extern lib support (e.g. utf8).", "platforms" : ["lua"]},{ "name" : "LuaVer", "define" : "lua_ver", "doc" : "The lua version to target.", "platforms" : ["lua"], "params" : ["version"]},{ "name" : "Macro", "define" : "macro", "doc" : "Defined when code is compiled in the macro context.", "links" : ["https://haxe.org/manual/macro.html"], "reserved" : true},{ "name" : "MacroTimes", "define" : "macro_times", "doc" : "Display per-macro timing when used with `--times`."},{ "name" : "NetVer", "define" : "net_ver", "doc" : "Sets the .NET version to be targeted.", "platforms" : ["cs"], "params" : ["version: 20-45"]},{ "name" : "NetcoreVer", "define" : "netcore_ver", "doc" : "Sets the .NET core version to be targeted", "platforms" : ["cs"], "params" : ["version: x.x.x"]},{ "name" : "NetTarget", "define" : "net_target", "doc" : "Sets the .NET target. `netcore` (.NET core), `xbox`, `micro` (Micro Framework), `compact` (Compact Framework) are some valid values. (default: `net`)", "platforms" : ["cs"], "params" : ["name"]},{ "name" : "NekoSource", "define" : "neko_source", "doc" : "Output neko source instead of bytecode.", "platforms" : ["neko"]},{ "name" : "NekoV1", "define" : "neko_v1", "doc" : "Keep Neko 1.x compatibility.", "platforms" : ["neko"]},{ "name" : "NetworkSandbox", "define" : "network-sandbox", "doc" : "Use local network sandbox instead of local file access one.", "platforms" : ["flash"]},{ "name" : "NoCompilation", "define" : "no-compilation", "doc" : "Disable final compilation.", "platforms" : ["cs","java","cpp","hl"]},{ "name" : "NoDebug", "define" : "no_debug", "doc" : "Remove all debug macros from cpp output."},{ "name" : "NoDeprecationWarnings", "define" : "no-deprecation-warnings", "doc" : "Do not warn if fields annotated with `@:deprecated` are used."},{ "name" : "NoFlashOverride", "define" : "no-flash-override", "doc" : "Change overrides on some basic classes into HX suffixed methods", "platforms" : ["flash"]},{ "name" : "NoOpt", "define" : "no_opt", "doc" : "Disable optimizations."},{ "name" : "NoInline", "define" : "no_inline", "doc" : "Disable inlining.", "links" : ["https://haxe.org/manual/class-field-inline.html"]},{ "name" : "KeepInlinePositions", "define" : "keep_inline_positions", "doc" : "Don't substitute positions of inlined expressions with the position of the place of inlining.", "links" : ["https://haxe.org/manual/class-field-inline.html"]},{ "name" : "NoRoot", "define" : "no_root", "doc" : "Generate top-level types into the `haxe.root` namespace.", "platforms" : ["cs"]},{ "name" : "NoMacroCache", "define" : "no_macro_cache", "doc" : "Disable macro context caching."},{ "name" : "NoSwfCompress", "define" : "no_swf_compress", "doc" : "Disable SWF output compression.", "platforms" : ["flash"]},{ "name" : "NoTraces", "define" : "no_traces", "doc" : "Disable all trace calls."},{ "name" : "Objc", "define" : "objc", "doc" : "Sets the hxcpp output to Objective-C++ classes. Must be defined for interop.", "platforms" : ["cpp"]},{ "name" : "OldErrorFormat", "define" : "old-error-format", "doc" : "Use Haxe 3.x zero-based column error messages instead of new one-based format."},{ "name" : "PhpPrefix", "define" : "php_prefix", "doc" : "Root namespace for generated php classes. E.g. if compiled with`-D php-prefix=some.sub`, then all classes will be generated in `\\some\\sub` namespace.", "platforms" : ["php"], "params" : ["dot-separated namespace"]},{ "name" : "PhpLib", "define" : "php_lib", "doc" : "Select the name for the php lib folder.", "platforms" : ["php"], "params" : ["folder name"]},{ "name" : "PhpFront", "define" : "php_front", "doc" : "Select the name for the php front file. (default: `index.php`)", "platforms" : ["php"], "params" : ["filename"]},{ "name" : "PythonVersion", "define" : "python_version", "doc" : "The python version to target. (default: 3.3)", "platforms" : ["python"], "params" : ["version"]},{ "name" : "RealPosition", "define" : "real_position", "doc" : "Disables Haxe source mapping when targetting C#, removes position comments in Java and Php output.", "platforms" : ["cs","java","php"]},{ "name" : "ReplaceFiles", "define" : "replace_files", "doc" : "GenCommon internal.", "platforms" : ["cs","java"]},{ "name" : "Scriptable", "define" : "scriptable", "doc" : "GenCPP internal.", "platforms" : ["cpp"]},{ "name" : "ShallowExpose", "define" : "shallow-expose", "doc" : "Expose types to surrounding scope of Haxe generated closure without writing to window object.", "platforms" : ["js"]},{ "name" : "SourceHeader", "define" : "source-header", "doc" : "Print value as comment on top of generated files, use '' value to disable."},{ "name" : "SourceMapContent", "define" : "source-map-content", "doc" : "Include the Haxe sources as part of the JS source map.", "platforms" : ["js"]},{ "name" : "Static", "define" : "static", "doc" : "Defined if the current target is static.", "reserved" : true},{ "name" : "StdEncodingUtf8", "define" : "std-encoding-utf8", "doc" : "Force utf8 encoding for stdin, stdout and stderr", "platforms" : ["java","cs","python"]},{ "name" : "Swc", "define" : "swc", "doc" : "Output a SWC instead of a SWF.", "platforms" : ["flash"], "reserved" : true},{ "name" : "SwfCompressLevel", "define" : "swf_compress_level", "doc" : "Set the amount of compression for the SWF output.", "platforms" : ["flash"], "params" : ["level: 1-9"]},{ "name" : "SwfDebugPassword", "define" : "swf_debug_password", "doc" : "Set a password for debugging.", "platforms" : ["flash"], "params" : ["password"]},{ "name" : "SwfDirectBlit", "define" : "swf_direct_blit", "doc" : "Use hardware acceleration to blit graphics.", "platforms" : ["flash"]},{ "name" : "SwfGpu", "define" : "swf_gpu", "doc" : "Use GPU compositing features when drawing graphics.", "platforms" : ["flash"]},{ "name" : "SwfMetadata", "define" : "swf_metadata", "doc" : "Include contents of the given file as metadata in the SWF.", "platforms" : ["flash"], "params" : ["file"]},{ "name" : "SwfPreloaderFrame", "define" : "swf_preloader_frame", "doc" : "Insert empty first frame in SWF.", "platforms" : ["flash"]},{ "name" : "SwfProtected", "define" : "swf_protected", "doc" : "Compile Haxe `private` as `protected` in the SWF instead of `public`.", "platforms" : ["flash"]},{ "name" : "SwfScriptTimeout", "define" : "swf_script_timeout", "doc" : "Maximum ActionScript processing time before script stuck dialog box displays.", "platforms" : ["flash"], "params" : ["time in seconds"]},{ "name" : "SwfUseDoAbc", "define" : "swf_use_doabc", "doc" : "Use `DoAbc` SWF-tag instead of `DoAbcDefine`.", "platforms" : ["flash"]},{ "name" : "Sys", "define" : "sys", "doc" : "Defined for all system platforms.", "reserved" : true},{ "name" : "Unsafe", "define" : "unsafe", "doc" : "Allow unsafe code when targeting C#.", "platforms" : ["cs"]},{ "name" : "UseNekoc", "define" : "use_nekoc", "doc" : "Use `nekoc` compiler instead of the internal one.", "platforms" : ["neko"]},{ "name" : "Utf16", "define" : "utf16", "doc" : "Defined for all platforms that use UTF-16 string encoding with UCS-2 API.", "reserved" : true},{ "name" : "Vcproj", "define" : "vcproj", "doc" : "GenCPP internal.", "platforms" : ["cpp"]},{ "name" : "WarnVarShadowing", "define" : "warn_var_shadowing", "doc" : "Warn about shadowing variable declarations."},{ "name" : "NoTre", "define" : "no_tre", "doc" : "Disable tail recursion elimination."}];
var haxeLanguageServer_features_hxml_data_Flags_HxmlFlags = (function($this) {
	var $r;
	let _g = new haxe_ds_EnumValueMap();
	_g.set(haxeLanguageServer_features_hxml_data_Category.Target,[{ name : "--js", deprecatedNames : ["-js"], argument : { name : "<file>", insertion : "bin/${1:main}.js", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "generate JavaScript code into target file"},{ name : "--lua", deprecatedNames : ["-lua"], argument : { name : "<file>", insertion : "bin/${1:main}.lua", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "generate Lua code into target file"},{ name : "--swf", deprecatedNames : ["-swf"], argument : { name : "<file>", insertion : "bin/${1:main}.swf", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "generate Flash SWF bytecode into target file"},{ name : "--neko", deprecatedNames : ["-neko"], argument : { name : "<file>", insertion : "bin/${1:main}.n", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "generate Neko bytecode into target file"},{ name : "--php", deprecatedNames : ["-php"], argument : { name : "<directory>", insertion : "bin/php", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.Directory}, description : "generate PHP code into target directory"},{ name : "--cpp", deprecatedNames : ["-cpp"], argument : { name : "<directory>", insertion : "bin/cpp", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.Directory}, description : "generate C++ code into target directory"},{ name : "--cppia", deprecatedNames : ["-cppia"], argument : { name : "<file>", insertion : "bin/${1:main}.cppia", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "generate Cppia bytecode into target file"},{ name : "--cs", deprecatedNames : ["-cs"], argument : { name : "<directory>", insertion : "bin/cs", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.Directory}, description : "generate C# code into target directory"},{ name : "--java", deprecatedNames : ["-java"], argument : { name : "<directory>", insertion : "bin/java", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.Directory}, description : "generate Java code into target directory"},{ name : "--jvm", deprecatedNames : ["-jvm"], argument : { name : "<file>", insertion : "bin/${1:main}.jar", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "generate JVM bytecode into target file"},{ name : "--python", deprecatedNames : ["-python"], argument : { name : "<file>", insertion : "bin/${1:main}.py", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "generate Python code into target file"},{ name : "--hl", deprecatedNames : ["-hl"], argument : { name : "<file>", insertion : "bin/${1:main}.hl", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "generate HashLink `.hl` bytecode or `.c` code into target file"},{ name : "--interp", deprecatedNames : ["-interp"], description : "interpret the program using internal macro system"},{ name : "--run", argument : { name : "<module> [args...]", insertion : "Main"}, description : "interpret a Haxe module with command line arguments"}]);
	_g.set(haxeLanguageServer_features_hxml_data_Category.Compilation,[{ name : "--class-path", shortName : "-p", deprecatedNames : ["-cp"], argument : { name : "<path>", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.Directory}, description : "add a directory to find source files"},{ name : "--main", shortName : "-m", deprecatedNames : ["-main"], argument : { name : "<class>", insertion : "Main"}, description : "select startup class"},{ name : "--library", shortName : "-L", deprecatedNames : ["-lib"], argument : { name : "<name[:ver]>", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.LibraryName}, description : "use a haxelib library"},{ name : "--define", shortName : "-D", argument : { name : "<var[=value]>", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.Define}, description : "define a conditional compilation flag"},{ name : "--resource", shortName : "-r", deprecatedNames : ["-resource"], argument : { name : "<file>[@name]", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "define a conditional compilation flag"},{ name : "--cmd", deprecatedNames : ["-cmd"], argument : { name : "<command>", insertion : "command"}, description : "run the specified command after successful compilation"},{ name : "--remap", argument : { name : "<package:target>", insertion : "${1:package}:${2:target}"}, description : "remap a package to another one"},{ name : "--macro", argument : { name : "<macro>", insertion : "macro"}, description : "call the given macro before typing anything else"},{ name : "--cwd", shortName : "-C", argument : { name : "<directory>", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.Directory}, description : "set current working directory"},{ name : "--haxelib-global", description : "pass `--global` argument to haxelib"}]);
	_g.set(haxeLanguageServer_features_hxml_data_Category.Optimization,[{ name : "--dce", deprecatedNames : ["-dce"], argument : { name : "[std|full|no]", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.Enum(haxeLanguageServer_features_hxml_data_Shared_DceEnumValues)}, description : "set the dead code elimination mode (default `std`)"},{ name : "--no-traces", description : "don't compile trace calls in the program"},{ name : "--no-output", description : "compiles but does not generate any file"},{ name : "--no-inline", description : "disable inlining"},{ name : "--no-opt", description : "disable code optimizations"}]);
	_g.set(haxeLanguageServer_features_hxml_data_Category.Debug,[{ name : "--verbose", shortName : "-v", description : "turn on verbose mode"},{ name : "--debug", deprecatedNames : ["-debug"], description : "add debug information to the compiled code"},{ name : "--times", description : "measure compilation times"}]);
	_g.set(haxeLanguageServer_features_hxml_data_Category.Batch,[{ name : "--next", description : "separate several haxe compilations"},{ name : "--each", description : "append preceding parameters to all Haxe compilations separated by `--next`"}]);
	_g.set(haxeLanguageServer_features_hxml_data_Category.Services,[{ name : "--xml", deprecatedNames : ["-xml"], argument : { name : "<file>", insertion : "bin/${1:types}.xml", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "generate XML types description"},{ name : "--json", argument : { name : "<file>", insertion : "bin/${1:types}.json", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "generate JSON types description"}]);
	_g.set(haxeLanguageServer_features_hxml_data_Category.CompilationServer,[{ name : "--connect", argument : { name : "<[host:]port>", insertion : "7000"}, description : "connect on the given port and run commands there"}]);
	{
		let _this = [9.,10.,10.1,10.2,10.3,11.,11.1,11.2,11.3,11.4,11.5,11.6,11.7,11.8,11.9,12.0,13.0,14.0,15.0,16.0,17.0,18.0,19.0,20.0,21.0,22.0,23.0,24.0,25.0,26.0,27.0,28.0,29.0,31.0,32.0];
		let result = new Array(_this.length);
		let _g1 = 0;
		let _g2 = _this.length;
		while(_g1 < _g2) {
			let i = _g1++;
			let version = _this[i];
			result[i] = { name : version == null ? "null" : "" + version, description : null};
		}
		_g.set(haxeLanguageServer_features_hxml_data_Category.TargetSpecific,[{ name : "--swf-version", argument : { name : "<version>", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.Enum(result)}, description : "change the SWF version"},{ name : "--swf-header", argument : { name : "<header>", insertion : "${1:width}:${2:height}:${3:fps}:${4:color}"}, description : "define SWF header (`width:height:fps:color`)"},{ name : "--flash-strict", description : "more type strict flash API"},{ name : "--swf-lib", argument : { name : "<file>", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "add the SWF library to the compiled SWF"},{ name : "--swf-lib-extern", argument : { name : "<file>", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "use the SWF library for type checking"},{ name : "--java-lib", argument : { name : "<file>", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "add an external JAR or directory of JAR files"},{ name : "--java-lib-extern", argument : { name : "<file>", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "use an external JAR or directory of JAR files for type checking"},{ name : "--net-lib", argument : { name : "<file>[@std]", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "add an external .NET DLL file"},{ name : "--net-std", argument : { name : "<file>", kind : haxeLanguageServer_features_hxml_data_ArgumentKind.File}, description : "add a root std .NET DLL search path"},{ name : "--c-arg", argument : { name : "<arg>", insertion : "arg"}, description : "pass option `<arg>` to the native Java/C# compiler"}]);
	}
	_g.set(haxeLanguageServer_features_hxml_data_Category.Miscellaneous,[]);
	{
		let _g3 = 0;
		let _g4 = [];
		let e = _g.iterator();
		while(e.hasNext()) {
			let x = $getIterator(e.next());
			while(x.hasNext()) _g4.push(x.next());
		}
		while(_g3 < _g4.length) {
			let flag = _g4[_g3];
			++_g3;
			flag.description = haxeLanguageServer_extensions_StringExtensions_capitalize(flag.description) + ".";
		}
	}
	$r = _g;
	return $r;
}(this));
haxeLanguageServer_helper_DocHelper.reStartsWhitespace = new EReg("^\\s*","");
haxeLanguageServer_helper_DocHelper.reEndsWithWhitespace = new EReg("\\s*$","");
haxeLanguageServer_helper_HaxePosition.positionRe = new EReg("^(.+):(\\d+): (?:lines (\\d+)-(\\d+)|character(?:s (\\d+)-| )(\\d+))$","");
haxeLanguageServer_helper_HaxePosition.properFileNameCaseCache = new haxe_ds_StringMap();
haxeLanguageServer_helper_HaxePosition.isWindows = Sys.systemName() == "Windows";
haxeLanguageServer_helper_PathHelper.reUpperCaseDriveLetter = new EReg("^([A-Z]:)","");
haxeLanguageServer_helper_SemVer.reVersion = new EReg("^(\\d+)\\.(\\d+)\\.(\\d+)(?:[-]([a-z0-9.-]+))?(?:[+]([a-z0-9.-]+))?","i");
haxeLanguageServer_helper_StringHelper.stripAnsi = new EReg("[\x1B][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]","g");
haxeLanguageServer_helper_TypeHelper.groupRegex = new EReg("\\$(\\d+)","g");
haxeLanguageServer_helper_TypeHelper.parenRegex = new EReg("^\\((.*)\\)$","");
haxeLanguageServer_helper_TypeHelper.argNameRegex = new EReg("^(\\??\\w+) : ","");
haxeLanguageServer_helper_TypeHelper.monomorphRegex = new EReg("^Unknown<\\d+>$","");
haxeLanguageServer_helper_TypeHelper.nullRegex = new EReg("^Null<(\\$\\d+)>$","");
haxeLanguageServer_helper_TypeHelper.packagePathsRegex = new EReg("((?:_*[a-z]\\w*\\.)*)(?=_*[A-Z])","g");
haxeLanguageServer_helper_TypeHelper.subtypePackageRegex = new EReg("\\b[A-Z]\\w*\\.[A-Z]","");
var haxeLanguageServer_helper_VscodeCommands_TriggerSuggest = { title : "Trigger Suggest", command : "editor.action.triggerSuggest", 'arguments' : []};
var haxeLanguageServer_helper_VscodeCommands_TriggerParameterHints = { title : "Trigger Parameter Hints", command : "editor.action.triggerParameterHints", 'arguments' : []};
haxeLanguageServer_protocol_DisplayPrinter.castRegex = new EReg("^(cast )+","");
haxeLanguageServer_server_DisplayRequest.stdinSepBuf = js_node_buffer_Buffer.alloc(1,1);
haxeLanguageServer_server_HaxeConnection._hx_skip_constructor = false;
haxeLanguageServer_server_HaxeConnection.reTrailingNewline = new EReg("\r?\n$","");
hxparse_LexEngine.EMPTY = [];
hxparse_LexEngine.ALL_CHARS = [new hxparse__$LexEngine_CharRange(0,255)];
haxeparser_HaxeLexer.keywords = (function($this) {
	var $r;
	let _g = new haxe_ds_StringMap();
	_g.h["abstract"] = haxeparser_Keyword.KwdAbstract;
	_g.h["break"] = haxeparser_Keyword.KwdBreak;
	_g.h["case"] = haxeparser_Keyword.KwdCase;
	_g.h["cast"] = haxeparser_Keyword.KwdCast;
	_g.h["catch"] = haxeparser_Keyword.KwdCatch;
	_g.h["class"] = haxeparser_Keyword.KwdClass;
	_g.h["continue"] = haxeparser_Keyword.KwdContinue;
	_g.h["default"] = haxeparser_Keyword.KwdDefault;
	_g.h["do"] = haxeparser_Keyword.KwdDo;
	_g.h["dynamic"] = haxeparser_Keyword.KwdDynamic;
	_g.h["else"] = haxeparser_Keyword.KwdElse;
	_g.h["enum"] = haxeparser_Keyword.KwdEnum;
	_g.h["extends"] = haxeparser_Keyword.KwdExtends;
	_g.h["extern"] = haxeparser_Keyword.KwdExtern;
	_g.h["false"] = haxeparser_Keyword.KwdFalse;
	_g.h["final"] = haxeparser_Keyword.KwdFinal;
	_g.h["for"] = haxeparser_Keyword.KwdFor;
	_g.h["function"] = haxeparser_Keyword.KwdFunction;
	_g.h["if"] = haxeparser_Keyword.KwdIf;
	_g.h["implements"] = haxeparser_Keyword.KwdImplements;
	_g.h["import"] = haxeparser_Keyword.KwdImport;
	_g.h["in"] = haxeparser_Keyword.KwdIn;
	_g.h["inline"] = haxeparser_Keyword.KwdInline;
	_g.h["interface"] = haxeparser_Keyword.KwdInterface;
	_g.h["macro"] = haxeparser_Keyword.KwdMacro;
	_g.h["new"] = haxeparser_Keyword.KwdNew;
	_g.h["null"] = haxeparser_Keyword.KwdNull;
	_g.h["operator"] = haxeparser_Keyword.KwdOperator;
	_g.h["overload"] = haxeparser_Keyword.KwdOverload;
	_g.h["override"] = haxeparser_Keyword.KwdOverride;
	_g.h["package"] = haxeparser_Keyword.KwdPackage;
	_g.h["private"] = haxeparser_Keyword.KwdPrivate;
	_g.h["public"] = haxeparser_Keyword.KwdPublic;
	_g.h["return"] = haxeparser_Keyword.KwdReturn;
	_g.h["static"] = haxeparser_Keyword.KwdStatic;
	_g.h["switch"] = haxeparser_Keyword.KwdSwitch;
	_g.h["this"] = haxeparser_Keyword.KwdThis;
	_g.h["throw"] = haxeparser_Keyword.KwdThrow;
	_g.h["true"] = haxeparser_Keyword.KwdTrue;
	_g.h["try"] = haxeparser_Keyword.KwdTry;
	_g.h["typedef"] = haxeparser_Keyword.KwdTypedef;
	_g.h["untyped"] = haxeparser_Keyword.KwdUntyped;
	_g.h["using"] = haxeparser_Keyword.KwdUsing;
	_g.h["var"] = haxeparser_Keyword.KwdVar;
	_g.h["while"] = haxeparser_Keyword.KwdWhile;
	$r = _g;
	return $r;
}(this));
haxeparser_HaxeLexer.buf = new StringBuf();
haxeparser_HaxeLexer.tok = hxparse_Lexer.buildRuleset([{ rule : "", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Eof);
}},{ rule : "[\r\n\t ]+", func : function(lexer) {
	return lexer.token(haxeparser_HaxeLexer.tok);
}},{ rule : "((0x)(([0-9a-fA-F](_?[0-9a-fA-F])*)+))((_?[iu](([1-9](_?[0-9])*)|0)+)?)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_HaxeLexer.splitIntSuffix(lexer.current));
}},{ rule : "(([1-9](_?[0-9])*)|0)((_?[iu](([1-9](_?[0-9])*)|0)+)?)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_HaxeLexer.splitIntSuffix(lexer.current));
}},{ rule : "(([1-9](_?[0-9])*)|0)((_?f(([1-9](_?[0-9])*)|0)+)?)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_HaxeLexer.splitFloatSuffix(lexer.current));
}},{ rule : "(((([1-9](_?[0-9])*)|0)(\\.))(([0-9](_?[0-9])*)+))((_?f(([1-9](_?[0-9])*)|0)+)?)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_HaxeLexer.splitFloatSuffix(lexer.current));
}},{ rule : "((\\.)(([0-9](_?[0-9])*)+))((_?f(([1-9](_?[0-9])*)|0)+)?)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_HaxeLexer.splitFloatSuffix(lexer.current));
}},{ rule : "(((([1-9](_?[0-9])*)|0)([eE][\\+\\-]?))(([0-9](_?[0-9])*)+))((_?f(([1-9](_?[0-9])*)|0)+)?)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_HaxeLexer.splitFloatSuffix(lexer.current));
}},{ rule : "(((([1-9](_?[0-9])*)|0)(\\.[0-9]*[eE][\\+\\-]?))(([0-9](_?[0-9])*)+))((_?f(([1-9](_?[0-9])*)|0)+)?)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_HaxeLexer.splitFloatSuffix(lexer.current));
}},{ rule : "(([1-9](_?[0-9])*)|0)(\\.\\.\\.)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.IntInterval(HxOverrides.substr(lexer.current,0,-3)));
}},{ rule : "//[^\n\r]*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.CommentLine(HxOverrides.substr(lexer.current,2,null)));
}},{ rule : "+\\+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpIncrement));
}},{ rule : "--", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpDecrement));
}},{ rule : "~", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpNegBits));
}},{ rule : "%=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMod)));
}},{ rule : "&=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAnd)));
}},{ rule : "|=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpOr)));
}},{ rule : "^=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpXor)));
}},{ rule : "+=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAdd)));
}},{ rule : "-=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpSub)));
}},{ rule : "*=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMult)));
}},{ rule : "/=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpDiv)));
}},{ rule : "<<=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShl)));
}},{ rule : "|\\|=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpBoolOr)));
}},{ rule : "&&=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpBoolAnd)));
}},{ rule : "?\\?=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpNullCoal)));
}},{ rule : "==", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpEq));
}},{ rule : "!=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpNotEq));
}},{ rule : "<=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLte));
}},{ rule : "&&", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpBoolAnd));
}},{ rule : "|\\|", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpBoolOr));
}},{ rule : "<<", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpShl));
}},{ rule : "->", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Arrow);
}},{ rule : "\\.\\.\\.", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Spread);
}},{ rule : "=>", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpArrow));
}},{ rule : "!", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpNot));
}},{ rule : "(<)([$|:A-Z_a-z\\u{x00C0}-\\u{x00D6}\\u{x00D8}-\\u{x00F6}\\u{x00F8}-\\u{x002FF}\\u{x00370}-\\u{x0037D}\\u{x0037F}-\\u{x001FFF}\\u{x00200C}-\\u{x00200D}\\u{x002070}-\\u{x00218F}\\u{x002C00}-\\u{x002FEF}\\u{x003001}-\\u{x00D7FF}\\u{x00F900}-\\u{x00FDCF}\\u{x00FDF0}-\\u{x00FFFD}\\u{x0010000}-\\u{x00EFFFF}][$|:A-Z_a-z\\u{x00C0}-\\u{x00D6}\\u{x00D8}-\\u{x00F6}\\u{x00F8}-\\u{x002FF}\\u{x00370}-\\u{x0037D}\\u{x0037F}-\\u{x001FFF}\\u{x00200C}-\\u{x00200D}\\u{x002070}-\\u{x00218F}\\u{x002C00}-\\u{x002FEF}\\u{x003001}-\\u{x00D7FF}\\u{x00F900}-\\u{x00FDCF}\\u{x00FDF0}-\\u{x00FFFD}\\u{x0010000}-\\u{x00EFFFF}\\-.0-9\\u{x00B7}\\u{x0300}-\\u{x036F}\\u{x203F}-\\u{x2040}]*)", func : function(lexer) {
	return haxeparser_HaxeLexer.inlineMarkup(lexer);
}},{ rule : "<", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLt));
}},{ rule : ">", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpGt));
}},{ rule : ";", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Semicolon);
}},{ rule : ":", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.DblDot);
}},{ rule : ",", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Comma);
}},{ rule : "?\\.", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.QuestionDot);
}},{ rule : "\\.", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Dot);
}},{ rule : "%", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpMod));
}},{ rule : "&", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAnd));
}},{ rule : "|", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpOr));
}},{ rule : "^", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpXor));
}},{ rule : "+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAdd));
}},{ rule : "*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpMult));
}},{ rule : "/", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpDiv));
}},{ rule : "-", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpSub));
}},{ rule : "=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign));
}},{ rule : "[", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BkOpen);
}},{ rule : "]", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BkClose);
}},{ rule : "{", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BrOpen);
}},{ rule : "}", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BrClose);
}},{ rule : "\\(", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.POpen);
}},{ rule : "\\)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.PClose);
}},{ rule : "?\\?", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpNullCoal));
}},{ rule : "?", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Question);
}},{ rule : "@", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.At);
}},{ rule : "\"", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	let pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.string);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	let token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxeparser_Constant.CString(haxeparser_HaxeLexer.unescape(haxeparser_HaxeLexer.buf.b,haxeparser_HaxeLexer.mkPos(pmin)),haxe_macro_StringLiteralKind.DoubleQuotes)));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "'", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	let pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.string2);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	let token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxeparser_Constant.CString(haxeparser_HaxeLexer.unescape(haxeparser_HaxeLexer.buf.b,haxeparser_HaxeLexer.mkPos(pmin)),haxe_macro_StringLiteralKind.SingleQuotes)));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "~/", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	let pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	let info;
	try {
		info = lexer.token(haxeparser_HaxeLexer.regexp);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedRegExp,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	let token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxeparser_Constant.CRegexp(haxeparser_HaxeLexer.buf.b,info.opt)));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "/\\*", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	let pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.comment);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedComment,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	let token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Comment(haxeparser_HaxeLexer.buf.b));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "(#)(_*[a-z][a-zA-Z0-9_]*|_+|_+[0-9][_a-zA-Z0-9]*)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Sharp(HxOverrides.substr(lexer.current,1,null)));
}},{ rule : "$[_a-zA-Z0-9]*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Dollar(HxOverrides.substr(lexer.current,1,null)));
}},{ rule : "_*[a-z][a-zA-Z0-9_]*|_+|_+[0-9][_a-zA-Z0-9]*", func : function(lexer) {
	let kwd = haxeparser_HaxeLexer.keywords.h[lexer.current];
	if(kwd != null) {
		return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Kwd(kwd));
	} else {
		return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxeparser_Constant.CIdent(lexer.current)));
	}
}},{ rule : "_*[A-Z][a-zA-Z0-9_]*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxeparser_Constant.CIdent(lexer.current)));
}}],"tok");
haxeparser_HaxeLexer.string = hxparse_Lexer.buildRuleset([{ rule : "\\\\\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\\\";
	return lexer.token(haxeparser_HaxeLexer.string);
}},{ rule : "\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\";
	return lexer.token(haxeparser_HaxeLexer.string);
}},{ rule : "\\\\\"", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\"";
	return lexer.token(haxeparser_HaxeLexer.string);
}},{ rule : "\"", func : function(lexer) {
	return new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax;
}},{ rule : "[^\\\\\"]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.string);
}}],"string");
haxeparser_HaxeLexer.string2 = hxparse_Lexer.buildRuleset([{ rule : "\\\\\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\\\";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "\\\\'", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "'";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "'", func : function(lexer) {
	return new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax;
}},{ rule : "($$)|(\\$)|$", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "$";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "${", func : function(lexer) {
	let pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	try {
		lexer.token(haxeparser_HaxeLexer.codeString);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedCode,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "[^$\\\\']+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.string2);
}}],"string2");
haxeparser_HaxeLexer.codeString = hxparse_Lexer.buildRuleset([{ rule : "{|/", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "}", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
}},{ rule : "\"", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(34);
	let pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.string);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(34);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "'", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(39);
	let pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.string2);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(39);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "/\\*", func : function(lexer) {
	let pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.comment);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedComment,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "//[^\n\r]*", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "[^/\"'{}\n\r]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "[\r\n\t ]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}}],"codeString");
haxeparser_HaxeLexer.comment = hxparse_Lexer.buildRuleset([{ rule : "*/", func : function(lexer) {
	return new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax;
}},{ rule : "*", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "*";
	return lexer.token(haxeparser_HaxeLexer.comment);
}},{ rule : "[^\\*]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.comment);
}}],"comment");
haxeparser_HaxeLexer.regexp = hxparse_Lexer.buildRuleset([{ rule : "\\\\/", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "/";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\r", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\r";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\n", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\n";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\t", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\t";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\[\\\\$\\.*+\\^|{}\\[\\]()?\\-0-9]", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\[wWbBsSdDx]", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\[uU][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\[^\\]", func : function(lexer) {
	throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedRegExp,haxeparser_HaxeLexer.mkPos(new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos))));
}},{ rule : "/", func : function(lexer) {
	return lexer.token(haxeparser_HaxeLexer.regexp_options);
}},{ rule : "[^\\\\/\r\n]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.regexp);
}}],"regexp");
haxeparser_HaxeLexer.regexp_options = hxparse_Lexer.buildRuleset([{ rule : "[gimsu]*", func : function(lexer) {
	return { pmax : new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax, opt : lexer.current};
}}],"regexp_options");
jsonrpc_node__$MessageReader_MessageBuffer.CR = js_node_buffer_Buffer.from("\r","ascii")[0];
jsonrpc_node__$MessageReader_MessageBuffer.LF = js_node_buffer_Buffer.from("\n","ascii")[0];
sys_io_File.copyBuf = js_node_buffer_Buffer.alloc(65536);
tokentree_TokenStream.MODE = tokentree_TokenStreamMode.Strict;
haxeLanguageServer_Main_main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
